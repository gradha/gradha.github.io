<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rants from the Ballmer Peak</title>
  <link href="http://gradha.github.io/" />
  <link href="http://gradha.github.io/feed.xml" rel="self" />
  <id>http://gradha.github.io/</id>
  <generator>ipsumgenera</generator>
  <updated>2013-10-01T00:08:51Z</updated>
    <entry>
      <title>Users prefer static linking</title>
      <link rel="alternate" type="text/html" href="http://gradha.github.io/articles/2013/08/users-prefer-static-linking.html"/>
      <id>http://gradha.github.io/articles/2013/08/users-prefer-static-linking.html</id>
      <updated>2013-08-03T12:31:00Z</updated>
      <author><name>Grzegorz Adam Hankiewicz</name></author>
      <content type="html">
        &lt;h1&gt;What is static linking&lt;/h1&gt;&lt;p&gt;Users prefer static linking. That is, if software users would actually know what static linking is. Most users don't know anything about software, how it is built, or how much time you pour into it, but they know one thing: if it works, they expect it to keep working.&lt;/p&gt;
&lt;p&gt;That's where the static linking is important. When a program is compiled a &lt;span style=&quot;font-style: italic;&quot;&gt;binary&lt;/span&gt; is generated. The binary can have dynamic dependencies, which means that it relies on external code that is loaded every time the binary is loaded into memory to be executed. On the other hand, a statically linked binary will &lt;span style=&quot;font-style: italic;&quot;&gt;copy&lt;/span&gt; all (or some) of the external code it requires into the final binary itself.&lt;/p&gt;
&lt;p&gt;The advantage of static linking is that you can copy the binary to another system and it will keep running, something which may not happen if the other system environment doesn't also have the same external library installed. The cost to pay for this is increased binary size, and there are also other drawbacks like the operating system not being able to share the library between processes and having duplicate instances of the same code in memory during execution.&lt;/p&gt;
&lt;p&gt;Mainstream consumer operating systems (Windows, Linux, OS X) provide a big set of shared libraries, allowing programmers to not have to care distributing their own copy with the program. But that soon started to be a problem: different versions of each operating system and/or library could be problematic for the programs. This is usually known as &lt;a href=&quot;https://en.wikipedia.org/wiki/DLL_Hell&quot;&gt;DLL Hell&lt;/a&gt;, where installation of program A on the end user machine brings in version 1 of a shared library, and installation of program B brings in an incompatible version 2 of that same shared library.&lt;/p&gt;
&lt;p&gt;Due to poor DLL versioning or programmer carelessness the end user system becomes unstable. The best is when it actually crashes, because end users &lt;span style=&quot;font-style: italic;&quot;&gt;notice&lt;/span&gt; there is something wrong. The problem is when the programs don't crash immediately, they may crash later, at random or specific times, or behave in not completely correct behaviour, but not exactly right.&lt;/p&gt;
&lt;p&gt;Nowadays even bigger culprits of dynamic linking are dynamic or interpreted languages. Instead of producing compiled code, interpreted languages like &lt;a href=&quot;http://www.python.org&quot;&gt;Python&lt;/a&gt; or &lt;a href=&quot;http://www.ruby-lang.org&quot;&gt;Ruby&lt;/a&gt; are transformed into machine instructions each time they are run. Now they don't only depend on the availability of the dynamic libraries they require, they also depend on the version of the interpreter. If you try to run a script written for say Python 2.5, it won't work on Python 3 because of language incompatibilities. This ends up creating a divide between programmers and affects end users too.&lt;/p&gt;
&lt;p&gt;If you thought your problems are only here, don't look at operating system upgrades, the main reason people are &lt;span style=&quot;font-style: italic;&quot;&gt;scared to death&lt;/span&gt; to upgrade their system.  If you know of a computer end user who is not scared to death of upgrades it is only because he hasn't suffered the experience of &lt;span style=&quot;font-style: italic;&quot;&gt;upgrading&lt;/span&gt; the machine to only find out (sometimes weeks later) that a critical program stopped working because it is incompatible with the new version of the operating system. This causes pain, gnashing of teeth and hatred towards computers and/or technology.&lt;/p&gt;
&lt;h1&gt;Levels of portability&lt;/h1&gt;&lt;p&gt;The situations explained above don't actually relate all to static linking, or can't be applied at all, since there is no concept of static linking for interpreted languages. So maybe at this point we should rephrase the term of static linking for the end user as a general problem of portability. We also need to consider different levels of portability, for instance:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;The user installed some software, and it works fine. The operating systems has the feature of multiple users and only the user who installed the software can run the program despite it being accessible to other users. Maybe the problem is the installation copied critical files to the user's private directories which are not available to the other users.&lt;/li&gt;&lt;li&gt;The user copies the program to another machine, apparently using the same operating system version. However, it won't run at all. Maybe the &lt;span style=&quot;font-style: italic;&quot;&gt;major&lt;/span&gt; operating system version is the same, but sometimes operating systems have different minor versions, maybe one was upgraded to the latest security patch and this breaks the program's behaviour.&lt;/li&gt;&lt;li&gt;The user copies the program to another machine or upgrades the operating system. The program won't run at all, sometimes without giving any useful explanation.&lt;/li&gt;&lt;li&gt;The user wants to run the software in a cybercafe, or is otherwise somewhere else on lent hardware. The user copies all program files to an USB stick, but surprisingly it doesn't run there.  Why? Even though there are projects to create &lt;a href=&quot;http://portableapps.com&quot;&gt;portable versions of applications&lt;/a&gt; most programs don't expect to be run in such a fashion. Also, even if your spreadsheet software runs you don't want it to leave your bank details on a public computer at a cybercafe just because it thought for convenience that you will always have a private user data folder on the hard drive.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;More different situations could be described, but one thing to note is a program can fall into several of these situations at the same time, and it mostly depends on two factors: technologies used and programmer's interest in portability. Yes, portability is a feature decided by programmers upon their end users. And unfortunately few people care.&lt;/p&gt;
&lt;h1&gt;The solution&lt;/h1&gt;&lt;p&gt;The solution for portability is simple: you copy, bundle, or embed whatever your program needs into your binary. For instance, Windows programs may want to avoid writing into the registry so that copying the folder where the software was installed is enough to copy everything to a different machine and run it there.&lt;/p&gt;
&lt;p&gt;On OS X this is abstracted to the user through the use of &lt;a href=&quot;https://en.wikipedia.org/wiki/Application_bundle&quot;&gt;application bundles&lt;/a&gt;. These are normal directories with a special structure the operating system recognizes and treads uniformly as a single entity. The Finder on OS X won't allow you to copy only part of the bundle's directory somewhere else, and should it fail, it will delete the incomplete bundle. Even if it is left there broken, the system wont run it and will likely draw a translucent stop sign on its icon.&lt;/p&gt;
&lt;p&gt;Linuxâ€¦ Linux users usually don't care. They brag about sophisticate software management programs (oh, the meta) and tell end users they are crazy because they don't want to learn how to use it or search the net for solutions to a dependency, which can be solved, but requires some obscure option/command line switch to work.&lt;/p&gt;
&lt;p&gt;Mobile software stores have adopted the bundle paradigm: they include everything required to run except the basic libraries provided by the system which are (in theory) guaranteed to be the same on all future OS versions. This allows for example software written for the iPhone 3G to still run on the iPhone 5 without updates.&lt;/p&gt;
&lt;p&gt;Note that bundling everything together still requires the program to be &lt;span style=&quot;font-style: italic;&quot;&gt;aware&lt;/span&gt; of being run in this kind of environment. Fortunately for end users the strict rules for iOS and Android are creating more awareness towards the usual &lt;span style=&quot;font-style: italic;&quot;&gt;sandboxes&lt;/span&gt;, so much in fact that OS X desktop users already have an equivalent app store with &lt;span style=&quot;font-style: italic;&quot;&gt;sandboxing&lt;/span&gt; and Windows seems to be following suit.&lt;/p&gt;
&lt;h1&gt;Software proud to be portable&lt;/h1&gt;&lt;p&gt;There are not many developer oriented tools which are written with portability in mind. The authors of &lt;a href=&quot;https://sqlite.org&quot;&gt;Sqlite&lt;/a&gt; and &lt;a href=&quot;http://fossil-scm.org/index.html/doc/trunk/www/index.wiki&quot;&gt;Fossil&lt;/a&gt; are one exceptional case. They aim for the highest level of portability: a single binary which can be copied anywhere and it works.&lt;/p&gt;
&lt;p&gt;Nothing particularly new, but worth of appraise. Long forgotten MSDOS programmers also developed funny &lt;span style=&quot;font-style: italic;&quot;&gt;tricks&lt;/span&gt; to provide single binary portability (remember the times when having a hard disk was rare?). The most notable one was appending additional resources to the binary itself. The operating system would load the whole binary into memory but will ignore the extraneous trailing data. Instead, the application could read it to avoid littering the disk with extra files.&lt;/p&gt;
&lt;p&gt;Surprisingly this technique still works on today's systems. Even more, programs like &lt;a href=&quot;http://upx.sourceforge.net&quot;&gt;UPX&lt;/a&gt; which compress binaries also know how to handle trailing data and are known to work with binary appending tools, like the one provided by the &lt;a href=&quot;http://alleg.sourceforge.net&quot;&gt;C game programming library Allegro&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;However, USB level portability is hard to find for most programming languages compilers and interpreters. The closest may be the &lt;a href=&quot;http://nimrod-code.org&quot;&gt;Nimrod programming language&lt;/a&gt;, since it compiles everything into a single nimrod binary, which can be run everywhere.&lt;/p&gt;
&lt;p&gt;The problem is, will it work? Compiling most source code will require using modules from the standard library. But where are these? Scattered somewhere else. So while it is true that Nimrod produces a statically linked contained binary, it is effectively not portable if for 99% of its usage it depends on external files. Another example, you could be using different nimrod compiler versions for testing, and one works with a specific version of the standard library, but a previous compiled binary won't work due to changes in the language. This requires you to maintain different versions of the standard library module tree, and make sure to point to the correct one with each binary if you actually need to switch.&lt;/p&gt;
&lt;p&gt;Certainly developers are special &lt;span style=&quot;font-style: italic;&quot;&gt;power&lt;/span&gt; users, and they are expected to know how to install tool dependencies, search the net for obscure incantations of poorly known commands, and are usually resilient to repeated failure, with a special knack for banging their head against a wall until they figure out what is wrong.&lt;/p&gt;
&lt;p&gt;However, couldn't we all be nice and provide 100% portable tools too? Why do we provide portability to end users yet again and again we torture ourselves with DLL Hell? Do we enjoy it so much?&lt;/p&gt;
&lt;p&gt;&lt;pre class='code'&gt;&lt;span class=&quot;Operator&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;nimrod&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;forum&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;nim&lt;/span&gt;
&lt;span class=&quot;Operator&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;Operator&quot;&gt;./&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;forum&lt;/span&gt;
&lt;span class=&quot;Identifier&quot;&gt;could&lt;/span&gt; &lt;span class=&quot;Keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;libcairo&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;dylib&lt;/span&gt;
&lt;/pre&gt; &lt;/p&gt;

      </content>
    </entry>
</feed>
