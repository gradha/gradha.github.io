<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rants from the Ballmer Peak</title>
  <link href="http://gradha.github.io/" />
  <link href="http://gradha.github.io/feed.xml" rel="self" />
  <id>http://gradha.github.io/</id>
  <generator>ipsumgenera</generator>
  <updated>2014-01-11T20:50:26Z</updated>
    <entry>
      <title>Small big mistakes</title>
      <link rel="alternate" type="text/html" href="http://gradha.github.io/articles/2014/01/small-big-mistakes.html"/>
      <id>http://gradha.github.io/articles/2014/01/small-big-mistakes.html</id>
      <updated>2014-01-10T23:01:00Z</updated>
      <author><name>Grzegorz Adam Hankiewicz</name></author>
      <content type="html">
        &lt;h1&gt;Small big mistakes&lt;/h1&gt;&lt;p&gt;Open software is cool. Everybody can join in and tinker with the code. But sometimes the entrance threshold is too high and projects are kept &lt;span style=&quot;font-style: italic;&quot;&gt;under the radar&lt;/span&gt; for most people. I believe the &lt;a href=&quot;http://nimrod-lang.org&quot;&gt;Nimrod programming language&lt;/a&gt; by &lt;a href=&quot;https://github.com/Araq&quot;&gt;Andreas Rumpf&lt;/a&gt; slightly tiptoes into the &lt;span style=&quot;font-style: italic;&quot;&gt;could-be-much-better-with-a-little-more-care&lt;/span&gt;. The disadvantage of Nimrod is that it is a programming language, and a really full fledged one which beats most commonly used ones in terms of flexibility and amazing features. Most potential contributors are intimidated by the initial complexity of such software (not everybody writes compilers for breakfast).&lt;/p&gt;
&lt;p&gt;But even more pitiful is what I consider basic administration mistakes which discourage potential users. It is not fun when &lt;a href=&quot;https://github.com/Araq/Nimrod/issues/750&quot;&gt;users have to report that the build instructions fail&lt;/a&gt; (wait a second, why are build instructions not part of the &lt;a href=&quot;http://build.nimrod-lang.org/&quot;&gt;continuous integration farm&lt;/a&gt;?) and the issue is neglected for weeks or months. It is even less funny that this is neglected because Andreas himself has to manually upload files to the website, and starts to look like a bad joke when &lt;span style=&quot;font-style: italic;&quot;&gt;after&lt;/span&gt; updating the website, some pages are still missing, so he goes and uploads &lt;span style=&quot;font-style: italic;&quot;&gt;again&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;For somebody capable of creating a programming language the only possible answer is lack of attention to releases. When a lazy programmer is confronted with a manual task, there are two possible paths: avoid the task or automate the hell out of it. In this case, Andreas took the worst path for the visibility of Nimrod, as new users come and find something which doesn't work at first glance. Why should they keep bothering when there's a constant torrent of new shiny programming languages out there competing for everybody's attention? In more technical terms, it doesn't matter how many users have write access to the repository, because updating the website still has a &lt;a href=&quot;http://www.crummy.com/writing/segfault.org/Bus.html&quot;&gt;bus factor&lt;/a&gt; bottleneck.&lt;/p&gt;
&lt;p&gt;Some time ago &lt;a href=&quot;https://github.com/nimrod-code/babel&quot;&gt;Babel, the official package manager for Nimrod&lt;/a&gt; was in a state of flux where some stuff did not work correctly, or required some prodding. I don't understand what is so hard about keeping the repository &lt;span style=&quot;font-style: italic;&quot;&gt;master&lt;/span&gt; branch compilable. Maybe I'm weird. But it get's better!  Here's something to &lt;a href=&quot;http://knowyourmeme.com/memes/facepalm&quot;&gt;facepalm&lt;/a&gt; if you want to use Babel to install &lt;a href=&quot;https://github.com/nimrod-code/Aporia&quot;&gt;Aporia&lt;/a&gt;, the &lt;span style=&quot;font-style: italic;&quot;&gt;official&lt;/span&gt; Nimrod editor, linked from the &lt;a href=&quot;http://nimrod-lang.org&quot;&gt;Nimrod webpage&lt;/a&gt;:&lt;pre class='literal'&gt;
$ babel install aporia
Downloading aporia into /tmp/babel/aporia using git...
Found tags...
blah
blah
more blah
and then…
FAILURE: Specified directory does not contain a .babel file.
$&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;So the &lt;span style=&quot;font-style: italic;&quot;&gt;secret handshake&lt;/span&gt; this time is to run &lt;code&gt;babel install aporia#head&lt;/code&gt;. Totally obvious. The Aporia repository uses tags, but unfortunately the last one didn't have a &lt;code&gt;.babel&lt;/code&gt; file with the package info, so the &lt;code&gt;#head&lt;/code&gt; suffix fixes that. As if version numbers were &lt;span style=&quot;font-style: italic;&quot;&gt;expensive&lt;/span&gt; and you could not simply bump the version number and re tag the repository with the added file. On the bright side Aporia specifies this in the &lt;a href=&quot;https://github.com/nimrod-code/Aporia#compiling&quot;&gt;compiling section of the README&lt;/a&gt;, but it is a weird bright side to be, demanding all your potential users to jump through hoops when you can easily avoid that collective pain.&lt;/p&gt;
&lt;p&gt;But it all makes you wonder: how many people did find Aporia listed in Babel's &lt;code&gt;list&lt;/code&gt; command output and tried to install it? Hint: IRC logs show a few. How many didn't bother asking on IRC? We will never know… How many users did tried to compile Babel during the time it was &lt;span style=&quot;font-style: italic;&quot;&gt;unstable&lt;/span&gt;? Hopefully few. How many users did Nimrod lose to outdated github build instructions, since pretty much every other Nimrod software in active development requires the git version? These are all trivial things to solve really.&lt;/p&gt;
&lt;p&gt;Oh, and how much do I hate &lt;a href=&quot;http://felixge.de/2013/03/11/the-pull-request-hack.html&quot;&gt;people graciously giving commit access to github repositories&lt;/a&gt;. Let me explain: if this works for you it is only because you are a one man shop or don't really care about the project and are looking for somebody to replace you. Can you imagine a project like &lt;a href=&quot;http://www.webkit.org&quot;&gt;Webkit&lt;/a&gt; or &lt;a href=&quot;https://www.kernel.org&quot;&gt;the Linux kernel&lt;/a&gt; giving out write access to just about everybody? Not going to happen, that software has value, and random changes by random people are unlikely to increase value. Sorry, the &lt;span style=&quot;font-style: italic;&quot;&gt;pull request hack&lt;/span&gt; only works if your project has essentially no value to you, or if you think 100% of humans are good, something which is &lt;a href=&quot;http://www.penny-arcade.com/comic/2004/03/19/&quot;&gt;easily disputed&lt;/a&gt;. It's the reason we have &lt;a href=&quot;https://en.wikipedia.org/wiki/Captcha&quot;&gt;captchas&lt;/a&gt; to give our opinion on many websites.&lt;/p&gt;
&lt;p&gt;Unfortunately I'm preaching to the walls: in my &lt;span style=&quot;font-style: italic;&quot;&gt;professional&lt;/span&gt; life as a software developer I've seen even worse blunders in commercial software. You know, the one where people's heads roll when something goes wrong. So my theory is that most people doing open source software simply replicate what they have learned at work. Or worse, are too lazy to even do that minimum effort!&lt;/p&gt;
&lt;p&gt;That's when I &lt;code&gt;&amp;lt;inception_bwaaaa&amp;gt;&lt;/code&gt; &lt;span style=&quot;font-style: italic;&quot;&gt;step in to save the world of software&lt;/span&gt; &lt;code&gt;&amp;lt;/inception_bwaaaa&amp;gt;&lt;/code&gt;. Actually, I did read recently some hilarious articles by &lt;a href=&quot;https://research.microsoft.com/en-us/people/mickens/&quot;&gt;James Mickens&lt;/a&gt; (scroll to the bottom of that page, or find the extracts and direct links at the &lt;a href=&quot;http://programmingisterrible.com/post/72437339273/james-mickens-the-funniest-person-in-microsoft&quot;&gt;Programming is terrible blog&lt;/a&gt; which is also a nice read), so I thought to myself, hey, why not try and write something absurd while being semi serious about the issue? Also, it seems that Andreas only reads stuff if it is in &lt;span style=&quot;font-style: italic;&quot;&gt;paper&lt;/span&gt; form, so here goes my paper in pedantic PDF form:&lt;/p&gt;
&lt;blockquote&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;how_to_release_software_periodically.pdf&quot;&gt;How to release software periodically&lt;/a&gt;.&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p&gt;Hmm… maybe that wasn't such a good idea after all.&lt;/p&gt;
&lt;p&gt;&lt;pre class='code'&gt;&lt;span class=&quot;Operator&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;nimrod&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;rst2html&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;paper&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;rst&lt;/span&gt;
&lt;span class=&quot;Identifier&quot;&gt;paper&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;rst&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;DecNumber&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;DecNumber&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;invalid&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;directive&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;CharLit&quot;&gt;'humour'&lt;/span&gt;
&lt;/pre&gt; &lt;/p&gt;

      </content>
    </entry>
    <entry>
      <title>Worse than global variables</title>
      <link rel="alternate" type="text/html" href="http://gradha.github.io/articles/2013/12/worse-than-global-variables.html"/>
      <id>http://gradha.github.io/articles/2013/12/worse-than-global-variables.html</id>
      <updated>2013-12-09T10:54:00Z</updated>
      <author><name>Grzegorz Adam Hankiewicz</name></author>
      <content type="html">
        &lt;h1&gt;Worse than global variables&lt;/h1&gt;&lt;p&gt;Global variables are one of the lowest programming abstractions you can use today. They represent through a human readable name an arbitrary address of memory on the machine running a program. In the beginning, &lt;span style=&quot;font-style: italic;&quot;&gt;real&lt;/span&gt; programmers would store their data at specific memory address locations, and this was tedious and error prone. Being able to &lt;span style=&quot;font-style: italic;&quot;&gt;name&lt;/span&gt; those address locations with a meaningful name, hopefully indicating what the address was used for, decreased human errors and made reviewing code easier. Programmers didn't have to remember any more what the address &lt;code&gt;&amp;amp;A0BFh&lt;/code&gt; stood for while developing. They weren't even called &lt;span style=&quot;font-style: italic;&quot;&gt;global&lt;/span&gt; variables, they were simply variables, saving the world and allowing civilization reach higher heights. They were good, and kittens were saved.&lt;/p&gt;
&lt;p&gt;So what happened? At some point &lt;a href=&quot;https://en.wikipedia.org/wiki/Structured_programming&quot;&gt;structured programming&lt;/a&gt; happened and suddenly programmers realised that as code grew, it was useful to compartmentalize sections and try to make them independent of each other for reuse. Local variables entered the scene, having a shorter lifespan compared to that of the &lt;span style=&quot;font-style: italic;&quot;&gt;immortal&lt;/span&gt; global variables. Now you could have &lt;a href=&quot;https://en.wikipedia.org/wiki/Subroutines&quot;&gt;subroutines&lt;/a&gt; using their own variables without &lt;span style=&quot;font-style: italic;&quot;&gt;polluting&lt;/span&gt; the global &lt;span style=&quot;font-style: italic;&quot;&gt;name space&lt;/span&gt;. Note how even the words I just used (polluting) imply something negative. As if the global name space was as &lt;span style=&quot;font-style: italic;&quot;&gt;precious&lt;/span&gt; as our &lt;a href=&quot;https://www.youtube.com/watch?v=Qr2bSL5VQgM&quot;&gt;bodily fluids&lt;/a&gt;, and any attack against them had to be answered with resolution.&lt;/p&gt;
&lt;p&gt;Indeed, global variables are at odds with structured programming (and even more concurrent programming). Consider the following C program:&lt;/p&gt;
&lt;p&gt;&lt;pre class='code'&gt;&lt;span class=&quot;Comment&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;Comment&quot;&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;

&lt;span class=&quot;Identifier&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;amount&lt;/span&gt; &lt;span class=&quot;Operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;DecNumber&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;Identifier&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;count_words&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;Operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;Punctation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;Keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;Operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;sep&lt;/span&gt; &lt;span class=&quot;Operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;StringLit&quot;&gt;&amp;quot;, &lt;/span&gt;&lt;span class=&quot;EscapeSequence&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;StringLit&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;Keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;Punctation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;Operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;Operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;strtok&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;sep&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;Identifier&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;Operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;strtok&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;sep&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;Punctation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;Identifier&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;Punctation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;Punctation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;Identifier&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;Punctation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;Identifier&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;Operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;StringLit&quot;&gt;&amp;quot;Globals, globals everywhere&amp;quot;&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;Identifier&quot;&gt;count_words&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;Keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;StringLit&quot;&gt;&amp;quot;Words %d&lt;/span&gt;&lt;span class=&quot;EscapeSequence&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;StringLit&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;Punctation&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;This little program will display that there are 3 words in the text &lt;code&gt;Globals, globals everywhere&lt;/code&gt;. This is done calling the &lt;code&gt;count_words&lt;/code&gt; function, which then calls the libc &lt;code&gt;strtok&lt;/code&gt; function to &lt;span style=&quot;font-style: italic;&quot;&gt;tokenize&lt;/span&gt; the input. That is, &lt;code&gt;strtok&lt;/code&gt; splits the input buffer and loops over it ignoring the separator characters.&lt;/p&gt;
&lt;p&gt;The function &lt;code&gt;count_words&lt;/code&gt; stores into the global variable &lt;code&gt;amount&lt;/code&gt; the number of words. And for this simple example it's enough, and it works. However, if we wanted to reuse the &lt;code&gt;count_words&lt;/code&gt; function in other programs, we would quickly see that we &lt;span style=&quot;font-style: italic;&quot;&gt;have to carry&lt;/span&gt; the global variable along: the function itself is not independent. Also, it is difficult to call, rather than assigning the result to any variable, we are forced to use &lt;code&gt;amount&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;I picked this specific case for another reason. Let's say that we make &lt;code&gt;count_words&lt;/code&gt; &lt;span style=&quot;font-weight: bold;&quot;&gt;not&lt;/span&gt; use the global variable &lt;code&gt;amount&lt;/code&gt; but instead return the value. Then we write &lt;a href=&quot;https://www.google.com/&quot;&gt;some sort of word indexing website as an experiment&lt;/a&gt; and we modify the program to read multiple input files and start &lt;a href=&quot;https://en.wikipedia.org/wiki/Thread_(computing)&quot;&gt;different threads&lt;/a&gt;, each calling the &lt;code&gt;count_words&lt;/code&gt; subroutine. Excellent! We are done, aren't we?&lt;/p&gt;
&lt;p&gt;Nope. Here we see another &lt;span style=&quot;font-style: italic;&quot;&gt;evilness&lt;/span&gt; of global variables. The libc &lt;code&gt;strtok&lt;/code&gt; function itself uses an internal global buffer (similar to the &lt;code&gt;amount&lt;/code&gt; global variable) for its purposes, and this means that concurrent threads calling this function at the same time will step over each other modifying this buffer, and likely obtaining an incorrect result during the computation. For this specific reason the &lt;a href=&quot;http://linux.die.net/man/3/strtok_r&quot;&gt;strtok_r function&lt;/a&gt; was added. Through the use of a new third parameter, the caller of the function can specify the internal buffer, and thus multiple concurrent threads using &lt;span style=&quot;font-style: italic;&quot;&gt;different&lt;/span&gt; buffers won't step on each other. This property is called &lt;a href=&quot;https://en.wikipedia.org/wiki/Reentrancy_(computing)&quot;&gt;reentrancy&lt;/a&gt;, and it tells the programmer that it is safe to call a function in a multi threaded context because it doesn't use any global state.&lt;/p&gt;
&lt;h2&gt;The crusade against global variables&lt;/h2&gt;&lt;p&gt;The solution to all this suffering is easy. Ban global variables. Banish the &lt;code&gt;strtok&lt;/code&gt; function from the standard C library. Even better! Why don't we make &lt;a href=&quot;https://en.wikipedia.org/wiki/Java_(programming_language)&quot;&gt;a programming language were the programmer has to jump through hoops to make a global variable&lt;/a&gt;? That will teach them, if programmers really want to have a global variable, let's force them to wrap that around an invented object class and mark it static.&lt;/p&gt;
&lt;p&gt;Even better, rather than create global variables, why don't we have a language where the &lt;span style=&quot;font-style: italic;&quot;&gt;mainstream&lt;/span&gt; convention is to wrap them inside &lt;a href=&quot;https://en.wikipedia.org/wiki/Singleton_pattern&quot;&gt;the singleton pattern&lt;/a&gt;? Oh, don't worry, it's going to be simple, so simple in fact that to this day there are &lt;a href=&quot;http://stackoverflow.com/questions/145154/what-should-my-objective-c-singleton-look-like&quot;&gt;still questions on how to implement this pattern because it is so complex and it has so many little gotchas that nobody is able to figure out the proper way to do it&lt;/a&gt;. I'm not the first to point out that people who are new to programming &lt;a href=&quot;http://programmingisterrible.com/post/40453884799/what-language-should-i-learn-first&quot;&gt;get bored to death through the use of languages which require them to be an expert to implement a Hello World program&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;At this point you really have to stop. Where did it go wrong? Why from a simple global variable we have to over engineer a singleton pattern? Is it really that good? Is it &lt;span style=&quot;font-style: italic;&quot;&gt;that&lt;/span&gt; common to start writing an algorithm using a global variable that you later say &amp;quot;&lt;span style=&quot;font-style: italic;&quot;&gt;Awww, look, I should have not used that global variable because I have to now… add a single state parameter/structure to my code&lt;/span&gt;&amp;quot;? The amount of times I've said that are very very few, yet day and night I find myself reading the singleton pattern where a normal global variable access would do.&lt;/p&gt;
&lt;p&gt;Global state is rarely a matter of a single variable, and one typical solution is to group the global state into a single structure. Then create an global variable of that structure and use it. Here's a snippet from one of my programs implemented in &lt;a href=&quot;http://nimrod-lang.org&quot;&gt;Nimrod&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;pre class='code'&gt;&lt;span class=&quot;Keyword&quot;&gt;type&lt;/span&gt;
  &lt;span class=&quot;Identifier&quot;&gt;Tglobal&lt;/span&gt; &lt;span class=&quot;Operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;Keyword&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;Comment&quot;&gt;## \&lt;/span&gt;
    &lt;span class=&quot;Comment&quot;&gt;## Holds all the global variables of the process.&lt;/span&gt;
    &lt;span class=&quot;Identifier&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;Tcommandline_results&lt;/span&gt;
    &lt;span class=&quot;Identifier&quot;&gt;verbose&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;Comment&quot;&gt;## Quick access to parsed values.&lt;/span&gt;
    &lt;span class=&quot;Identifier&quot;&gt;target_url&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;Comment&quot;&gt;## Were to download stuff from.&lt;/span&gt;
    &lt;span class=&quot;Identifier&quot;&gt;short_name&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;Comment&quot;&gt;## Prefix used for file directories.&lt;/span&gt;
    &lt;span class=&quot;Identifier&quot;&gt;dest_dir&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;Comment&quot;&gt;## Path for the destination directory.&lt;/span&gt;
    &lt;span class=&quot;Identifier&quot;&gt;post_process&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;Comment&quot;&gt;## Path to command to be run on final directory.&lt;/span&gt;

&lt;span class=&quot;Keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;Tglobal&lt;/span&gt;
&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;Command line parsing is a very good example of global state because it happens once, and it works for the whole execution of the program. When the user wants to have a &lt;span style=&quot;font-style: italic;&quot;&gt;verbose&lt;/span&gt; execution you can store that in a global variable. Then you access &lt;code&gt;g.verbose&lt;/code&gt; and do your thing. Instead, according to the singleton pattern I should be accessing some &lt;span style=&quot;font-style: italic;&quot;&gt;static&lt;/span&gt; method of a class to read the value of a variable (which is not going to change). How wasteful is that, not only in terms of program runtime but also developer time, repeating that stupid pattern all over the place?&lt;/p&gt;
&lt;h2&gt;Crutches, not tools&lt;/h2&gt;&lt;p&gt;The fact is that Java or Objective-C are not good languages when it comes to implement global variables, each having downsides, imposing a development penalty on all of us. Global variables  won't go away, all but the most trivial programs have or need global state. It is damaging to ourselves when programmers, after having invested time in learning a programming language, throw excuses and tantrums to justify their broken tools.  That's an emotional answer, nobody wants to be told that they have wasted their time learning the wrong thing.&lt;/p&gt;
&lt;p&gt;The singleton pattern can be useful, but hiding simple global variables behind it is not a proper use of this pattern. Is your programming language preventing you from doing the right thing then? And more importantly, is your programming language preventing you from thinking about the right way to express your needs? &lt;/p&gt;

      </content>
    </entry>
    <entry>
      <title>40 years later we still can't be friends</title>
      <link rel="alternate" type="text/html" href="http://gradha.github.io/articles/2013/10/40-years-later-we-still-cant-be-friends.html"/>
      <id>http://gradha.github.io/articles/2013/10/40-years-later-we-still-cant-be-friends.html</id>
      <updated>2013-10-07T23:29:00Z</updated>
      <author><name>Grzegorz Adam Hankiewicz</name></author>
      <content type="html">
        &lt;h1&gt;40 years later we still can't be friends&lt;/h1&gt;&lt;h2&gt;Context&lt;/h2&gt;&lt;p&gt;The computer (or electronic device) you are likely using to read this article is also very likely to be doing some form of &lt;a href=&quot;https://en.wikipedia.org/wiki/Computer_multitasking&quot;&gt;multitasking&lt;/a&gt;, where the machine gives the illusion of performing different tasks simultaneously. At the low level a single processor is only able to perform a single task, operation, action, whatever you want to call it. However, processors are so fast that switching from one task to another looks to us, humans, like they are doing multiple things.&lt;/p&gt;
&lt;p&gt;For instance, even if you are waiting for a web page or program to load, and you see some sort of visual indicator, like a spinning wheel, as a user you may think the computer is busy doing one task, the loading of the web page or program. But at the low level the computer is doing much more, in fact, by simple virtue of drawing and updating an animated icon, updating the position of the mouse on the screen, and why not even &lt;a href=&quot;https://www.youtube.com/watch?v=yMqL1iWfku4&quot;&gt;playing some kpop music in the background&lt;/a&gt; while you patiently wait. In contrast, if the computer could not multitask, while the web page or program loaded, you could not do anything, not even move the mouse.&lt;/p&gt;
&lt;p&gt;According to the erudites from wikipedia (&lt;span style=&quot;font-style: italic;&quot;&gt;citation needed&lt;/span&gt;), &lt;a href=&quot;http://en.wikipedia.org/wiki/Time-sharing&quot;&gt;time sharing&lt;/a&gt; was a computing model which between 1960 and 1970 established itself as the way to share resources on big mainframes. &lt;a href=&quot;http://en.wikipedia.org/wiki/Unix&quot;&gt;Unix&lt;/a&gt; and many of its descendants, like the popular &lt;a href=&quot;http://en.wikipedia.org/wiki/Linux&quot;&gt;Linux&lt;/a&gt; inherited this computing model, since it was accepted as valid. Most of operating systems of today follow this computing model, since one of the troubles with the computing industry is its really impressive momentum and resistance to change.&lt;/p&gt;
&lt;h2&gt;There's a war going on inside your machine&lt;/h2&gt;&lt;p&gt;There are many ways to explain how programs running on a computer share resources, but actually most ignore the fact that the programs &lt;span style=&quot;font-style: italic;&quot;&gt;are not sharing, nor willing to share&lt;/span&gt; those resources. Operating systems are really like guardians who provide access to a single resource (the CPU) in turns. If you have a single process running, it will get all the time slices of the CPU. But if you have two processes, the operating system will try to distribute equally the CPU among them. Depending on the type of the programs, they might not even use the CPU at all because they may be waiting for user input. The process gets the time slice of the CPU but yields it back to the OS. Hence modern machines have many processes, but they are actually &lt;span style=&quot;font-style: italic;&quot;&gt;sleeping&lt;/span&gt;, waiting for some event which will trigger a reaction.&lt;/p&gt;
&lt;p&gt;The problem is of course the active CPU hogs. These could be playing music in the background, video playback, compressing images or rendering frames for a video game (games are constantly redrawing the game world on the screen for the user).  But even if you are actively running a single program, it might run many different sub threads to perform its tasks. For this reason most task managers can display the list of programs running, and how many threads or children have they spawned. So you don't actually need multiple processes to trigger time sharing behaviour, it's enough for a single process with multiple threads.&lt;/p&gt;
&lt;p&gt;The problem with this inherited approach is the way multitasking is expressed and handled in software. The most popular ways to split a task are to either &lt;span style=&quot;font-style: italic;&quot;&gt;fork&lt;/span&gt; a process, or &lt;span style=&quot;font-style: italic;&quot;&gt;spawn&lt;/span&gt; a thread. In both cases the source program decides how many processes or threads to create, and then coordinates the communication to control and complete the task. And here lies the problem, a process can query the number of available cores on the system and decide to spawn an equal number of threads to perform a task which can be subdivided (this is called parallelization). Why is this a problem at all?  There are two:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;The process ignores the existence of other processes in the current environment.&lt;/li&gt;&lt;li&gt;The check for available cores happens at the beginning of the task subdivision, and presumes the number will remain stable for its duration.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Both of these can be handled perfectly by the operating system, since it knows all the necessary data to decide best how to divide tasks. Yet our current software threading model forces the programmer to decide without this information.&lt;/p&gt;
&lt;h2&gt;Task switching killing your scalability&lt;/h2&gt;&lt;p&gt;Let's write a photo processing software! Or maybe video. Anyway, this kind of software operates on bidimensional images which can usually be split into smaller chunks and dealt with mostly individually without dependencies. Tasks inside the computer don't &lt;span style=&quot;font-style: italic;&quot;&gt;magically&lt;/span&gt; migrate to other cores. If we write this software in single threaded mode, the four core machine will have one core working at the maximum, and three idling. What a waste. No problem, we subdivide the image and feed the chunks to the four cores. Now the performance is nearly four times that of the original single threaded code (we have a small overhead for splitting/controlling tasks).&lt;/p&gt;
&lt;p&gt;Cool, now we can batch process porn pictures at the speed of light. But it takes time to go through &lt;a href=&quot;https://www.youtube.com/watch?v=q8lW8ndh5BU&quot;&gt;our folder of midget porn&lt;/a&gt;, and we want to do other things in the meantime. Let's compress some video! Video edition can also benefit from parallelization, since at the basic level the individual images can also be split into chunks to feed different cores. Again, our video program detects four cores, splits the images in a queue and starts processing them four at a time. See the problem?&lt;/p&gt;
&lt;p&gt;Now there are two processes on the quad core machine, each of them requesting to have the four cores for itself, but in total that means running eight threads at the same time. Unless we are running JesusOS which can multiply cores out of nowhere, the OS is just going to switch tasks between each core. Big deal, right? Yes, it's a big deal. When you start to measure performance of such programs in combination you realize that task switching is not free: the CPU has to change a lot of internal state and then the next task has to recover it.  It takes time. And the more processes you run the worse it gets. So we end up with a machine which for each process overspawns many threads instead of getting one thread per core. Where doing tasks serially would take &lt;code&gt;A + B + C&lt;/code&gt; seconds, now we have &lt;code&gt;A + B + C + task switching overhead&lt;/code&gt; seconds, and the &lt;code&gt;task switching overhead&lt;/code&gt; part can grow quite a lot, especially the more processes there are.&lt;/p&gt;
&lt;p&gt;This considers a situation where the number of processing units is static all the time, but things can be harder especially on mobile devices where the hardware may decide to disable one or more processing units to save battery. Plugin in the laptop might give it a performance boost, and viceversa. For these situations the programming model we have dragged for over forty years is completely useless, there is no provision for changing the number of threads on the fly, you need clever programmers to implement such behaviour themselves, but there are clearly none since we haven't solved this yet, have we?&lt;/p&gt;
&lt;h2&gt;Take this ticket and wait for your turn&lt;/h2&gt;&lt;p&gt;While most of the world was indulging in criticizing Apple for having economic success, they silently released &lt;a href=&quot;https://en.wikipedia.org/wiki/Grand_Central_Dispatch&quot;&gt;Grand Central Dispatch (GCD)&lt;/a&gt; which is &lt;span style=&quot;font-style: italic;&quot;&gt;yet another&lt;/span&gt; task parallelism tool based on &lt;a href=&quot;https://en.wikipedia.org/wiki/Kqueue&quot;&gt;kqueue&lt;/a&gt;. GCD changes the way the programmer thinks about multithreading. Instead of saying &amp;quot;&lt;span style=&quot;font-style: italic;&quot;&gt;hey, I want 4 threads doing this much stuff&lt;/span&gt;&amp;quot;, the programmer says &amp;quot;&lt;span style=&quot;font-style: italic;&quot;&gt;hey, I have these many tasks which can run parallel to each other without dependencies, run them please&lt;/span&gt;&amp;quot;. This is a big change. While it can be argued that queues are easier to handle than threads, what this change means to the user is that the OS can now decide how many threads to allocate for a process. The OS doesn't face the &lt;span style=&quot;font-style: italic;&quot;&gt;simultaneous attack&lt;/span&gt; of dozens of processes, instead it sees dozens of processes waiting for their queues to finish. The OS can decide then to pick as many tasks from their queues and not worry (mostly) about switching threads.&lt;/p&gt;
&lt;p&gt;Of course the devil is in the details. What if you are not subdividing your tasks well enough that they block the queues for other processes? What if the chunk of code in the queue blocks for disk I/O? What if... queues are not for solving the inherent threading problems OSes will keep having for the foreseeable future. But they help a lot in allowing them to decide what to run and when. In the example give above, the OS could decide to take only two tasks at the same time from the image process queue and two tasks from the video queue, and if any process finishes, the new slots can be given to the reminder tasks in other processes' queues. Similar scenario happens if the platform you are running enables/disables more processing cores. Have you imagined a hardware where you can plug in a card and double the processing speed of the running processes without them having to restart to take advantage of the change? Now you could.&lt;/p&gt;
&lt;p&gt;In fact, all of this is &lt;span style=&quot;font-style: italic;&quot;&gt;in the past&lt;/span&gt;. Note that GCD was introduced in the year 2009. Since then, Apple has been pushing API changes all over their iOS and OSX frameworks to include blocks and queues where they make sense. Even if programmers of these platforms don't explicitly use queues for their programs, most of the libraries they will surely use &lt;span style=&quot;font-weight: bold;&quot;&gt;are&lt;/span&gt; going to take advantage of these task parallelization techniques, thus gaining the advantages mentioned here. And of course, whenever they need to run something in the background, the Objective-C language and APIs will prod them towards queues rather than threads or processes.&lt;/p&gt;
&lt;p&gt;The benefits from using queues are not invisible or theoretical. Already in November of 2010, &lt;a href=&quot;https://github.com/robbiehanson&quot;&gt;Robbie Hanson (aka Deusty)&lt;/a&gt; wrote &lt;a href=&quot;http://deusty.blogspot.com.es/2010/11/introducing-gcd-based-cocoahttpserver.html&quot;&gt;a blog post explaining the benefits of migrating its HTTP server&lt;/a&gt; (&lt;a href=&quot;https://github.com/robbiehanson/CocoaHTTPServer&quot;&gt;CocoaHTTPServer&lt;/a&gt;) to queues. Claimed performance improvements range from doubling to quadrupling, but the most impressive is the &lt;span style=&quot;font-style: italic;&quot;&gt;nearly linear scalability&lt;/span&gt; when the number of concurrent connections was increased. This is the golden dream: increase number of tasks with nearly zero overhead. And Robbie is collaborating to other pieces of software you might not expect could benefit from queues, like &lt;a href=&quot;https://github.com/yaptv/YapDatabase&quot;&gt;YapDatabase&lt;/a&gt;, built on top of &lt;a href=&quot;https://sqlite.org&quot;&gt;SQLite&lt;/a&gt; and providing &lt;a href=&quot;https://github.com/yaptv/YapDatabase/wiki/Hello-World&quot;&gt;smooth database operations not blocking the user interface&lt;/a&gt; to preserve the fluidity of the user's interaction.&lt;/p&gt;
&lt;h2&gt;A bleak future&lt;/h2&gt;&lt;p&gt;Yet here we are, nearly four years later still waiting for the revolution to happen. You could only hope the competition would clone this approach to threaded code as the phone industry copied the iPhone, but I haven't seen yet any other mainstream programming language embedding such functionality in its core language and standard library. And if you think that's bad, we still haven't talked about another pressing issue related to inter process hostility. If only I had the memory to remember what it was all about…&lt;/p&gt;
&lt;p&gt;&lt;pre class='code'&gt;&lt;span class=&quot;Operator&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;nimrod&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;work_faster&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;nim&lt;/span&gt;
&lt;span class=&quot;Identifier&quot;&gt;work_faster&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;nim&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;DecNumber&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;DecNumber&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;cannot&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;CharLit&quot;&gt;'threads'&lt;/span&gt;
&lt;/pre&gt; &lt;/p&gt;

      </content>
    </entry>
    <entry>
      <title>You have to realise that someday you will die…</title>
      <link rel="alternate" type="text/html" href="http://gradha.github.io/articles/2013/10/you-have-to-realise-that-someday-you-will-die….html"/>
      <id>http://gradha.github.io/articles/2013/10/you-have-to-realise-that-someday-you-will-die….html</id>
      <updated>2013-10-01T14:45:00Z</updated>
      <author><name>Grzegorz Adam Hankiewicz</name></author>
      <content type="html">
        &lt;h1&gt;You have to realise that someday you will die…&lt;/h1&gt;&lt;p&gt;…until you know that, you are useless. That's part of the lyrics of &lt;a href=&quot;http://www.leoslyrics.com/tyler-durden/this-is-your-life-lyrics/&quot;&gt;This is your life&lt;/a&gt;, part of the soundtrack to the &lt;a href=&quot;http://www.imdb.com/title/tt0137523/&quot;&gt;Fight club film&lt;/a&gt;, based on &lt;a href=&quot;http://chuckpalahniuk.net/books/fight-club&quot;&gt;a book by Chuck Palahniuk&lt;/a&gt;. It's a sentence I like to remember during the times when everything goes wrong: broken hardware, service providers going out of business, breaking relationships, etc. Focusing on whatever &lt;span style=&quot;font-style: italic;&quot;&gt;is gone&lt;/span&gt; is the result of getting too attached, and that can interfere with new things in life. It simply means change, and people who are unable to change will have a harder time than those who can adapt.&lt;/p&gt;
&lt;p&gt;So my old project Electric Hands Software is gone, and the most disgusting part of &lt;code&gt;http://elhaso.com/&lt;/code&gt; not being available any more is that it has been claimed by automatic spambots, turning it into a casino. With black jack. And hopefully, whores:&lt;/p&gt;
&lt;img src=&quot;/i/the_definition_of_crap.png&quot; alt=&quot;&quot; /&gt;&lt;p&gt;It is clearly a sign of irrelevance when automatic software cares more about your out of business ideas than human people, I don't think that website registered more than 2000 hits during several years. So let the new &lt;a href=&quot;http://www.elhaso.es/&quot;&gt;Electric Hands Software website at http://www.elhaso.es/&lt;/a&gt; shine! But this time it won't be ambitious, I've already been taught all that went wrong and why, there's no point in repeating mistakes.&lt;/p&gt;
&lt;p&gt;Instead, it will live on as a hobby. And since my new hobby is &lt;a href=&quot;http://nimrod-lang.org&quot;&gt;the Nimrod programming language&lt;/a&gt;, maybe I should take the crusty C source code of &lt;a href=&quot;http://www.elhaso.es/subhunt/index.en.html&quot;&gt;Submarine Hunt&lt;/a&gt; and rewrite it opensource in nimrod?  Ah, if only these feelings of inebriation lasted a little bit longer…&lt;/p&gt;
&lt;p&gt;&lt;pre class='code'&gt;&lt;span class=&quot;Operator&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;nimrod&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;Operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;life&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;nim&lt;/span&gt;
&lt;span class=&quot;Identifier&quot;&gt;SIGSEGV&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;Illegal&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;storage&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;access&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;Punctation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;Attempt&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;Keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;Keyword&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt; &lt;/p&gt;

      </content>
    </entry>
    <entry>
      <title>Users prefer static linking</title>
      <link rel="alternate" type="text/html" href="http://gradha.github.io/articles/2013/08/users-prefer-static-linking.html"/>
      <id>http://gradha.github.io/articles/2013/08/users-prefer-static-linking.html</id>
      <updated>2013-08-03T12:31:00Z</updated>
      <author><name>Grzegorz Adam Hankiewicz</name></author>
      <content type="html">
        &lt;h1&gt;What is static linking&lt;/h1&gt;&lt;p&gt;Users prefer static linking. That is, if software users would actually know what static linking is. Most users don't know anything about software, how it is built, or how much time you pour into it, but they know one thing: if it works, they expect it to keep working.&lt;/p&gt;
&lt;p&gt;That's where the static linking is important. When a program is compiled a &lt;span style=&quot;font-style: italic;&quot;&gt;binary&lt;/span&gt; is generated. The binary can have dynamic dependencies, which means that it relies on external code that is loaded every time the binary is loaded into memory to be executed. On the other hand, a statically linked binary will &lt;span style=&quot;font-style: italic;&quot;&gt;copy&lt;/span&gt; all (or some) of the external code it requires into the final binary itself.&lt;/p&gt;
&lt;p&gt;The advantage of static linking is that you can copy the binary to another system and it will keep running, something which may not happen if the other system environment doesn't also have the same external library installed. The cost to pay for this is increased binary size, and there are also other drawbacks like the operating system not being able to share the library between processes and having duplicate instances of the same code in memory during execution.&lt;/p&gt;
&lt;p&gt;Mainstream consumer operating systems (Windows, Linux, OS X) provide a big set of shared libraries, allowing programmers to not have to care distributing their own copy with the program. But that soon started to be a problem: different versions of each operating system and/or library could be problematic for the programs. This is usually known as &lt;a href=&quot;https://en.wikipedia.org/wiki/DLL_Hell&quot;&gt;DLL Hell&lt;/a&gt;, where installation of program A on the end user machine brings in version 1 of a shared library, and installation of program B brings in an incompatible version 2 of that same shared library.&lt;/p&gt;
&lt;p&gt;Due to poor DLL versioning or programmer carelessness the end user system becomes unstable. The best is when it actually crashes, because end users &lt;span style=&quot;font-style: italic;&quot;&gt;notice&lt;/span&gt; there is something wrong. The problem is when the programs don't crash immediately, they may crash later, at random or specific times, or behave in not completely correct behaviour, but not exactly right.&lt;/p&gt;
&lt;p&gt;Nowadays even bigger culprits of dynamic linking are dynamic or interpreted languages. Instead of producing compiled code, interpreted languages like &lt;a href=&quot;http://www.python.org&quot;&gt;Python&lt;/a&gt; or &lt;a href=&quot;http://www.ruby-lang.org&quot;&gt;Ruby&lt;/a&gt; are transformed into machine instructions each time they are run. Now they don't only depend on the availability of the dynamic libraries they require, they also depend on the version of the interpreter. If you try to run a script written for say Python 2.5, it won't work on Python 3 because of language incompatibilities. This ends up creating a divide between programmers and affects end users too.&lt;/p&gt;
&lt;p&gt;If you thought your problems are only here, don't look at operating system upgrades, the main reason people are &lt;span style=&quot;font-style: italic;&quot;&gt;scared to death&lt;/span&gt; to upgrade their system.  If you know of a computer end user who is not scared to death of upgrades it is only because he hasn't suffered the experience of &lt;span style=&quot;font-style: italic;&quot;&gt;upgrading&lt;/span&gt; the machine to only find out (sometimes weeks later) that a critical program stopped working because it is incompatible with the new version of the operating system. This causes pain, gnashing of teeth and hatred towards computers and/or programmers.&lt;/p&gt;
&lt;h1&gt;Levels of portability&lt;/h1&gt;&lt;p&gt;The situations explained above don't actually relate all to static linking, or can't be applied at all, since there is no concept of static linking for interpreted languages. So maybe at this point we should rephrase the term of static linking for the end user as a general problem of portability. We also need to consider different levels of portability, for instance:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;The user installed some software, and it works fine. The operating systems has the feature of multiple users and only the user who installed the software can run the program despite it being accessible to other users. Maybe the problem is the installation copied critical files to the user's private directories which are not available to the other users.&lt;/li&gt;&lt;li&gt;The user copies the program to another machine, apparently using the same operating system version. However, it won't run at all. Maybe the &lt;span style=&quot;font-style: italic;&quot;&gt;major&lt;/span&gt; operating system version is the same, but sometimes operating systems have different minor versions, maybe one was upgraded to the latest security patch and this breaks the program's behaviour.&lt;/li&gt;&lt;li&gt;The user copies the program to another machine or upgrades the operating system. The program won't run at all, sometimes without giving any useful explanation.&lt;/li&gt;&lt;li&gt;The user wants to run the software in a cybercafe, or is otherwise somewhere else on lent hardware. The user copies all program files to an USB stick, but surprisingly it doesn't run there.  Why? Even though there are projects to create &lt;a href=&quot;http://portableapps.com&quot;&gt;portable versions of applications&lt;/a&gt; most programs don't expect to be run in such a fashion. Also, even if your spreadsheet software runs you don't want it to leave your bank details on a public computer at a cybercafe just because it thought for convenience that you will always have a private user data folder on the hard drive.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;More different situations could be described, but one thing to note is a program can fall into several of these situations at the same time, and it mostly depends on two factors: technologies used and programmer's interest in portability. Yes, portability is a feature decided by programmers upon their end users. And unfortunately few people care.&lt;/p&gt;
&lt;h1&gt;The solution&lt;/h1&gt;&lt;p&gt;The solution for portability is simple: you copy, bundle, or embed whatever your program needs into your binary. For instance, Windows programs may want to avoid writing into the registry so that copying the folder where the software was installed is enough to copy everything to a different machine and run it there.&lt;/p&gt;
&lt;p&gt;On OS X this is abstracted to the user through the use of &lt;a href=&quot;https://en.wikipedia.org/wiki/Application_bundle&quot;&gt;application bundles&lt;/a&gt;. These are normal directories with a special structure the operating system recognizes and treats uniformly as a single entity. The Finder on OS X won't allow you to copy only part of the bundle's directory somewhere else, and should it fail, it will delete the incomplete bundle. Even if it is left there broken, the system wont run it and will likely draw a translucent stop sign on its icon.&lt;/p&gt;
&lt;p&gt;Linux… Linux users usually don't care. They brag about sophisticate software management programs (oh, the meta) and tell end users they are crazy because they don't want to learn how to use it or search the net for solutions to a dependency, which can be solved, but requires some obscure option/command line switch to work.&lt;/p&gt;
&lt;p&gt;Mobile software stores have adopted the bundle paradigm: they include everything required to run except the basic libraries provided by the system which are (in theory) guaranteed to be the same on all future OS versions. This allows for example software written for the iPhone 3G to still run on the iPhone 5 without updates.&lt;/p&gt;
&lt;p&gt;Note that bundling everything together still requires the program to be &lt;span style=&quot;font-style: italic;&quot;&gt;aware&lt;/span&gt; of being run in this kind of environment. Fortunately for end users the strict rules for iOS and Android are creating more awareness towards the usual &lt;span style=&quot;font-style: italic;&quot;&gt;sandboxes&lt;/span&gt;, so much in fact that OS X desktop users already have an equivalent app store with &lt;span style=&quot;font-style: italic;&quot;&gt;sandboxing&lt;/span&gt; and Windows seems to be following suit.&lt;/p&gt;
&lt;h1&gt;Software proud to be portable&lt;/h1&gt;&lt;p&gt;There are not many developer oriented tools which are written with portability in mind. The authors of &lt;a href=&quot;https://sqlite.org&quot;&gt;Sqlite&lt;/a&gt; and &lt;a href=&quot;http://fossil-scm.org/index.html/doc/trunk/www/index.wiki&quot;&gt;Fossil&lt;/a&gt; are one exceptional case. They aim for the highest level of portability: a single binary which can be copied anywhere and it works.&lt;/p&gt;
&lt;p&gt;Nothing particularly new, but worth of appraise. Long forgotten MSDOS programmers also developed funny &lt;span style=&quot;font-style: italic;&quot;&gt;tricks&lt;/span&gt; to provide single binary portability (remember the times when having a hard disk was rare?). The most notable one was appending additional resources to the binary itself. The operating system would load the whole binary into memory but will ignore the extraneous trailing data. Instead, the application could read it to avoid littering the disk with extra files.&lt;/p&gt;
&lt;p&gt;Surprisingly this technique still works on today's systems. Even more, programs like &lt;a href=&quot;http://upx.sourceforge.net&quot;&gt;UPX&lt;/a&gt; which compress binaries also know how to handle trailing data and are known to work with binary appending tools, like the one provided by the &lt;a href=&quot;http://alleg.sourceforge.net&quot;&gt;C game programming library Allegro&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;However, USB level portability is hard to find for most programming languages compilers and interpreters. The closest may be the &lt;a href=&quot;http://nimrod-lang.org&quot;&gt;Nimrod programming language&lt;/a&gt;, since it compiles everything into a single nimrod binary, which can be run everywhere.&lt;/p&gt;
&lt;p&gt;The problem is, will it work? Compiling most source code will require using modules from the standard library. But where are these? Scattered somewhere else. So while it is true that Nimrod produces a statically linked contained binary, it is effectively not portable if for 99% of its usage it depends on external files. Another example, you could be using different nimrod compiler versions for testing, and one works with a specific version of the standard library, but a previous compiled binary won't work due to changes in the language. This requires you to maintain different versions of the standard library module tree, and make sure to point to the correct one with each binary if you actually need to switch.&lt;/p&gt;
&lt;p&gt;Certainly developers are special &lt;span style=&quot;font-style: italic;&quot;&gt;power&lt;/span&gt; users, and they are expected to know how to install tool dependencies, search the net for obscure incantations of poorly known commands, and are usually resilient to repeated failure, with a special knack for banging their head against a wall until they figure out what is wrong.&lt;/p&gt;
&lt;p&gt;However, couldn't we all be nice and provide 100% portable tools too? Why do we provide portability to end users yet again and again we torture ourselves with DLL Hell? Do we enjoy it so much?&lt;/p&gt;
&lt;p&gt;&lt;pre class='code'&gt;&lt;span class=&quot;Operator&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;nimrod&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;forum&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;nim&lt;/span&gt;
&lt;span class=&quot;Operator&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;Operator&quot;&gt;./&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;forum&lt;/span&gt;
&lt;span class=&quot;Identifier&quot;&gt;could&lt;/span&gt; &lt;span class=&quot;Keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;libcairo&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;dylib&lt;/span&gt;
&lt;/pre&gt; &lt;/p&gt;

      </content>
    </entry>
    <entry>
      <title>First post!</title>
      <link rel="alternate" type="text/html" href="http://gradha.github.io/articles/2013/06/first-post.html"/>
      <id>http://gradha.github.io/articles/2013/06/first-post.html</id>
      <updated>2013-06-19T12:31:00Z</updated>
      <author><name>Grzegorz Adam Hankiewicz</name></author>
      <content type="html">
        &lt;p&gt;Hey, so here we are in 2013! People from the past would be proud, I still use static files for websites despite the fancy ipsum genera on my shoulder. I wonder how long will this last…&lt;/p&gt;
&lt;p&gt;&lt;pre class='code'&gt;&lt;span class=&quot;Identifier&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;StringLit&quot;&gt;&amp;quot;Hello interblags!&amp;quot;&lt;/span&gt;
&lt;span class=&quot;Identifier&quot;&gt;quit&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt; &lt;/p&gt;

      </content>
    </entry>
</feed>
