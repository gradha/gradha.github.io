<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rants from the Ballmer Peak</title>
  <link href="http://gradha.github.io/" />
  <link href="http://gradha.github.io/feed.xml" rel="self" />
  <id>http://gradha.github.io/</id>
  <generator>ipsumgenera</generator>
  <updated>2013-11-06T16:21:43Z</updated>
    <entry>
      <title>40 years later we still can't be friends</title>
      <link rel="alternate" type="text/html" href="http://gradha.github.io/articles/2013/10/40-years-later-we-still-cant-be-friends.html"/>
      <id>http://gradha.github.io/articles/2013/10/40-years-later-we-still-cant-be-friends.html</id>
      <updated>2013-10-07T23:29:00Z</updated>
      <author><name>Grzegorz Adam Hankiewicz</name></author>
      <content type="html">
        &lt;h1&gt;40 years later we still can't be friends&lt;/h1&gt;&lt;h2&gt;Context&lt;/h2&gt;&lt;p&gt;The computer (or electronic device) you are likely using to read this article is also very likely to be doing some form of &lt;a href=&quot;https://en.wikipedia.org/wiki/Computer_multitasking&quot;&gt;multitasking&lt;/a&gt;, where the machine gives the illusion of performing different tasks simultaneously. At the low level a single processor is only able to perform a single task, operation, action, whatever you want to call it. However, processors are so fast that switching from one task to another looks to us, humans, like they are doing multiple things.&lt;/p&gt;
&lt;p&gt;For instance, even if you are waiting for a web page or program to load, and you see some sort of visual indicator, like a spinning wheel, as a user you may think the computer is busy doing one task, the loading of the web page or program. But at the low level the computer is doing much more, in fact, by simple virtue of drawing and updating an animated icon, updating the position of the mouse on the screen, and why not even &lt;a href=&quot;https://www.youtube.com/watch?v=yMqL1iWfku4&quot;&gt;playing some kpop music in the background&lt;/a&gt; while you patiently wait. In contrast, if the computer could not multitask, while the web page or program loaded, you could not do anything, not even move the mouse.&lt;/p&gt;
&lt;p&gt;According to the erudites from wikipedia (&lt;span style=&quot;font-style: italic;&quot;&gt;citation needed&lt;/span&gt;), &lt;a href=&quot;http://en.wikipedia.org/wiki/Time-sharing&quot;&gt;time sharing&lt;/a&gt; was a computing model which between 1960 and 1970 established itself as the way to share resources on big mainframes. &lt;a href=&quot;http://en.wikipedia.org/wiki/Unix&quot;&gt;Unix&lt;/a&gt; and many of its descendants, like the popular &lt;a href=&quot;http://en.wikipedia.org/wiki/Linux&quot;&gt;Linux&lt;/a&gt; inherited this computing model, since it was accepted as valid. Most of operating systems of today follow this computing model, since one of the troubles with the computing industry is its really impressive momentum and resistance to change.&lt;/p&gt;
&lt;h2&gt;There's a war going on inside your machine&lt;/h2&gt;&lt;p&gt;There are many ways to explain how programs running on a computer share resources, but actually most ignore the fact that the programs &lt;span style=&quot;font-style: italic;&quot;&gt;are not sharing, nor willing to share&lt;/span&gt; those resources. Operating systems are really like guardians who provide access to a single resource (the CPU) in turns. If you have a single process running, it will get all the time slices of the CPU. But if you have two processes, the operating system will try to distribute equally the CPU among them. Depending on the type of the programs, they might not even use the CPU at all because they may be waiting for user input. The process gets the time slice of the CPU but yields it back to the OS. Hence modern machines have many processes, but they are actually &lt;span style=&quot;font-style: italic;&quot;&gt;sleeping&lt;/span&gt;, waiting for some event which will trigger a reaction.&lt;/p&gt;
&lt;p&gt;The problem is of course the active CPU hogs. These could be playing music in the background, video playback, compressing images or rendering frames for a video game (games are constantly redrawing the game world on the screen for the user).  But even if you are actively running a single program, it might run many different sub threads to perform its tasks. For this reason most task managers can display the list of programs running, and how many threads or children have they spawned. So you don't actually need multiple processes to trigger time sharing behaviour, it's enough for a single process with multiple threads.&lt;/p&gt;
&lt;p&gt;The problem with this inherited approach is the way multitasking is expressed and handled in software. The most popular ways to split a task are to either &lt;span style=&quot;font-style: italic;&quot;&gt;fork&lt;/span&gt; a process, or &lt;span style=&quot;font-style: italic;&quot;&gt;spawn&lt;/span&gt; a thread. In both cases the source program decides how many processes or threads to create, and then coordinates the communication to control and complete the task. And here lies the problem, a process can query the number of available cores on the system and decide to spawn an equal number of threads to perform a task which can be subdivided (this is called parallelization). Why is this a problem at all?  There are two:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;The process ignores the existence of other processes in the current environment.&lt;/li&gt;&lt;li&gt;The check for available cores happens at the beginning of the task subdivision, and presumes the number will remain stable for its duration.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Both of these can be handled perfectly by the operating system, since it knows all the necessary data to decide best how to divide tasks. Yet our current software threading model forces the programmer to decide without this information.&lt;/p&gt;
&lt;h2&gt;Task switching killing your scalability&lt;/h2&gt;&lt;p&gt;Let's write a photo processing software! Or maybe video. Anyway, this kind of software operates on bidimensional images which can usually be split into smaller chunks and dealt with mostly individually without dependencies. Tasks inside the computer don't &lt;span style=&quot;font-style: italic;&quot;&gt;magically&lt;/span&gt; migrate to other cores. If we write this software in single threaded mode, the four core machine will have one core working at the maximum, and three idling. What a waste. No problem, we subdivide the image and feed the chunks to the four cores. Now the performance is nearly four times that of the original single threaded code (we have a small overhead for splitting/controlling tasks).&lt;/p&gt;
&lt;p&gt;Cool, now we can batch process porn pictures at the speed of light. But it takes time to go through &lt;a href=&quot;https://www.youtube.com/watch?v=q8lW8ndh5BU&quot;&gt;our folder of midget porn&lt;/a&gt;, and we want to do other things in the meantime. Let's compress some video! Video edition can also benefit from parallelization, since at the basic level the individual images can also be split into chunks to feed different cores. Again, our video program detects four cores, splits the images in a queue and starts processing them four at a time. See the problem?&lt;/p&gt;
&lt;p&gt;Now there are two processes on the quad core machine, each of them requesting to have the four cores for itself, but in total that means running eight threads at the same time. Unless we are running JesusOS which can multiply cores out of nowhere, the OS is just going to switch tasks between each core. Big deal, right? Yes, it's a big deal. When you start to measure performance of such programs in combination you realize that task switching is not free: the CPU has to change a lot of internal state and then the next task has to recover it.  It takes time. And the more processes you run the worse it gets. So we end up with a machine which for each process overspawns many threads instead of getting one thread per core. Where doing tasks serially would take &lt;code&gt;A + B + C&lt;/code&gt; seconds, now we have &lt;code&gt;A + B + C + task switching overhead&lt;/code&gt; seconds, and the &lt;code&gt;task switching overhead&lt;/code&gt; part can grow quite a lot, especially the more processes there are.&lt;/p&gt;
&lt;p&gt;This considers a situation where the number of processing units is static all the time, but things can be harder especially on mobile devices where the hardware may decide to disable one or more processing units to save battery. Plugin in the laptop might give it a performance boost, and viceversa. For these situations the programming model we have dragged for over forty years is completely useless, there is no provision for changing the number of threads on the fly, you need clever programmers to implement such behaviour themselves, but there are clearly none since we haven't solved this yet, have we?&lt;/p&gt;
&lt;h2&gt;Take this ticket and wait for your turn&lt;/h2&gt;&lt;p&gt;While most of the world was indulging in criticizing Apple for having economic success, they silently released &lt;a href=&quot;https://en.wikipedia.org/wiki/Grand_Central_Dispatch&quot;&gt;Grand Central Dispatch (GCD)&lt;/a&gt; which is &lt;span style=&quot;font-style: italic;&quot;&gt;yet another&lt;/span&gt; task parallelism tool based on &lt;a href=&quot;https://en.wikipedia.org/wiki/Kqueue&quot;&gt;kqueue&lt;/a&gt;. GCD changes the way the programmer thinks about multithreading. Instead of saying &quot;&lt;span style=&quot;font-style: italic;&quot;&gt;hey, I want 4 threads doing this much stuff&lt;/span&gt;&quot;, the programmer says &quot;&lt;span style=&quot;font-style: italic;&quot;&gt;hey, I have these many tasks which can run parallel to each other without dependencies, run them please&lt;/span&gt;&quot;. This is a big change. While it can be argued that queues are easier to handle than threads, what this change means to the user is that the OS can now decide how many threads to allocate for a process. The OS doesn't face the &lt;span style=&quot;font-style: italic;&quot;&gt;simultaneous attack&lt;/span&gt; of dozens of processes, instead it sees dozens of processes waiting for their queues to finish. The OS can decide then to pick as many tasks from their queues and not worry (mostly) about switching threads.&lt;/p&gt;
&lt;p&gt;Of course the devil is in the details. What if you are not subdividing your tasks well enough that they block the queues for other processes? What if the chunk of code in the queue blocks for disk I/O? What if... queues are not for solving the inherent threading problems OSes will keep having for the foreseeable future. But they help a lot in allowing them to decide what to run and when. In the example give above, the OS could decide to take only two tasks at the same time from the image process queue and two tasks from the video queue, and if any process finishes, the new slots can be given to the reminder tasks in other processes' queues. Similar scenario happens if the platform you are running enables/disables more processing cores. Have you imagined a hardware where you can plug in a card and double the processing speed of the running processes without them having to restart to take advantage of the change? Now you could.&lt;/p&gt;
&lt;p&gt;In fact, all of this is &lt;span style=&quot;font-style: italic;&quot;&gt;in the past&lt;/span&gt;. Note that GCD was introduced in the year 2009. Since then, Apple has been pushing API changes all over their iOS and OSX frameworks to include blocks and queues where they make sense. Even if programmers of these platforms don't explicitly use queues for their programs, most of the libraries they will surely use &lt;span style=&quot;font-weight: bold;&quot;&gt;are&lt;/span&gt; going to take advantage of these task parallelization techniques, thus gaining the advantages mentioned here. And of course, whenever they need to run something in the background, the Objective-C language and APIs will prod them towards queues rather than threads or processes.&lt;/p&gt;
&lt;p&gt;The benefits from using queues are not invisible or theoretical. Already in November of 2010, &lt;a href=&quot;https://github.com/robbiehanson&quot;&gt;Robbie Hanson (aka Deusty)&lt;/a&gt; wrote &lt;a href=&quot;http://deusty.blogspot.com.es/2010/11/introducing-gcd-based-cocoahttpserver.html&quot;&gt;a blog post explaining the benefits of migrating its HTTP server&lt;/a&gt; (&lt;a href=&quot;https://github.com/robbiehanson/CocoaHTTPServer&quot;&gt;CocoaHTTPServer&lt;/a&gt;) to queues. Claimed performance improvements range from doubling to quadrupling, but the most impressive is the &lt;span style=&quot;font-style: italic;&quot;&gt;nearly linear scalability&lt;/span&gt; when the number of concurrent connections was increased. This is the golden dream: increase number of tasks with nearly zero overhead. And Robbie is collaborating to other pieces of software you might not expect could benefit from queues, like &lt;a href=&quot;https://github.com/yaptv/YapDatabase&quot;&gt;YapDatabase&lt;/a&gt;, built on top of &lt;a href=&quot;https://sqlite.org&quot;&gt;SQLite&lt;/a&gt; and providing &lt;a href=&quot;https://github.com/yaptv/YapDatabase/wiki/Hello-World&quot;&gt;smooth database operations not blocking the user interface&lt;/a&gt; to preserve the fluidity of the user's interaction.&lt;/p&gt;
&lt;h2&gt;A bleak future&lt;/h2&gt;&lt;p&gt;Yet here we are, nearly four years later still waiting for the revolution to happen. You could only hope the competition would clone this approach to threaded code as the phone industry copied the iPhone, but I haven't seen yet any other mainstream programming language embedding such functionality in its core language and standard library. And if you think that's bad, we still haven't talked about another pressing issue related to inter process hostility. If only I had the memory to remember what it was all about…&lt;/p&gt;
&lt;p&gt;&lt;pre class='code'&gt;&lt;span class=&quot;Operator&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;nimrod&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;work_faster&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;nim&lt;/span&gt;
&lt;span class=&quot;Identifier&quot;&gt;work_faster&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;nim&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;DecNumber&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;DecNumber&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;cannot&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;CharLit&quot;&gt;'threads'&lt;/span&gt;
&lt;/pre&gt; &lt;/p&gt;

      </content>
    </entry>
    <entry>
      <title>You have to realise that someday you will die…</title>
      <link rel="alternate" type="text/html" href="http://gradha.github.io/articles/2013/10/you-have-to-realise-that-someday-you-will-die….html"/>
      <id>http://gradha.github.io/articles/2013/10/you-have-to-realise-that-someday-you-will-die….html</id>
      <updated>2013-10-01T14:45:00Z</updated>
      <author><name>Grzegorz Adam Hankiewicz</name></author>
      <content type="html">
        &lt;h1&gt;You have to realise that someday you will die…&lt;/h1&gt;&lt;p&gt;…until you know that, you are useless. That's part of the lyrics of &lt;a href=&quot;http://www.leoslyrics.com/tyler-durden/this-is-your-life-lyrics/&quot;&gt;This is your life&lt;/a&gt;, part of the soundtrack to the &lt;a href=&quot;http://www.imdb.com/title/tt0137523/&quot;&gt;Fight club film&lt;/a&gt;, based on &lt;a href=&quot;http://chuckpalahniuk.net/books/fight-club&quot;&gt;a book by Chuck Palahniuk&lt;/a&gt;. It's a sentence I like to remember during the times when everything goes wrong: broken hardware, service providers going out of business, breaking relationships, etc. Focusing on whatever &lt;span style=&quot;font-style: italic;&quot;&gt;is gone&lt;/span&gt; is the result of getting too attached, and that can interfere with new things in life. It simply means change, and people who are unable to change will have a harder time than those who can adapt.&lt;/p&gt;
&lt;p&gt;So my old project Electric Hands Software is gone, and the most disgusting part of &lt;code&gt;http://elhaso.com/&lt;/code&gt; not being available any more is that it has been claimed by automatic spambots, turning it into a casino. With black jack. And hopefully, whores:&lt;/p&gt;
&lt;img src=&quot;/i/the_definition_of_crap.png&quot; alt=&quot;&quot; /&gt;&lt;p&gt;It is clearly a sign of irrelevance when automatic software cares more about your out of business ideas than human people, I don't think that website registered more than 2000 hits during several years. So let the new &lt;a href=&quot;http://www.elhaso.es/&quot;&gt;Electric Hands Software website at http://www.elhaso.es/&lt;/a&gt; shine! But this time it won't be ambitious, I've already been taught all that went wrong and why, there's no point in repeating mistakes.&lt;/p&gt;
&lt;p&gt;Instead, it will live on as a hobby. And since my new hobby is &lt;a href=&quot;http://nimrod-code.org&quot;&gt;the Nimrod programming language&lt;/a&gt;, maybe I should take the crusty C source code of &lt;a href=&quot;http://www.elhaso.es/subhunt/index.en.html&quot;&gt;Submarine Hunt&lt;/a&gt; and rewrite it opensource in nimrod?  Ah, if only these feelings of inebriation lasted a little bit longer…&lt;/p&gt;
&lt;p&gt;&lt;pre class='code'&gt;&lt;span class=&quot;Operator&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;nimrod&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;Operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;life&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;nim&lt;/span&gt;
&lt;span class=&quot;Identifier&quot;&gt;SIGSEGV&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;Illegal&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;storage&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;access&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;Punctation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;Attempt&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;Keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;Keyword&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt; &lt;/p&gt;

      </content>
    </entry>
    <entry>
      <title>Users prefer static linking</title>
      <link rel="alternate" type="text/html" href="http://gradha.github.io/articles/2013/08/users-prefer-static-linking.html"/>
      <id>http://gradha.github.io/articles/2013/08/users-prefer-static-linking.html</id>
      <updated>2013-08-03T12:31:00Z</updated>
      <author><name>Grzegorz Adam Hankiewicz</name></author>
      <content type="html">
        &lt;h1&gt;What is static linking&lt;/h1&gt;&lt;p&gt;Users prefer static linking. That is, if software users would actually know what static linking is. Most users don't know anything about software, how it is built, or how much time you pour into it, but they know one thing: if it works, they expect it to keep working.&lt;/p&gt;
&lt;p&gt;That's where the static linking is important. When a program is compiled a &lt;span style=&quot;font-style: italic;&quot;&gt;binary&lt;/span&gt; is generated. The binary can have dynamic dependencies, which means that it relies on external code that is loaded every time the binary is loaded into memory to be executed. On the other hand, a statically linked binary will &lt;span style=&quot;font-style: italic;&quot;&gt;copy&lt;/span&gt; all (or some) of the external code it requires into the final binary itself.&lt;/p&gt;
&lt;p&gt;The advantage of static linking is that you can copy the binary to another system and it will keep running, something which may not happen if the other system environment doesn't also have the same external library installed. The cost to pay for this is increased binary size, and there are also other drawbacks like the operating system not being able to share the library between processes and having duplicate instances of the same code in memory during execution.&lt;/p&gt;
&lt;p&gt;Mainstream consumer operating systems (Windows, Linux, OS X) provide a big set of shared libraries, allowing programmers to not have to care distributing their own copy with the program. But that soon started to be a problem: different versions of each operating system and/or library could be problematic for the programs. This is usually known as &lt;a href=&quot;https://en.wikipedia.org/wiki/DLL_Hell&quot;&gt;DLL Hell&lt;/a&gt;, where installation of program A on the end user machine brings in version 1 of a shared library, and installation of program B brings in an incompatible version 2 of that same shared library.&lt;/p&gt;
&lt;p&gt;Due to poor DLL versioning or programmer carelessness the end user system becomes unstable. The best is when it actually crashes, because end users &lt;span style=&quot;font-style: italic;&quot;&gt;notice&lt;/span&gt; there is something wrong. The problem is when the programs don't crash immediately, they may crash later, at random or specific times, or behave in not completely correct behaviour, but not exactly right.&lt;/p&gt;
&lt;p&gt;Nowadays even bigger culprits of dynamic linking are dynamic or interpreted languages. Instead of producing compiled code, interpreted languages like &lt;a href=&quot;http://www.python.org&quot;&gt;Python&lt;/a&gt; or &lt;a href=&quot;http://www.ruby-lang.org&quot;&gt;Ruby&lt;/a&gt; are transformed into machine instructions each time they are run. Now they don't only depend on the availability of the dynamic libraries they require, they also depend on the version of the interpreter. If you try to run a script written for say Python 2.5, it won't work on Python 3 because of language incompatibilities. This ends up creating a divide between programmers and affects end users too.&lt;/p&gt;
&lt;p&gt;If you thought your problems are only here, don't look at operating system upgrades, the main reason people are &lt;span style=&quot;font-style: italic;&quot;&gt;scared to death&lt;/span&gt; to upgrade their system.  If you know of a computer end user who is not scared to death of upgrades it is only because he hasn't suffered the experience of &lt;span style=&quot;font-style: italic;&quot;&gt;upgrading&lt;/span&gt; the machine to only find out (sometimes weeks later) that a critical program stopped working because it is incompatible with the new version of the operating system. This causes pain, gnashing of teeth and hatred towards computers and/or programmers.&lt;/p&gt;
&lt;h1&gt;Levels of portability&lt;/h1&gt;&lt;p&gt;The situations explained above don't actually relate all to static linking, or can't be applied at all, since there is no concept of static linking for interpreted languages. So maybe at this point we should rephrase the term of static linking for the end user as a general problem of portability. We also need to consider different levels of portability, for instance:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;The user installed some software, and it works fine. The operating systems has the feature of multiple users and only the user who installed the software can run the program despite it being accessible to other users. Maybe the problem is the installation copied critical files to the user's private directories which are not available to the other users.&lt;/li&gt;&lt;li&gt;The user copies the program to another machine, apparently using the same operating system version. However, it won't run at all. Maybe the &lt;span style=&quot;font-style: italic;&quot;&gt;major&lt;/span&gt; operating system version is the same, but sometimes operating systems have different minor versions, maybe one was upgraded to the latest security patch and this breaks the program's behaviour.&lt;/li&gt;&lt;li&gt;The user copies the program to another machine or upgrades the operating system. The program won't run at all, sometimes without giving any useful explanation.&lt;/li&gt;&lt;li&gt;The user wants to run the software in a cybercafe, or is otherwise somewhere else on lent hardware. The user copies all program files to an USB stick, but surprisingly it doesn't run there.  Why? Even though there are projects to create &lt;a href=&quot;http://portableapps.com&quot;&gt;portable versions of applications&lt;/a&gt; most programs don't expect to be run in such a fashion. Also, even if your spreadsheet software runs you don't want it to leave your bank details on a public computer at a cybercafe just because it thought for convenience that you will always have a private user data folder on the hard drive.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;More different situations could be described, but one thing to note is a program can fall into several of these situations at the same time, and it mostly depends on two factors: technologies used and programmer's interest in portability. Yes, portability is a feature decided by programmers upon their end users. And unfortunately few people care.&lt;/p&gt;
&lt;h1&gt;The solution&lt;/h1&gt;&lt;p&gt;The solution for portability is simple: you copy, bundle, or embed whatever your program needs into your binary. For instance, Windows programs may want to avoid writing into the registry so that copying the folder where the software was installed is enough to copy everything to a different machine and run it there.&lt;/p&gt;
&lt;p&gt;On OS X this is abstracted to the user through the use of &lt;a href=&quot;https://en.wikipedia.org/wiki/Application_bundle&quot;&gt;application bundles&lt;/a&gt;. These are normal directories with a special structure the operating system recognizes and treats uniformly as a single entity. The Finder on OS X won't allow you to copy only part of the bundle's directory somewhere else, and should it fail, it will delete the incomplete bundle. Even if it is left there broken, the system wont run it and will likely draw a translucent stop sign on its icon.&lt;/p&gt;
&lt;p&gt;Linux… Linux users usually don't care. They brag about sophisticate software management programs (oh, the meta) and tell end users they are crazy because they don't want to learn how to use it or search the net for solutions to a dependency, which can be solved, but requires some obscure option/command line switch to work.&lt;/p&gt;
&lt;p&gt;Mobile software stores have adopted the bundle paradigm: they include everything required to run except the basic libraries provided by the system which are (in theory) guaranteed to be the same on all future OS versions. This allows for example software written for the iPhone 3G to still run on the iPhone 5 without updates.&lt;/p&gt;
&lt;p&gt;Note that bundling everything together still requires the program to be &lt;span style=&quot;font-style: italic;&quot;&gt;aware&lt;/span&gt; of being run in this kind of environment. Fortunately for end users the strict rules for iOS and Android are creating more awareness towards the usual &lt;span style=&quot;font-style: italic;&quot;&gt;sandboxes&lt;/span&gt;, so much in fact that OS X desktop users already have an equivalent app store with &lt;span style=&quot;font-style: italic;&quot;&gt;sandboxing&lt;/span&gt; and Windows seems to be following suit.&lt;/p&gt;
&lt;h1&gt;Software proud to be portable&lt;/h1&gt;&lt;p&gt;There are not many developer oriented tools which are written with portability in mind. The authors of &lt;a href=&quot;https://sqlite.org&quot;&gt;Sqlite&lt;/a&gt; and &lt;a href=&quot;http://fossil-scm.org/index.html/doc/trunk/www/index.wiki&quot;&gt;Fossil&lt;/a&gt; are one exceptional case. They aim for the highest level of portability: a single binary which can be copied anywhere and it works.&lt;/p&gt;
&lt;p&gt;Nothing particularly new, but worth of appraise. Long forgotten MSDOS programmers also developed funny &lt;span style=&quot;font-style: italic;&quot;&gt;tricks&lt;/span&gt; to provide single binary portability (remember the times when having a hard disk was rare?). The most notable one was appending additional resources to the binary itself. The operating system would load the whole binary into memory but will ignore the extraneous trailing data. Instead, the application could read it to avoid littering the disk with extra files.&lt;/p&gt;
&lt;p&gt;Surprisingly this technique still works on today's systems. Even more, programs like &lt;a href=&quot;http://upx.sourceforge.net&quot;&gt;UPX&lt;/a&gt; which compress binaries also know how to handle trailing data and are known to work with binary appending tools, like the one provided by the &lt;a href=&quot;http://alleg.sourceforge.net&quot;&gt;C game programming library Allegro&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;However, USB level portability is hard to find for most programming languages compilers and interpreters. The closest may be the &lt;a href=&quot;http://nimrod-code.org&quot;&gt;Nimrod programming language&lt;/a&gt;, since it compiles everything into a single nimrod binary, which can be run everywhere.&lt;/p&gt;
&lt;p&gt;The problem is, will it work? Compiling most source code will require using modules from the standard library. But where are these? Scattered somewhere else. So while it is true that Nimrod produces a statically linked contained binary, it is effectively not portable if for 99% of its usage it depends on external files. Another example, you could be using different nimrod compiler versions for testing, and one works with a specific version of the standard library, but a previous compiled binary won't work due to changes in the language. This requires you to maintain different versions of the standard library module tree, and make sure to point to the correct one with each binary if you actually need to switch.&lt;/p&gt;
&lt;p&gt;Certainly developers are special &lt;span style=&quot;font-style: italic;&quot;&gt;power&lt;/span&gt; users, and they are expected to know how to install tool dependencies, search the net for obscure incantations of poorly known commands, and are usually resilient to repeated failure, with a special knack for banging their head against a wall until they figure out what is wrong.&lt;/p&gt;
&lt;p&gt;However, couldn't we all be nice and provide 100% portable tools too? Why do we provide portability to end users yet again and again we torture ourselves with DLL Hell? Do we enjoy it so much?&lt;/p&gt;
&lt;p&gt;&lt;pre class='code'&gt;&lt;span class=&quot;Operator&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;nimrod&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;forum&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;nim&lt;/span&gt;
&lt;span class=&quot;Operator&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;Operator&quot;&gt;./&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;forum&lt;/span&gt;
&lt;span class=&quot;Identifier&quot;&gt;could&lt;/span&gt; &lt;span class=&quot;Keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;libcairo&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;dylib&lt;/span&gt;
&lt;/pre&gt; &lt;/p&gt;

      </content>
    </entry>
    <entry>
      <title>First post!</title>
      <link rel="alternate" type="text/html" href="http://gradha.github.io/articles/2013/06/first-post.html"/>
      <id>http://gradha.github.io/articles/2013/06/first-post.html</id>
      <updated>2013-06-19T12:31:00Z</updated>
      <author><name>Grzegorz Adam Hankiewicz</name></author>
      <content type="html">
        &lt;p&gt;Hey, so here we are in 2013! People from the past would be proud, I still use static files for websites despite the fancy ipsum genera on my shoulder. I wonder how long will this last…&lt;/p&gt;
&lt;p&gt;&lt;pre class='code'&gt;&lt;span class=&quot;Identifier&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;StringLit&quot;&gt;&amp;quot;Hello interblags!&amp;quot;&lt;/span&gt;
&lt;span class=&quot;Identifier&quot;&gt;quit&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Punctation&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt; &lt;/p&gt;

      </content>
    </entry>
</feed>
