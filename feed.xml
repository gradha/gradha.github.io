<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rants from the Ballmer Peak</title>
  <link href="http://gradha.github.io/" />
  <link href="http://gradha.github.io/feed.xml" rel="self" />
  <id>http://gradha.github.io/</id>
  <generator>ipsumgenera</generator>
  <updated>2015-08-22T20:55:49Z</updated>
    <entry>
      <title>Sad ways documentation generation tools suck</title>
      <link rel="alternate" type="text/html" href="http://gradha.github.io/articles/2015/08/sad-ways-documentation-generation-tools-suck.html"/>
      <id>http://gradha.github.io/articles/2015/08/sad-ways-documentation-generation-tools-suck.html</id>
      <published>2015-08-11T21:45:00Z</published>
      <updated>2015-08-11T21:45:00Z</updated>
      <author><name>Grzegorz Adam Hankiewicz</name></author>
      <content type="html">
        &lt;h1&gt;Sad ways documentation generation tools suck&lt;/h1&gt;
&lt;a href=&quot;http://www.all-idol.com/1587&quot;&gt;&lt;img
    src=&quot;../../../i/documenting.jpg&quot;
    style=&quot;width:100%;max-width:600px&quot; align=&quot;right&quot;
    hspace=&quot;8pt&quot; vspace=&quot;8pt&quot;&gt;&lt;/a&gt;&lt;p&gt;My favourite thing to hack is documentation, it is easy to change, it gives the best bang for the buck, and it is hard to do. Any monkey with a typewriter can produce mountains of documentation (like this blog demonstrates), but writing good documentation is very difficult. So difficult in fact that it is the most neglected feature of any product. And just as software, it requires maintenance. Nobody wants to do maintenance, no matter how important it is. Still, creating, improving, and maintaining documentation is one of my secret little pleasures. Documentation is in fact the ultimate programming language: just like you program a CPU to perform some tasks, documentation programs the brains of the readers to make them achieve impressive things. Or if poorly written, crashes their expectations and dreams, &lt;span style=&quot;font-style: italic;&quot;&gt;bricking&lt;/span&gt; them forever, possibly making them go away from your technically perfect software… nobody knows how to use.&lt;/p&gt;
&lt;p&gt;I don't think I've ever written the perfect documentation, but maybe I've come close, little by little, retouching here and there, kind of like a painter who never knows when the artwork is finished, because in the eyes of the creator everything can still be improved.  I've written documentation for commercial products, but along the years I've been contributing to free and open software maybe the two most important documentation related improvements I've made were to the &lt;a href=&quot;http://liballeg.org&quot;&gt;C game programming library Allegro&lt;/a&gt; and the &lt;a href=&quot;http://nim-lang.org&quot;&gt;Nim programming language&lt;/a&gt;. I'm not talking this time about &lt;span style=&quot;font-style: italic;&quot;&gt;the documentation itself&lt;/span&gt; but about the tools and mechanisms to produce this documentation. With time and distance an odd comparison and conclusion emerges from my experience.  Let me introduce you to the respective tools.&lt;/p&gt;
&lt;h1&gt;The past&lt;/h1&gt;&lt;h2&gt;Allegro's makedoc&lt;/h2&gt;&lt;p&gt;The current Allegro uses &lt;a href=&quot;http://johnmacfarlane.net/pandoc/&quot;&gt;Pandoc&lt;/a&gt; to build its documentation, but in the past a little C &lt;a href=&quot;https://github.com/liballeg/allegro5/tree/09b024bacb9428a9cfa8feade7633b0402287186/docs/src&quot;&gt;makedoc&lt;/a&gt; command used to do the grunt work. &lt;code&gt;makedoc&lt;/code&gt; started as a simple parser for a weirdly hyperlinked text format. As &lt;a href=&quot;https://github.com/liballeg/allegro5/commit/b9508287d74d0a660d9ed70a30503b52bbb4dbb8&quot;&gt;horrible as the format was (lol)&lt;/a&gt; &lt;code&gt;makedoc&lt;/code&gt; made possible the miracle of generating from a single source file &lt;a href=&quot;https://github.com/liballeg/allegro5/blob/09b024bacb9428a9cfa8feade7633b0402287186/docs/src/makedoc/makedoc.c&quot;&gt;ASCII, HTML, TexInfo, RTF&lt;/a&gt; and other derivative file formats like PDF which were made from the previous ones. This happened in the times of &lt;a href=&quot;https://en.wikipedia.org/wiki/MS-DOS&quot;&gt;MS-DOS&lt;/a&gt; and &lt;a href=&quot;http://www.delorie.com/djgpp/&quot;&gt;DJGPP&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Given the strict limitations of &lt;code&gt;makedoc&lt;/code&gt; I have to say it was a terrific success. I still remember how much fun I had when I added &lt;a href=&quot;https://github.com/liballeg/allegro5/commit/68faf6b825a043805cc7a298ee1dff3e4c38097b&quot;&gt;the possibility of cross referencing examples from the API documentation&lt;/a&gt;. As any big library, Allegro contained a vast list of examples to showcase the functionality, but examples and documentation lived in separate universes, far from each other. The improvement added additional documentation building phases where the examples would be scanned for symbols. Then this symbol database was used to generate the chapter listing all the examples. With this, the documentation &lt;span style=&quot;font-style: italic;&quot;&gt;suddenly&lt;/span&gt; was aware of examples, and therefore visible to readers.&lt;/p&gt;
&lt;p&gt;But even better, thanks to the symbol database whenever &lt;code&gt;makedoc&lt;/code&gt; would generate the documentation for any API it would scan this database and automatically hyperlink the example showcasing its use. So if you had a function &lt;code&gt;draw_something()&lt;/code&gt;, it would list all the examples which &lt;span style=&quot;font-weight: bold;&quot;&gt;used&lt;/span&gt; that API.  And since the mapping between API and examples wasn't necessarily one to one, you could add manual cross references where appropriate.&lt;/p&gt;
&lt;p&gt;The current Pandoc version doesn't do this, and it is a shame, but the developers who continued maintaining Allegro certainly decided that the externalization of the hacky custom documentation generator few wanted to touch was worth their personal time. And I agree. If at the time I had known of tools like Pandoc, instead of maintaining &lt;code&gt;makedoc&lt;/code&gt; I would have likely created scripts or tools to improve it with the features API documentation creation requires.  An ugly source code with manual memory management, weird extensions and backwards compatibility tricks (I don't remember &lt;span style=&quot;font-weight: bold;&quot;&gt;ever&lt;/span&gt; breaking existing docs) grown organically, manually maintained list of files to parse and build, it finally met its end. A toast to you, &lt;code&gt;makedoc&lt;/code&gt;. I did learn a lot about building documentation, and how it is vital for a project.&lt;/p&gt;
&lt;h2&gt;Nim's docgen&lt;/h2&gt;&lt;p&gt;Nim's documentation generation can be explained as the sum of two parts: an extractor and a generator. The generator uses a custom &lt;a href=&quot;http://nim-lang.org/docs/rstgen.html&quot;&gt;reStructuredText&lt;/a&gt; format to create HTML or LaTeX output. Documentation lives as comments embedded in the source file.  The extractor is part of the compiler living in the &lt;a href=&quot;https://github.com/nim-lang/Nim/blob/9764ba933b08e9e04a145c922ab32bfa06cc7400/compiler/docgen.nim&quot;&gt;docgen.nim&lt;/a&gt; file. Using the compiler for API and comment extraction is the fastest way to reuse code, but unfortunately makes changes to the documentation generation tool a pain.  Araq has mentioned several times that docgen should  be split, but who knows when that would happen. Or if the split &lt;a href=&quot;https://github.com/nim-lang/Nim/issues/2757&quot;&gt;will&lt;/a&gt; &lt;a href=&quot;https://github.com/nim-lang/Nim/issues/2341&quot;&gt;cause&lt;/a&gt; &lt;a href=&quot;https://github.com/nim-lang/nimsuggest/issues/1&quot;&gt;even&lt;/a&gt; &lt;a href=&quot;https://github.com/nim-lang/nimsuggest/issues/6&quot;&gt;more&lt;/a&gt; &lt;a href=&quot;https://github.com/nim-lang/nimsuggest/issues/3&quot;&gt;problems&lt;/a&gt;.&lt;/p&gt;

&lt;a href=&quot;http://www.idol-grapher.com/1567&quot;&gt;&lt;img
    src=&quot;../../../i/missing_docs.jpg&quot;
    style=&quot;width:100%;max-width:600px&quot; align=&quot;right&quot;
    hspace=&quot;8pt&quot; vspace=&quot;8pt&quot;&gt;&lt;/a&gt;&lt;p&gt;From the improvements I made to &lt;code&gt;docgen&lt;/code&gt; maybe the most important one was &lt;a href=&quot;http://nim-lang.org/docs/docgen.html#html-anchor-generation&quot;&gt;predictable hyperlinks&lt;/a&gt;. The original &lt;code&gt;docgen&lt;/code&gt; would scan the source code and generate hyperlinks using a counter: the first API entry would be zero, the second one, etc, etc. Pretty horrible, since that makes hyperlinks &lt;span style=&quot;font-weight: bold;&quot;&gt;dead by design&lt;/span&gt;. Nobody is going to use them knowing that at some point a new API or just a simple code refactoring can break them. On the other hand, predictable hyperlinks make it possible to tell somebody 'hey, loop this up &lt;span style=&quot;font-weight: bold;&quot;&gt;here&lt;/span&gt;', rather than 'hey, open this huge generated document and try to find whatever keyword I'm telling you about'.&lt;/p&gt;
&lt;p&gt;Unlike with the Allegro community, which quickly embraced every new documentation feature, I don't think these improvements were much appreciated in Nim land.  The easiest way to verify something is good is when other people use it. I did contribute new documentation adding hyperlinks showing &lt;span style=&quot;font-style: italic;&quot;&gt;how it should be done&lt;/span&gt;, improved existing documentation (aka, maintaining), but other developers didn't seem to care. The biggest advancement I saw was when other contributors started quoting symbols so that words would &lt;code&gt;show up in monospaced font&lt;/code&gt;. But rarely with a hyperlink.  It looks like the best Nim documentation is the &lt;span style=&quot;font-style: italic;&quot;&gt;non existant&lt;/span&gt; documentation.&lt;/p&gt;
&lt;p&gt;I had plans to improve &lt;code&gt;docgen&lt;/code&gt; &lt;span style=&quot;font-style: italic;&quot;&gt;at least&lt;/span&gt; to the level of &lt;code&gt;makedoc&lt;/code&gt;, but even better with &lt;span style=&quot;font-weight: bold;&quot;&gt;automatic&lt;/span&gt; hyperlinks, checks against 404 (in case an API changes), execution of embedded examples for implicit unit testing, generation of &lt;a href=&quot;https://github.com/nim-lang/Nim/issues/1401&quot;&gt;dash/zeal docsets&lt;/a&gt; (which I had already started anyway), etc. However the environment slowly drained my enthusiasm. Pull requests seemed an uphill battle and weirdly sometimes took many weeks to review, while other changes were approved faster than you could blink. Sometimes they were &lt;a href=&quot;https://github.com/nim-lang/Nim/pull/1452&quot;&gt;ignored&lt;/a&gt; despite &lt;a href=&quot;https://github.com/nim-lang/Nim/issues/1136&quot;&gt;users requesting such changes&lt;/a&gt;. Other developers usually ignored existing documentation styles, sometimes producing a final odd mixture to read. I finally decided to stop contributing to Nim when &lt;a href=&quot;https://github.com/nim-lang/Nim/pull/1869&quot;&gt;Araq deliberately lost some improvements to the json module&lt;/a&gt;.  If contributions are to be wasted like that on an arbitrary merge I prefer to waste my time elsewhere.&lt;/p&gt;
&lt;h2&gt;Third time's a charm?&lt;/h2&gt;&lt;p&gt;Since documentation is one of my obsessions I felt I had to do something when so many people contributed &lt;a href=&quot;https://github.com/nim-lang/nimble&quot;&gt;Nimble&lt;/a&gt; &lt;a href=&quot;https://github.com/nim-lang/packages&quot;&gt;packages&lt;/a&gt; which rarely had any documentation or even the most basic of READMEs. Believing that the pain of generating and publishing documentation was to blame, I started &lt;a href=&quot;https://github.com/gradha/gh_nimrod_doc_pages&quot;&gt;gh_nimrod_doc_pages&lt;/a&gt; with the hope that a mostly automatic command would alleviate the repulsion towards documentation most programmers seem to experience. The &lt;code&gt;gh_nimrod_doc_pages&lt;/code&gt; command was meant to be run after each software release and generate static HTML files from the local source reStructuredText or MarkDown files, which would then be uploaded to &lt;a href=&quot;https://pages.github.com&quot;&gt;GitHub Pages&lt;/a&gt; on the next commit.&lt;/p&gt;
&lt;p&gt;And it does, but maybe it is not the best approach. Maybe I didn't &lt;a href=&quot;http://forum.nim-lang.org/t/460&quot;&gt;publicise it enough&lt;/a&gt;, because very few people ended up using it. Maybe instead of putting the burden on the documentation generator I should have made it &lt;a href=&quot;https://github.com/gradha/gh_nimrod_doc_pages/issues/25&quot;&gt;integrate with Nimble&lt;/a&gt; (or Babel, as it used to be named) so that users could generate the docs despite the original developer not caring about them. Maybe it was too specific, who uses &lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt; when everybody is doing &lt;a href=&quot;https://bitbucket.org&quot;&gt;BitBucket&lt;/a&gt;. In any case I consider it a practical failure, but at least it helped me to document my own Nimble packages.&lt;/p&gt;
&lt;p&gt;One of the features it does is scan the final HTML output and rename hyperlinks in some cases. It is very nice to be able to have reStructuredText or MarkDown documentation which refers to other such files. The question is, do you refer to their source or to their final HTML versions? If you use the source, the link in the GitHub visualization works, but end users generating the HTML locally will get a broken link (they expect to link the HTML version instead). If you use an HTML link you have a broken link for GitHub browsers. So &lt;code&gt;gh_nimrod_doc_pages&lt;/code&gt; detects documentation source links and renames them to HTML in the generated documentation. Then you can write links which work on both sides, the online visualization and the final HTML output.&lt;/p&gt;
&lt;p&gt;Being greedy I also wanted to integrate documentation with source code. Wouldn't it be cool to have API &lt;code&gt;procs&lt;/code&gt; have a &lt;span style=&quot;font-style: italic;&quot;&gt;see source code&lt;/span&gt; which would take you to a local HTML version of the source code? Wouldn't it be even better to have this HTML version with syntax highlighting &lt;span style=&quot;font-weight: bold;&quot;&gt;and&lt;/span&gt; hyperlinks to other symbols, either their documentation or their source code? That would be nice, it would effectively turn all source code into a navigable HTML website.  But something wasn't feeling right, even with patches here and there the design was hard to maintain as I was writing the software. In the end, another dead useless project more, I guess…&lt;/p&gt;
&lt;h1&gt;The elephant in the text&lt;/h1&gt;&lt;p&gt;The common feature of these three failed documentation generators (&lt;code&gt;makedoc&lt;/code&gt;, &lt;code&gt;docgen&lt;/code&gt;, &lt;code&gt;gh_nimrod_doc_pages&lt;/code&gt;) is that they treat documentation as a second class citizen. If you are a C programmer you have likely heard the expression &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_citizen&quot;&gt;first-class citizen&lt;/a&gt;, usually applied to a functional coding style where you pass procs/methods to other procs/methods as parameters.  The way documentation is treated as a second class citizen is easy to see when you compare documentation to source code. Source code gets our love, our tool support, our IDE integration.  Documentation? Meh, who cares, only a bunch of lame old timers do that.  Besides, what does it mean for documentation to be a first class citizen anyway?&lt;/p&gt;
&lt;p&gt;All the three documentation generation tools  require you to specify the input files the documentation is made of (&lt;code&gt;gh_nimrod_doc_pages&lt;/code&gt; scans automatically for files, but this is a terrible illusion, internally it is still a &lt;code&gt;proc&lt;/code&gt; processing items from a list one at a time without context).  Compare this to how you build software in any modern programming language. In Nim you write &lt;code&gt;nim c module.nim&lt;/code&gt;. And that's it, because the source is king, the source says &lt;code&gt;import strutils&lt;/code&gt;, and the Nim compiler will understand that it has to look for the &lt;a href=&quot;http://nim-lang.org/docs/strutils.html&quot;&gt;strutils module&lt;/a&gt;, process it, and link it together.  Even good old Objective-C got a new &lt;a href=&quot;http://stackoverflow.com/a/23146109/172690&quot;&gt;@import modules syntax&lt;/a&gt;, because as a programmer if you need to specify in the source code &lt;span style=&quot;font-weight: bold;&quot;&gt;and&lt;/span&gt; in the build tool that you need to link something, you are repeating yourself. So the natural place is for the source code to dictate what the build tool has to do.&lt;/p&gt;
&lt;p&gt;How does this relate to documentation? You should be able to write &lt;code&gt;build_docs some_file.txt&lt;/code&gt; and that's it. The build tool should start processing the text file and automatically detect hyperlinks. Not only would the hyperlinks be verified, but they would tell the build tool to add yet another file into the build process, generating it along. Just like your Java or Nim projects! Simple, isn't it? Well, why the hell aren't we doing that? Of course this increases the complexity of the documentation tool, since it needs to have different steps in scanning, parsing and linking everything together, but we have decades of experience doing that with source code, which is presumably harder to make sense of.  Once you change your mindset into understanding that documentation is &lt;span style=&quot;font-style: italic;&quot;&gt;yet another kind of source code project&lt;/span&gt; you start treating it as it deserves. Now you can provide static analysis (no more dead hyperlinks!) and even more exotic features like code hyperlinks, pointing to examples or implementation files and vice versa. It is just a language more, so there is no problem to integrate it with your IDE.&lt;/p&gt;
&lt;h1&gt;The uncertain future&lt;/h1&gt;&lt;p&gt;While I haven't officially killed &lt;code&gt;gh_nimrod_doc_pages&lt;/code&gt; yet, I'm still deciding whether I should continue it or let it die. It is possible to implement some of these features as I've been doing now, parsing the generated HTML and processing it further, but some things will really be difficult or impossible to do without collaboration from &lt;code&gt;docgen&lt;/code&gt; or whatever springs up in the future. What follows is a list of the features I was planning to implement. May you pick this up and use it for good.&lt;/p&gt;
&lt;h2&gt;Feature: no manual file lists, automatic dependencies&lt;/h2&gt;&lt;p&gt;As said earlier, you should be able to write &lt;code&gt;build_docs some_file.txt&lt;/code&gt;. This file you are processing should be a &lt;a href=&quot;https://docs.python.org/2/&quot;&gt;welcome file&lt;/a&gt; with further links to other parts of the documentation. The documentation generator will detect the links to external files and process them too. Manual file lists or file patterns should be used only if for some reason you need to include/exclude a set of files for some reason.&lt;/p&gt;
&lt;p&gt;Being able to build all the documentation from a single entry point avoids errors and makes it easy to verify that everything is actually available to the user in the final navigation. There is no point in creating documentation if you never ever link to it and nobody sees it.&lt;/p&gt;
&lt;h2&gt;Feature: strong/non broken links&lt;/h2&gt;&lt;p&gt;Related to the previous one, when a document file links another one, it should use a hyperlink anchor which is valid. In essence this is like programming in C and calling the &lt;code&gt;printf()&lt;/code&gt; function after you have included the appropriate header file, the compiler will validate that the &lt;code&gt;printf()&lt;/code&gt; symbol is available. Since a hyperlink already tells you what file it is referring to, that one gets imported, built together (see previous feature) and validated for anchors. This gives you the peace of mind that you are not referring to something that has moved.&lt;/p&gt;
&lt;p&gt;Circular dependencies are easily solved because a hyperlink doesn't immediately &lt;span style=&quot;font-style: italic;&quot;&gt;require&lt;/span&gt; the other file to be processed nor does it have to know anything about it unlike statically typed programming languages. The referred file will be processed together, but link validation can be done at a later stage: first all referred files are imported if not already cached and scanned for symbols, then hyperlinks are resolved and validated when no more files are to be added to the build. Luckily there is no such a thing as mutually recursive types in documentation.&lt;/p&gt;
&lt;h2&gt;Feature: internal symbols&lt;/h2&gt;&lt;p&gt;Also, you shouldn't be linking to the final HTML output anchor, you should be linking to an internal documentation &lt;span style=&quot;font-weight: bold;&quot;&gt;symbol&lt;/span&gt;.  Does this symbol &lt;span style=&quot;font-style: italic;&quot;&gt;resolve&lt;/span&gt; to an HTML anchor? Yes, but you don't care how it looks, you are referring to an element inside your documentation. Of course, generated links should be easily predictable by documentation users.  It is actually OK if you follow the syntax of a typical hyperlink for internal symbols, but it is terribly bad if you use the HTML output anchor as the source link. See this reStructuredText example:&lt;pre class='literal'&gt;
See `See Düsseldorf, Lörick &amp;lt;d%C3%BCsseldorf.html#L%C3%B6rick&amp;gt;`_
for info.&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;That's terrible for you as a documentation creator. Firs problem is that your hyperlink goes to an HTML file. What if you want to generate a PDF? I guess it's OK if you use an HTML to PDF conversion tool, but we are in 2015 and maybe you should expect your toolchain to be able to produce PDFs directly. Second problem is that since you have already lowered your hyperlink to HTML you require to use ugly percent encoded anchors. Instead you should be able to write:&lt;pre class='literal'&gt;
See `See Düsseldorf, Lörick &amp;lt;düsseldorf.rst#Lörick&amp;gt;`_ for info.&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;Our hypothetical documentation generation tool will understand this to be an internal anchor, bring in the &lt;code&gt;düsseldorf.rst&lt;/code&gt; file for processing, validate the &lt;code&gt;Lörick&lt;/code&gt; internal symbol and resolve it to a valid HTML anchor in the last generation step.&lt;/p&gt;

&lt;a href=&quot;http://mang2goon.tistory.com/379&quot;&gt;&lt;img
    src=&quot;../../../i/hyeyeon_approval.jpg&quot;
    style=&quot;width:100%;max-width:600px&quot; align=&quot;right&quot;
    hspace=&quot;8pt&quot; vspace=&quot;8pt&quot;&gt;&lt;/a&gt;&lt;h2&gt;Feature: example code renderization and symbol detection&lt;/h2&gt;&lt;p&gt;When you write documentation about an API it can sometimes help to see the source of examples using the API to which you can navigate and see the API usage in full context. Your documentation system should have a way to tell the build tool to &lt;span style=&quot;font-style: italic;&quot;&gt;scan&lt;/span&gt; external files and look for the used symbol the build a list of files. Of course, as mentioned in the first rule, this means the example files' source code get also built and rendered with syntax highlighting so that you can view everything inside your documentation browser. Bonus points if your source code itself is also hyperlinked and clicking on a symbol in the rendered code will lead you to the API documentation for that symbol.&lt;/p&gt;
&lt;p&gt;You should be able to do this today too, I was doing most of this feature in 2005. In the snow. In C. Uphill. OK, I used external tools and extra build steps, but only because I didn't know better at the time.&lt;/p&gt;
&lt;h2&gt;Feature: embedded example validation&lt;/h2&gt;&lt;p&gt;Sometimes rather than looking at an example it is good enough to see just a few lines of code. This is done quite a lot in &lt;a href=&quot;http://nim-lang.org/docs/tut1.html&quot;&gt;tutorials&lt;/a&gt;. Unfortunately these snippets of code are not verified and tend to &lt;a href=&quot;https://github.com/nim-lang/Nim/issues/2928&quot;&gt;bit rot&lt;/a&gt;. The way I was planning to solve this in Nim was to add two extra sections before and after the source code to showcase. The build tool should concatenate all three blocks of source code (pre + body + post) into a temporary source file and build it to scan for errors and refuse to continue building documentation until everything is fixed. Embedded code without pre/post blocks would not be tested of course.&lt;/p&gt;
&lt;p&gt;The final output would by default show only the body block, but for interactive outputs like HTML a JavaScript button would unfold/fold the pre/post blocks to let the reader see what else was needed to prepare those few lines of source code if needed. As a bonus you get unit testing for the parts of the API you happen to document like this, and you could let the example &lt;span style=&quot;font-style: italic;&quot;&gt;run&lt;/span&gt; and embed its output in the generated documentation, saving you the manual duplication typical in such examples.&lt;/p&gt;
&lt;p&gt;Since these validations are expensive you may want to disable them for the typical documentation generation run, or maybe add a &lt;code&gt;test_examples&lt;/code&gt; command so that they can be invoked in a continuous integration server after each commit.&lt;/p&gt;
&lt;h2&gt;Feature: forward declarations&lt;/h2&gt;&lt;p&gt;The documentation generator builds internally a symbol database for each included file. Well, make it public, generate a &lt;code&gt;docindex.sqlite&lt;/code&gt; file or something. Let users include this file or refer to it in your documentation for cross library/API references. Go to the main &lt;a href=&quot;http://gradha.github.io/midnight_dynamite/gh_docs/master/midnight_dynamite.html&quot;&gt;midnight_dynamite module documentation&lt;/a&gt; and look at the sad, very sad imports section. Click that &lt;a href=&quot;http://gradha.github.io/midnight_dynamite/gh_docs/master/os.html&quot;&gt;os module link&lt;/a&gt;. Not there? Try then &lt;a href=&quot;http://gradha.github.io/midnight_dynamite/gh_docs/master/streams.html&quot;&gt;streams module&lt;/a&gt; then. What, 404 too? Seriously, why? A minimal start would be to know that these modules are not available and &lt;span style=&quot;font-style: italic;&quot;&gt;remove&lt;/span&gt; the hyperlink. After all, what good does it do to frustrate users?  Leave the reference as plain text and avoid the pain.&lt;/p&gt;
&lt;p&gt;Thanks to this hypothetical &lt;code&gt;docindex.sqlite&lt;/code&gt; file (&lt;a href=&quot;http://nim-lang.org/docs/docgen.html#index-idx-file-format&quot;&gt;wink wink&lt;/a&gt;) other people creating public libraries can refer to the standard library of your language and hyperlink it without problem. In the main documentation index (or maybe as a command line switch or configuration file) you could write something like:&lt;pre class='literal'&gt;
refdoc stdlib http://nim-lang.org/docs/docindex.sqlite&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;The URL tells the builder to download and parse that file, then make it available with the optional &lt;code&gt;stdlib&lt;/code&gt; prefix. Optional means that if there is no symbol collision you can write the reference like usual. If there are two symbols with the same name, the build tool will warn you and force you to write &lt;code&gt;stdlib.symbol&lt;/code&gt; instead of just &lt;code&gt;symbol&lt;/code&gt; in your hyperlinks. Just like normal source code! How amazingly original!&lt;/p&gt;
&lt;h2&gt;Feature: documentation macros&lt;/h2&gt;&lt;p&gt;No software wish list is complete until you request the software itself to be programmable. The features mentioned above are directly aimed at the specifics of documenting software API references, which heavily depend on hyperlinks. But sometimes you could want to document something like a file format. I've &lt;a href=&quot;https://github.com/gradha/OpenIrekia-iOS/blob/master/docs/server_protocol.txt&quot;&gt;done that before for JSON protocols&lt;/a&gt; and I have to say it is a &lt;a href=&quot;https://github.com/gradha/OpenIrekia-iOS/blob/master/docs/server_protocol.txt#L118-L126&quot;&gt;pain in the ass&lt;/a&gt; with normal documentation syntax to generate internal links and such. Normal file formats are not meant for that, which is the reason why tools like &lt;a href=&quot;http://swagger.io&quot;&gt;Swagger&lt;/a&gt; are so popular, because at some point a tool generates HTML and saves you all the duplication of symbols, tables of contents and such, producing the best possible output.&lt;/p&gt;
&lt;p&gt;Can typical documentation file formats support such extensibility? I don't know, which is why I'm putting a big question mark here. I've seen a few which allow extensibility but usually in a very limited fashion, or in a way that is completely external to the currently processed file (i.e. run this command and fetch the output). Would it be possible to write some kind of macro system where you could generate the documentation's AST and programatically build all those little internal hyperlinks and repeated structures? Maybe, but then you will have to fight users wanting each their own language. Unless you settle for JavaScript… yuck. Well, at least we can dream.&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;&lt;p&gt;It is not a wonder that making a generic tool supporting all these features would be a nightmare and would leave everybody unhappy. Which is the reason we don't see such tools, they have to be implemented specifically for each programming language that wants such tight documentation integration. Is your favourite programming language helping or getting in the way?&lt;/p&gt;
&lt;pre class='literal'&gt;$ nim doc2 midnight_dynamite.nim
lib/pure/parsecfg.nim(20, 4) Error: cannot open 'doc/mytest.cfg'
midnight_dynamite.nim(176, 10) Error: undeclared identifier: 'TCfgParser'
midnight_dynamite.nim(177, 7) Error: type mismatch: got ()
but expected one of:
system.open(f: var File, filehandle: FileHandle, mode: FileMode)
system.open(f: var File, filename: string, mode: FileMode, bufSize: int)
system.open(filename: string, mode: FileMode, bufSize: int)

midnight_dynamite.nim(179, 13) Error: undeclared identifier: 'next'
midnight_dynamite.nim(179, 17) Error: undeclared identifier: 'next'
midnight_dynamite.nim(179, 17) Error: expression 'next' cannot be called
midnight_dynamite.nim(180, 11) Error: undeclared identifier: 'kind'
midnight_dynamite.nim(180, 11) Error: expression '.' cannot be called
midnight_dynamite.nim(181, 8) Error: undeclared identifier: 'cfgEof'
midnight_dynamite.nim(181, 8) Error: internal error: cannot generate code for: cfgEof
No stack traceback available
To create a stacktrace, rerun compilation with ./koch temp doc2 &amp;lt;file&amp;gt;&lt;/pre&gt;
      </content>
    </entry>
    <entry>
      <title>Hard memory problems</title>
      <link rel="alternate" type="text/html" href="http://gradha.github.io/articles/2015/06/hard-memory-problems.html"/>
      <id>http://gradha.github.io/articles/2015/06/hard-memory-problems.html</id>
      <published>2015-06-14T20:05:00Z</published>
      <updated>2015-06-14T20:05:00Z</updated>
      <author><name>Grzegorz Adam Hankiewicz</name></author>
      <content type="html">
        &lt;h1&gt;Hard memory problems&lt;/h1&gt;
&lt;a href=&quot;https://instagram.com/p/vzWU8iSB9B/&quot;&gt;&lt;img
    src=&quot;../../../i/crayon_pop_explain.jpg&quot;
    alt=&quot;Endless pit of patience&quot;
    style=&quot;width:100%;max-width:320px&quot; align=&quot;right&quot;
    hspace=&quot;8pt&quot; vspace=&quot;8pt&quot;&gt;&lt;/a&gt;&lt;p&gt;The conclusion of &lt;a href=&quot;http://gradha.github.io/articles/2015/06/../../2013/10/40-years-later-we-still-cant-be-friends.html&quot;&gt;one of my previous articles&lt;/a&gt; might have led you to believe nobody cares about new better ways of sharing the CPU for end users. That's correct, but still solvable for many scenarios through libraries like &lt;a href=&quot;https://en.wikipedia.org/wiki/Grand_Central_Dispatch&quot;&gt;Grand Central Dispatch (GCD)&lt;/a&gt;, so it is a matter of time until the rest of the industry drags their feet forward. The problem we really haven't solved is about memory.  From a practical point of view, the CPU is &lt;span style=&quot;font-style: italic;&quot;&gt;sort of&lt;/span&gt; infinite if we look into the dimension of time: no current time slice for my starved process? OK, let's just wait a few clock ticks more until we can run. On the other hand, if a process gets any amount of memory, that memory is lost, completely gone and impossible to recover for any other process on the machine. In weird situations even the original owner of the memory may be unable to recover it! Why? What did we do to deserve this punishment?&lt;/p&gt;
&lt;h2&gt;Memento fragmentation&lt;/h2&gt;&lt;p&gt;Allocation of &lt;a href=&quot;http://en.wikipedia.org/wiki/C_dynamic_memory_allocation&quot;&gt;dynamic memory&lt;/a&gt; is still done today through a very simple interface. When you want a chunk of memory, you call &lt;a href=&quot;http://man7.org/linux/man-pages/man3/malloc.3.html&quot;&gt;malloc() and later free()&lt;/a&gt;. If you are not using C, your language may provide a different set of primitives, like &lt;a href=&quot;https://en.wikipedia.org/wiki/New_(C%2B%2B)&quot;&gt;new and delete in C++&lt;/a&gt;, but the basic idea is you ask for a chunk of memory, and you later free this chunk of memory. Higher level languages with &lt;span style=&quot;font-style: italic;&quot;&gt;managed memory&lt;/span&gt;, usually implementing a &lt;a href=&quot;https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)&quot;&gt;garbage collector&lt;/a&gt;, alleviate the programmer from doing this task manually but it still exists there, it's just a little bit hidden.&lt;/p&gt;
&lt;p&gt;In any case, the OS has to keep track of what cells in the whole hardware memory are free to use. And there is always a trade-off between precision of what byte belongs to whom, and space efficiency. Usually the OS will subdivide the hardware memory in blocks. Even lower level, the hardware itself might be able to provide memory to the OS only at the &lt;span style=&quot;font-style: italic;&quot;&gt;page&lt;/span&gt; granularity of say 1KB or 4KB. Programs have complex memory allocation patterns. If the program allocates different chunks, and frees one of them, the remaining chunks may prevent the shared memory block from being freed, and even make it not usable for future memory requests. This is called &lt;a href=&quot;https://en.wikipedia.org/wiki/Fragmentation_(computing)&quot;&gt;memory fragmentation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let's say that the OS imposes memory boundaries of 1KB and you request a &lt;code&gt;malloc()&lt;/code&gt; chunk of 1500 bytes. That will use two pages of memory. Depending on how clever the OS wants to be, the remaining bytes of the second page might be unable to other &lt;code&gt;malloc()&lt;/code&gt; requests. In this situation, your process is effectively losing &lt;code&gt;2048 - 1500 = 548&lt;/code&gt; bytes. If the OS is &lt;span style=&quot;font-style: italic;&quot;&gt;clever&lt;/span&gt;, let's say that it allows you to reuse this space. So we start again with a reserve of 1500 bytes, and get two pages.  Now we request another 1500 bytes, and the OS being clever gives us one page more, with the second allocation starting right at the end of the first one.  This is very nice, from the three pages of 1024 bytes we are losing only &lt;code&gt;(1024 * 3) - (1500 * 2) = 72&lt;/code&gt; bytes. Now the question is, what happens when the first &lt;code&gt;malloc()&lt;/code&gt; is freed? Only the first page can be freed. But more importantly, what if we now want to &lt;code&gt;malloc()&lt;/code&gt; 10KB? The OS is unable to give us that first page, because it is not contiguous to the other ones we need. Hence, we get a contiguous block of pages &lt;span style=&quot;font-style: italic;&quot;&gt;after&lt;/span&gt; the third page. We have fragmented our own free memory, the first hardware page is free, but we are not getting it.&lt;/p&gt;
&lt;p&gt;Memory allocators are always tricky software to write. Maybe one of the most famous ones is the one by &lt;a href=&quot;http://g.oswego.edu/dl/html/malloc.html&quot;&gt;Doug Lea&lt;/a&gt;. That page has a lot of juicy information, you can read it to get an idea about many more problems memory allocators have to deal with. I love to rant on the problem of sharing memory between languages inside the same process.&lt;/p&gt;
&lt;h2&gt;Sharing is caring&lt;/h2&gt;
&lt;a href=&quot;https://instagram.com/p/1hAndMyB2u/&quot;&gt;&lt;img
    src=&quot;../../../i/crayon_pop_sharing.jpg&quot;
    alt=&quot;Gangsta sharing&quot;
    style=&quot;width:100%;max-width:320px&quot; align=&quot;right&quot;
    hspace=&quot;8pt&quot; vspace=&quot;8pt&quot;&gt;&lt;/a&gt;&lt;p&gt;The memory interface is very minimal, and once a program has hold of a memory block, the OS guarantees that this block will be available forever to the program at that specific memory address. Since most programming languages are based on the idea of pointers, the OS is not able to &lt;span style=&quot;font-style: italic;&quot;&gt;move&lt;/span&gt; or reshuffle this block of memory because somewhere a variable might still point to the old &lt;span style=&quot;font-weight: bold;&quot;&gt;address&lt;/span&gt;. Moving this memory around could lead to crashes when this variable/pointer is later used to read or write to memory.&lt;/p&gt;
&lt;p&gt;In summary, dynamic memory handling in most programming languages is tied to these two very basic restrictions, which are not the fault of the language but of the foundation OSes provide:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;The OS doesn't have any idea what the memory is going to be used for, or for how long.&lt;/li&gt;&lt;li&gt;Once provided, the OS is unable to move this memory later due to guarantees to its physical address.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;How many times have you written software that depended on these restrictions being valid? Never? Unless you are writing some kind of &lt;a href=&quot;https://en.wikipedia.org/wiki/Direct_memory_access&quot;&gt;DMA level&lt;/a&gt; software, kernel, audio/video streaming interface, or similar piece of software which is &lt;span style=&quot;font-style: italic;&quot;&gt;really&lt;/span&gt; restricted by the hardware, you are unlikely to ever care &lt;span style=&quot;font-weight: bold;&quot;&gt;where&lt;/span&gt; the memory is allocated, or if it actually stays &lt;span style=&quot;font-weight: bold;&quot;&gt;there&lt;/span&gt; much later. Most software developers only care about memory being available or not. If there is not enough, the program just gives up and asks the user to buy more. Still, OSes are tied to this basic interface since the beginning of time. So you end up with the problem we described earlier for pages but at the level of whole processes.&lt;/p&gt;
&lt;h2&gt;Memory boundaries&lt;/h2&gt;&lt;p&gt;If memory issues are already bad between a process and the OS, you have additional barriers when you want to produce software which involves two or more different programming languages. Some time ago I started writing &lt;a href=&quot;http://pyallegro.sourceforge.net/alpy.php&quot;&gt;AlPy&lt;/a&gt;, a small binding between Python and &lt;a href=&quot;http://alleg.sourceforge.net&quot;&gt;Allegro&lt;/a&gt;. Since Allegro is a C library, you deal with creation and destruction of bitmaps manually. In Python land, you rarely if ever notice memory allocation, it is automatic. And there are two ways to write a binding for Python: you either make memory allocation explicit to the Python programmer, or you make it implicit.&lt;/p&gt;
&lt;p&gt;An explicit interface would mean that the user creates some &lt;code&gt;Bitmap&lt;/code&gt; placeholder object in Python land, and before using it another initialization method has to be called on it to reserve the appropriate amount of memory (which would call the C function).  Later when the user is done with the object another method is called, and the associated memory is freed, despite the Python placeholder still being alive and kicking. An implicit interface would let Python users to create freely as much &lt;code&gt;Bitmap&lt;/code&gt; objects as they want, and only usage of these objects would trigger allocations (and later deallocation when the Python object is deleted). The disadvantage of this method is that memory allocation/freeing is a potentially expensive operation you might want to control.&lt;/p&gt;

&lt;br clear=&quot;right&quot;&gt;&lt;center&gt;
&lt;a href=&quot;https://instagram.com/p/ybmONSGosR/&quot;&gt;&lt;img
    src=&quot;../../../i/kpop_interracial.jpg&quot;
    alt=&quot;Jake Pains&quot;
    style=&quot;width:100%;max-width:750px&quot; align=&quot;center&quot;
    hspace=&quot;8pt&quot; vspace=&quot;8pt&quot;&gt;&lt;/a&gt;
&lt;/center&gt;&lt;p&gt;In any of these cases, it is possible that objects created at the Python level which are not necessary any more, but haven't been collected, may prevent newer objects to be allocated. Let's say that you implement the kind of binding where the low level memory allocation happens automatically behind the user's back. Users might want to happily write a loop where they process all the files in a directory to load them, perform some tweaking on them, then save them to disk. It could happen that the memory allocated by the &lt;code&gt;Bitmap&lt;/code&gt; objects in one iteration of the loop is not freed immediately. The next iteration allocates more memory, and so on. When you look at such software in a memory debugger you see the memory growing in steps and suddenly drop when the loop finishes and all the temporary objects can be released at the same time.&lt;/p&gt;
&lt;p&gt;Let's twist this a little bit more. In Python it is frequent to cache the result of expensive operations. Maybe you want to load an image, perform some operations and store the final result in a dictionary. If the software has to come back to this image, rather than doing all the operations again, you can retrieve the cached image from the dictionary. Users love this because their interaction is immediate. But how do you make Python and C libraries cooperate? The solution is to delegate memory allocation from both actors into a separate third party. Instead of C or Python calling &lt;code&gt;malloc()&lt;/code&gt; directly, you write a separate memory cache library. This library will perform their &lt;code&gt;malloc()&lt;/code&gt; and &lt;code&gt;free()&lt;/code&gt;. But now when the Python (or C library) code wants to cache something, it can mark a bitmap as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Weak_reference&quot;&gt;weak reference&lt;/a&gt;. These objects go into a separate pool. If a new &lt;code&gt;malloc()&lt;/code&gt; comes in and the OS doesn't have any more free memory, the cache library can look through the pool of weak objects and free one or more of them before giving up.&lt;/p&gt;
&lt;p&gt;One interesting artifact of how memory is shared between languages shows its ugly head to Android programmers when they deal with images. If you take a brief look at &lt;a href=&quot;http://square.github.io/picasso/&quot;&gt;Square's Picasso library&lt;/a&gt; and look at the custom image transformations example, look at the following depressing lines:&lt;/p&gt;
&lt;p&gt;&lt;pre class='code'&gt;&lt;span class=&quot;Identifier&quot;&gt;Bitmap&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;Operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;Bitmap&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;createBitmap&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;Keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;Operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;Punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;Identifier&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;recycle&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;Punctuation&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;Any ideas about what &lt;code&gt;recycle()&lt;/code&gt; does? Depending on the Android version, &lt;a href=&quot;https://developer.android.com/training/displaying-bitmaps/manage-memory.html&quot;&gt;bitmap memory is managed in a different way&lt;/a&gt;, and the call to &lt;code&gt;recycle()&lt;/code&gt; &lt;span style=&quot;font-style: italic;&quot;&gt;helps&lt;/span&gt; to avoid running out of memory because the Java &lt;code&gt;Bitmap&lt;/code&gt; object is separate from it's native memory storage, causing a similar situation to what I described earlier, a Python object preventing a C malloc'ed image from being freed at the appropriate time. The documentation says this is only for older Android versions, but I suspect the implementation of &lt;code&gt;recycle()&lt;/code&gt; is still used in newer ones to signal the OS that most of the backing memory for the Bitmap can be used for something else at that moment. In fact, if it weren't really necessary, wouldn't they &lt;span style=&quot;font-style: italic;&quot;&gt;deprecate&lt;/span&gt; that API? Huh? &lt;span style=&quot;font-style: italic;&quot;&gt;Unneeded&lt;/span&gt; APIs still in use by the most popular image libraries out there… sounds like &lt;a href=&quot;https://en.wikipedia.org/wiki/Cargo_cult_programming&quot;&gt;sane design&lt;/a&gt;. Or maybe not?&lt;/p&gt;
&lt;h2&gt;Running parallelly with scissors&lt;/h2&gt;
&lt;a href=&quot;https://instagram.com/p/sKU6jvyB0J/&quot;&gt;&lt;img
    src=&quot;../../../i/crayon_pop_listens.jpg&quot;
    alt=&quot;Don't want to hurt your feelings&quot;
    style=&quot;width:100%;max-width:320px&quot; align=&quot;right&quot;
    hspace=&quot;8pt&quot; vspace=&quot;8pt&quot;&gt;&lt;/a&gt;&lt;p&gt;This is all a little bit tedious, but doable if all the parties agree on the mechanism to control memory (aka: not gonna happen). How do you extend this among separate processes? In an ideal world we would like to have the user open an image browser. The first time the image browser is loaded all the images in a specific directory are loaded and cached in memory (four rows of five images, each 20 mega pixels in size, or about 80 MB of uncompressed memory, for a total of 1.5GB of RAM required to have them all loaded at once). After browsing some of them, maybe editing them (more memory for undo required!) the user hears a sound and receives a new email. The email prompts to &lt;a href=&quot;https://www.youtube.com/watch?v=YR92tv29pFU&amp;amp;spfreload=10&quot;&gt;watch some youtube video&lt;/a&gt;.  Without closing the photo software the user opens the web browser to see a streaming video equivalent to about 150 or 200 MB file. With the video being in Full HD, each frame takes about 8MB of RAM. Not much, but still some frames might be buffered for smoother playback.&lt;/p&gt;
&lt;p&gt;Even on a machine with just 2GB of RAM this is all doable without problems. But what happens if there are more images on screen? What if the pictures the user is handling have higher resolution? What if we would like the video player to have caching and not have to download or uncompress parts of the stream again if the user clicks a few seconds back on the playback bar to watch again the video? All these &lt;span style=&quot;font-style: italic;&quot;&gt;niceties&lt;/span&gt; increase the memory usage. Programs don't have mechanisms to tell the OS &amp;quot;&lt;span style=&quot;font-style: italic;&quot;&gt;oh well, I want memory for these images, but the user has not accessed to them in a while, so maybe you can purge them if their memory is needed for something else&lt;/span&gt;&amp;quot;.  At the moment the closest thing to this are two mechanisms available in mobile operating systems, which are leading advances in memory sharing due to their low hardware resources compared to desktop machines:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Provide mechanism for the OS to request cache memory from applications.&lt;/li&gt;&lt;li&gt;Make memory handling opaque to the programmer through proxies, so it can be freed and recovered at certain points during execution.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;In the first category there are methods like Android's &lt;a href=&quot;http://developer.android.com/reference/android/app/Application.html#onLowMemory%28%29&quot;&gt;Application.onLowMemory()&lt;/a&gt; which is called when the overall system is running low on memory, and actively running processes have to trim their memory usage. On iOS there are similar methods like &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplicationDelegate_Protocol/index.html#//apple_ref/occ/intfm/UIApplicationDelegate/applicationDidReceiveMemoryWarning:&quot;&gt;applicationDidReceiveMemoryWarning:&lt;/a&gt;. It is worth noting though that methods like &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewController_Class/index.html#//apple_ref/occ/instm/UIViewController/viewDidUnload&quot;&gt;UIViewController.viewDidUnload&lt;/a&gt; have actually been deprecated! I remember watching a WWDC video session where they explained this method was removed because… people weren't using it properly causing more crashes than helping out, and anyway most of the memory was reclaimed through other means (a quick search says this was a &lt;a href=&quot;http://stackoverflow.com/a/12509381/172690&quot;&gt;WWDC 2012 session named Evolution of view controllers&lt;/a&gt;). Interesting, isn't it?&lt;/p&gt;
&lt;p&gt;Actually, that &amp;quot;&lt;span style=&quot;font-style: italic;&quot;&gt;through other means&lt;/span&gt;&amp;quot; leads us to the next next category, which is using proxy elements instead of letting programmer's filthy fingers touch directly any RAM. In both Android and iOS this happens through the classes used to display images. Think about it, most of the time when mobile developers build a user interface they are only &lt;span style=&quot;font-style: italic;&quot;&gt;connecting&lt;/span&gt; resources with objects controlling their appearance on the screen. Meaning, I want the data contain by this specific filename be displayed at this particular position on the screen with these resizing properties and relations to other visual objects.  And for this reason, when one of these mobile applications is interrupted and goes to the background, since the program is &lt;span style=&quot;font-style: italic;&quot;&gt;not really&lt;/span&gt; touching any of the memory, the OS can actually free the memory used by all those user interface bitmaps, and when the app comes back to the foreground it can reload the resources associated with them.&lt;/p&gt;
&lt;p&gt;For generic objects, programmers in Java can use a &lt;a href=&quot;http://developer.android.com/reference/java/lang/ref/WeakReference.html&quot;&gt;WeakReference&lt;/a&gt;. iOS developers can use &lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/NSCache_Class/&quot;&gt;NSCache&lt;/a&gt;. The unfortunate side of these APIs is that nobody uses them. They are somehow awkward to use, and I've come to see zero usages of them in other people's code. I have used them myself only once or twice.&lt;/p&gt;
&lt;p&gt;As for the first category, the idea of memory being released when the OS asks for it is nice until you realise it is all a lie. You see, the OS is allowed to call those methods only when &lt;span style=&quot;font-weight: bold;&quot;&gt;you&lt;/span&gt; are in the foreground. So if you build an app which keeps big data structures (not using those specific cache aware APIs) and the user switches to another one… you are out of luck, the OS won't call those methods again. Why? Well, imagine the performance of your app if when memory is scarce the OS starts running &lt;span style=&quot;font-style: italic;&quot;&gt;other apps' code&lt;/span&gt; in the &lt;span style=&quot;font-style: italic;&quot;&gt;hope&lt;/span&gt; that they can free some memory (and hopefully none of those other apps attempt to run anything that causes &lt;span style=&quot;font-weight: bold;&quot;&gt;more&lt;/span&gt; memory to be allocated, like, maybe be &lt;span style=&quot;font-style: italic;&quot;&gt;evil&lt;/span&gt; and request some network resource while they got some CPU to play with). What you end up realizing is that if you &lt;span style=&quot;font-weight: bold;&quot;&gt;really&lt;/span&gt; want to be a good neighbour to other running apps you have to essentially flush yourself your caches &lt;span style=&quot;font-weight: bold;&quot;&gt;before&lt;/span&gt; being pushed to the background while you are still running, or risk being killed due to an &lt;a href=&quot;http://www.oracle.com/technetwork/articles/servers-storage-dev/oom-killer-1911807.html&quot;&gt;out of memory&lt;/a&gt; situation if the future foreground app tries to allocate memory.  And the number of mobile programmers who do this is… (depressing answer left as an exercise for the reader).&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;a href=&quot;https://instagram.com/p/v8Skk3yB1Z/&quot;&gt;&lt;img
    src=&quot;../../../i/crayon_pop_christmas.jpg&quot;
    alt=&quot;Gangsta sharing&quot;
    style=&quot;width:100%;max-width:320px&quot; align=&quot;right&quot;
    hspace=&quot;8pt&quot; vspace=&quot;8pt&quot;&gt;&lt;/a&gt;&lt;p&gt;While a lot has been written about memory allocation and fragmentation prevention techniques (like &lt;a href=&quot;https://en.wikipedia.org/wiki/Region-based_memory_management&quot;&gt;regions&lt;/a&gt;, quite popular in video games for level loading), the problems of sharing memory between different processes, or sharing memory between different languages running in the same process are rarely talked about because they fall out of the domain of a single stakeholder. Memory fragmentation is easier to deal with because it is &lt;span style=&quot;font-style: italic;&quot;&gt;yours&lt;/span&gt;. Memory sharing with other processes? Meh, it's &lt;span style=&quot;font-style: italic;&quot;&gt;their&lt;/span&gt; fault. Don't expect any improvements in this area in your lifetime, at least until programming languages don't incorporate memory sharing primitives in their languages (or make memory sharing proxies transparent, which is the most realistic solution as proved by mobile platforms).&lt;/p&gt;
&lt;p&gt;And now, get back to your &lt;code&gt;malloc()&lt;/code&gt; and &lt;code&gt;free()&lt;/code&gt;!&lt;/p&gt;

&lt;br clear=&quot;right&quot;&gt;
      </content>
    </entry>
    <entry>
      <title>Whitespace goto fail</title>
      <link rel="alternate" type="text/html" href="http://gradha.github.io/articles/2015/04/whitespace-goto-fail.html"/>
      <id>http://gradha.github.io/articles/2015/04/whitespace-goto-fail.html</id>
      <published>2015-04-17T23:37:00Z</published>
      <updated>2015-04-17T23:37:00Z</updated>
      <author><name>Grzegorz Adam Hankiewicz</name></author>
      <content type="html">
        &lt;h1&gt;Whitespace goto fail&lt;/h1&gt;&lt;p&gt;Recently I fixed the following interesting code in an Android application I wrote. According to source control it had &lt;span style=&quot;font-style: italic;&quot;&gt;survived&lt;/span&gt; undetected for about eight months until it manifested as a runtime crash:&lt;/p&gt;
&lt;p&gt;&lt;pre class='code'&gt;&lt;span class=&quot;Identifier&quot;&gt;…&lt;/span&gt;
&lt;span class=&quot;Keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;Operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;Punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;Keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;Operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;Keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;Operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;Keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;Operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;Keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;Identifier&quot;&gt;set_sparta_kook&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;Identifier&quot;&gt;visible_web&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;loadUrl&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;Punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;Keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;Punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;Identifier&quot;&gt;visible_web&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;restoreState&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;Identifier&quot;&gt;…&lt;/span&gt;
&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;The culprit of the bug was of course the &lt;span style=&quot;font-weight: bold;&quot;&gt;addition&lt;/span&gt; of the &lt;a href=&quot;https://www.google.es/search?q=sparta+kook&amp;amp;tbm=isch&quot;&gt;set_sparta_kook()&lt;/a&gt; call to the previously existing lines of perfectly working code. Can you see now what the problem was? Yes, lack of beloved braces. Here's the fixed code:&lt;/p&gt;
&lt;p&gt;&lt;pre class='code'&gt;&lt;span class=&quot;Identifier&quot;&gt;…&lt;/span&gt;
&lt;span class=&quot;Keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;Operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;Punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;Keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;Operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;Keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;Operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;Keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;Operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;Keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;Punctuation&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;Identifier&quot;&gt;set_sparta_kook&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;Identifier&quot;&gt;visible_web&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;loadUrl&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;Punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;Punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;Keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;Punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;Identifier&quot;&gt;visible_web&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;restoreState&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;Identifier&quot;&gt;…&lt;/span&gt;
&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;Welcome to a variant of &lt;a href=&quot;http://arstechnica.com/security/2014/02/extremely-critical-crypto-flaw-in-ios-may-also-affect-fully-patched-macs/&quot;&gt;goto fail&lt;/a&gt;. It's not the first time I've written such bugs, but they don't come often. I don't think I've made more than five in my whole life. Still, far too many for my taste.&lt;/p&gt;
&lt;p&gt;What was particularly interesting is not how I could write this (distractions or tiredness can explain pretty much everything) but how I &lt;span style=&quot;font-weight: bold;&quot;&gt;could not fix&lt;/span&gt; this immediately despite reviewing it carefully. Let me explain: it took me several minutes of looking at the source code, actually not figuring out what was happening and then using a debugger to step through the lines and think &amp;quot;&lt;span style=&quot;font-style: italic;&quot;&gt;wait a second, why is the program execution running through&lt;/span&gt; &lt;code&gt;visible_web().loadUrl(this.item.url);&lt;/code&gt; &lt;span style=&quot;font-style: italic;&quot;&gt;in first place when the condition should be preventing that?&lt;/span&gt;&amp;quot;.&lt;/p&gt;
&lt;p&gt;I'm so used by now to reading properly indented code that no matter how many times I looked at this code I would not catch the missing braces. The typical &lt;span style=&quot;font-style: italic;&quot;&gt;patch&lt;/span&gt; to such problems is of course a coding convention. You can see this reflected as one of the promoted comments in &lt;a href=&quot;http://arstechnica.com/security/2014/02/extremely-critical-crypto-flaw-in-ios-may-also-affect-fully-patched-macs/&quot;&gt;the article I linked to&lt;/a&gt; earlier:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;a_v_s&lt;/span&gt; Ars Scholae Palatinae&lt;/p&gt;
&lt;p&gt;This is one of the reasons I always use {} even with single statement conditionals.&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;True. But you know what else could have prevented this bug without requiring a horrendous coding convention difficult to validate/enforce? Having a language which doesn't use braces and instead uses whitespace indentation like &lt;a href=&quot;http://eerolanguage.org&quot;&gt;Eero&lt;/a&gt; or &lt;a href=&quot;http://nim-lang.org&quot;&gt;Nim&lt;/a&gt; do.&lt;/p&gt;

&lt;center&gt;
&lt;a href=&quot;http://dijkcrayon.tistory.com/363&quot;&gt;&lt;img
    src=&quot;../../../i/whitespace_reactions.jpg&quot;
    alt=&quot;At first I was like…&quot;
    style=&quot;width:100%;max-width:750px&quot; align=&quot;center&quot;
    hspace=&quot;8pt&quot; vspace=&quot;8pt&quot;&gt;&lt;/a&gt;
&lt;/center&gt;&lt;h2&gt;Syntax anachronisms&lt;/h2&gt;&lt;p&gt;Braces, or just about any other start/end block delimiter, are an anachronism and only add clutter and useless bike shedding. The key to understanding this is how I wasn't able to understand the actual meaning of the code which is pretty obvious to the compiler. After years developing, braces (or whatever you have in most of the programming languages designed without taste) are simply noise.  They don't add any value to the source code. They are just a tedious necessity for the compiler, because frankly, humans &lt;span style=&quot;font-weight: bold;&quot;&gt;won't use them&lt;/span&gt;. If you remember the first time you drove a car vs how you drive it several years later the difference is the same: the first time you pay attention to everything. Not only everything is new (oh, a vertical sign! Hi!) but you actually paid extreme attention because a mistake could lead to a terrible error. Years later you can concentrate only on the important things and don't freak out at every little detail you can see behind the driving wheel.&lt;/p&gt;
&lt;p&gt;Unfortunately most people defending programming languages with braces don't get it and instead provide lame arguments. My favourite lame contra argument is that you can't easily copy/paste code between windows, web browsers, or Notepad, I guess, because the indentation will be messed up. It highly amuses me how often this argument comes up in religious battles because the people backing it must be using programming tools from the past, where automatic indentation is such an impossible technical feat. Or maybe programmers able to &lt;span style=&quot;font-weight: bold;&quot;&gt;only&lt;/span&gt; copy/paste code really need these crutches, since they will leave the source code in a state which compiles but is unreadable to anybody who is not a compiler.&lt;/p&gt;
&lt;p&gt;This argument also forgets another simple fact: it's highly unlikely that copying and pasting code somewhere else won't require changes &lt;span style=&quot;font-weight: bold;&quot;&gt;anyway&lt;/span&gt;. Maybe you will need to change variable names, or remove some lines you don't need. Or if you actually care about source code, you &lt;span style=&quot;font-weight: bold;&quot;&gt;will&lt;/span&gt; indent the code to &lt;span style=&quot;font-weight: bold;&quot;&gt;your&lt;/span&gt; coding convention, modify the symbols to be CamelCase or snake_case, change private/instance variables to have a different prefix (&lt;code&gt;m&lt;/code&gt;, &lt;code&gt;_&lt;/code&gt;, &lt;code&gt;m_&lt;/code&gt;, &lt;code&gt;F&lt;/code&gt;, …), etc. Whatever lines of code go into any of my source files, even those which come from my own projects, have to pass an initial visual style inspection. And in the inspection I performed I simply forgot about the braces. Why? Because they are useless to human eyes, completely discard able.&lt;/p&gt;
&lt;p&gt;You could really hear my facepalm in the whole building when I read on a forum discussion that somebody preferred programming languages with braces because their blog system screws up formatting for literal blocks. Seriously, if you come up with such quality arguments you should be neutered to prevent lowering humanity's intelligence average with your offspring (and the developers of your blog tools too).&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;&lt;p&gt;Language designers should know better that adding braces for code blocks that are going to be indented anyway due to code conventions is detrimental because they distract programmers with a needless task, but we can still see new languages enforcing braces (like &lt;a href=&quot;http://kotlinlang.org&quot;&gt;Kotlin&lt;/a&gt; or &lt;a href=&quot;https://developer.apple.com/swift/&quot;&gt;Swift&lt;/a&gt;). I suspect the real reason why these new languages keep them is to appease the hordes of users of the language they try to replace. It is such a shame we have so much trouble accepting change, even when it is for the better.&lt;/p&gt;
&lt;p&gt;Remember, the argument for &lt;span style=&quot;font-style: italic;&quot;&gt;having&lt;/span&gt; braces is that you are &lt;a href=&quot;https://www.youtube.com/watch?v=Yy3dIicSI_0&quot;&gt;such a horrible person&lt;/a&gt; that you will never indent or care about the style of your code and therefore prefer to have a crutch that frees you from having taste, and lets you dump foreign code into your own to leave it however it falls.&lt;/p&gt;

&lt;center&gt;
&lt;a href=&quot;http://xkcd.com/1513/&quot;&gt;&lt;img
    src=&quot;../../../i/xkcd_code_quality.png&quot;
    alt=&quot;At first I was like…&quot;
    style=&quot;width:100%;max-width:740px&quot; align=&quot;center&quot;
    hspace=&quot;8pt&quot; vspace=&quot;8pt&quot;&gt;&lt;/a&gt;
&lt;/center&gt;
      </content>
    </entry>
    <entry>
      <title>Goodbye Nim, and good luck</title>
      <link rel="alternate" type="text/html" href="http://gradha.github.io/articles/2015/02/goodbye-nim-and-good-luck.html"/>
      <id>http://gradha.github.io/articles/2015/02/goodbye-nim-and-good-luck.html</id>
      <published>2015-02-04T22:23:00Z</published>
      <updated>2015-04-23T21:49:00Z</updated>
      <author><name>Grzegorz Adam Hankiewicz</name></author>
      <content type="html">
        &lt;h1&gt;Goodbye Nim, and good luck&lt;/h1&gt;&lt;p&gt;In 2012 I learned about the Nimrod programming language, now renamed to &lt;a href=&quot;http://nim-lang.org&quot;&gt;Nim&lt;/a&gt;. I found Nim because I was looking for higher level programming languages which would compile to C, so I could use the generated code everywhere. Like Java. And I enjoyed learning it.&lt;/p&gt;
&lt;p&gt;I did spend a big chunk of time exploring the possibilities of applying Nim to my day job, which is writing mobile apps. I wrote first &lt;a href=&quot;https://github.com/gradha/seohtracker-ios&quot;&gt;Seohtracker for iOS&lt;/a&gt; and later &lt;a href=&quot;https://github.com/gradha/seohtracker-mac&quot;&gt;Seohtracker for OSX&lt;/a&gt; as proof of code reuse. Unfortunately I started to &lt;a href=&quot;http://gradha.github.io/articles/2015/02/../../2014/03/nimrod-for-cross-platform-software.html&quot;&gt;find troubles&lt;/a&gt; with the language implementation. I also slowly realized that no matter how fantastic the language implementation could be, Nim is designed to use soft realtime GC on thread local heaps. This means that a thread cannot touch the memory of another thread. If you add to this the necessary level of indirection of calling Nim from a different programming language (or vice versa), the amount of barriers to jump over to do what in other &lt;span style=&quot;font-weight: bold;&quot;&gt;unsafe&lt;/span&gt; languages is just accessing a variable starts to pile up.&lt;/p&gt;
&lt;p&gt;At that point that I realized that from all the amount of software written in Nim there were two kinds of software barely explored: GUIs and multithreading. It's not difficult to &lt;a href=&quot;http://forum.nim-lang.org&quot;&gt;read in the Nim forums&lt;/a&gt; how people are using one or the other, either using GTK for things like &lt;a href=&quot;https://github.com/nim-lang/Aporia&quot;&gt;Aporia&lt;/a&gt; or creating &lt;a href=&quot;http://forum.nim-lang.org/t/167&quot;&gt;raytracers which scale up in performance&lt;/a&gt;. But they are mostly single threaded with one or two callbacks here, or they don't share any state. It's the intersection of both which is lacking. And this intersection seems to require you to ignore all type and memory safety to make your own globals or shared memory for communicating. I'd love to be proved wrong, but all the questions I've found from other programmers attempting to do this are met with vague &lt;span style=&quot;font-style: italic;&quot;&gt;maybe&lt;/span&gt; answers or suggestions which read more like workarounds for an invisible elephant.&lt;/p&gt;
&lt;p&gt;People are finding the GC is not really wanted for certain scenarios, and are starting to wish for at least a minimal standard library which uses manual memory handling so that Nim can be used without that wonderful GC. Would this kind of project repeat history like D's Phobos vs Tango but with an even smaller community? I've toyed with this idea too, but there is no point in pushing something towards something it will never be. Of course I'll keep using Nim as I'm using now, to replace most of my toy Python code. But I can't see myself using Nim for anything work related in the future when so many alternatives are already delivering for mobile (&lt;a href=&quot;http://xamarin.com/platform&quot;&gt;Xamarin&lt;/a&gt; for C#, &lt;a href=&quot;http://elementscompiler.com/elements/silver/&quot;&gt;Silver&lt;/a&gt; for Swift, &lt;a href=&quot;http://robovm.com&quot;&gt;RoboVM&lt;/a&gt; for Java, and plenty of interpreted/script languages too).&lt;/p&gt;
&lt;p&gt;Since I started this blog with the purpose of writing articles about Nim and taking potshots at other programming languages from the safety of a random troll, I don't think I'll write anything more here. All the nim software I've created also has an expiration date: Nim 1.0. I've already spent the last weeks cleaning and upgrading the code I had working with 0.9.6 to work with 0.10.2, but there are still many deprecated warnings left which will make it again impossible to compile with 1.0, whenever it happens.&lt;/p&gt;
&lt;p&gt;At least I'll leave those repositories up in case somebody wants to pick them up. Good luck, Nim programmers. I'll keep watching from a distance. &lt;/p&gt;

      </content>
    </entry>
    <entry>
      <title>Writing C libraries with Nim</title>
      <link rel="alternate" type="text/html" href="http://gradha.github.io/articles/2015/01/writing-c-libraries-with-nim.html"/>
      <id>http://gradha.github.io/articles/2015/01/writing-c-libraries-with-nim.html</id>
      <published>2015-01-14T22:59:00Z</published>
      <updated>2015-08-02T15:01:00Z</updated>
      <author><name>Grzegorz Adam Hankiewicz</name></author>
      <content type="html">
        &lt;h1&gt;Writing C libraries with Nim&lt;/h1&gt;&lt;h2&gt;Context&lt;/h2&gt;&lt;p&gt;When you look at &lt;a href=&quot;http://stackoverflow.com/questions/2746692/restructuredtext-tool-support&quot;&gt;reStructuredText tool support&lt;/a&gt; you can notice that with the main reference implementation being written in Python, all other implementations are in languages &lt;span style=&quot;font-style: italic;&quot;&gt;equal&lt;/span&gt; or greater than Python: Java, Scala, Haskell, Perl, PHP, Nim. All these languages have in common that the programmer doesn't have to manage memory manually, and given the complexity of reStructuredText that doesn't seem to be a coincidence. This may have slowed down adoption of reStructuredText compared to &lt;a href=&quot;http://daringfireball.net/projects/markdown/&quot;&gt;Markdown&lt;/a&gt;. Markdown started as a Perl script, but its simplicity led to &lt;a href=&quot;https://github.com/hoedown/hoedown&quot;&gt;many C libraries&lt;/a&gt;, and even a &lt;a href=&quot;http://commonmark.org&quot;&gt;standarization attempt&lt;/a&gt;, not without &lt;a href=&quot;http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/&quot;&gt;typical drama&lt;/a&gt;. Wouldn't it be nice to have a C library for reStructuredText?&lt;/p&gt;
&lt;p&gt;Since I dislike Python due to its brittleness and slow speed, I didn't want to use a Python solution for an &lt;a href=&quot;https://en.wikipedia.org/wiki/Quick_Look&quot;&gt;OS X Quick Look plugin&lt;/a&gt;. I wrote &lt;a href=&quot;https://github.com/gradha/quicklook-rest-with-nim&quot;&gt;quicklook-rest-with-nim&lt;/a&gt; which just takes the work done by the Nim developers in the &lt;a href=&quot;https://github.com/Araq/Nim/blob/80b83611875383760da40d626a516e794e1245e7/lib/packages/docutils/rst.nim&quot;&gt;rst&lt;/a&gt;, &lt;a href=&quot;http://nim-lang.org/docs/rstast.html&quot;&gt;rstast&lt;/a&gt; and &lt;a href=&quot;http://nim-lang.org/docs/rstgen.html&quot;&gt;rstgen&lt;/a&gt; modules and packages it as a Quick Look renderer. Everything is statically linked, you can copy the plugin to any machine and it should run without any other runtime dependencies (note: &lt;a href=&quot;https://github.com/gradha/quicklook-rest-with-nim/issues/48&quot;&gt;some unknown bug&lt;/a&gt; prevents it from working on Yosemite when installed in a home directory, but works fine form a system folder).&lt;/p&gt;
&lt;p&gt;The Quick Look renderer is implemented using the default Objective-C Xcode template modifying it to call the Nim code through C bindings. That's when I realised the Nim implementation could be distributed as a plain C library for other languages to use, to avoid their pain rewriting the wheel or running shell commands. For the Quick Look plugin I was simply using two entry points exported to C with hard coded values, not acceptable to other people. I started then to move the custom Nim code to a separate module named &lt;a href=&quot;https://github.com/gradha/lazy_rest&quot;&gt;lazy_rest&lt;/a&gt;.  Exposing directly the Nim API didn't make sense for several reasons, so first I &lt;a href=&quot;http://gradha.github.io/lazy_rest/gh_docs/v0.2.2/lazy_rest.html&quot;&gt;implemented a slightly different Nim API&lt;/a&gt; which I think is nicer than the original, then proceeded to wrap it in a separate &lt;a href=&quot;http://gradha.github.io/lazy_rest/gh_docs/v0.2.2/lazy_rest_c_api.html&quot;&gt;C API module&lt;/a&gt; which is really another Nim file wrapping all of its procs with the &lt;a href=&quot;http://nim-lang.org/docs/manual.html#foreign-function-interface-exportc-pragma&quot;&gt;exportc pragma&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The project was successful, when I &lt;a href=&quot;https://github.com/gradha/quicklook-rest-with-nim/issues/42&quot;&gt;replaced the old rester module&lt;/a&gt; with &lt;code&gt;lazy_rest&lt;/code&gt; I dropped several brittle shell scripts and external nim compiler invocations from the project and simply dragged the C files into the Xcode project. This was pleasantly easy. The refactoring of the original reStructuredText modules into &lt;a href=&quot;https://github.com/gradha/lazy_rest&quot;&gt;lazy_rest&lt;/a&gt; wasn't that easy though, I did hit some problems or annoyances. This post is going to enumerate the issues I found, in case you would like to make some other Nim module available to C users.&lt;/p&gt;
&lt;h2&gt;Namespaces and identifiers&lt;/h2&gt;&lt;p&gt;Nim compiles to C, but most of the identifiers will have mangled C names you usually don't care about.  Looking at the code found in the &lt;code&gt;nimcache&lt;/code&gt; directory you can get an idea of the mangling pattern (which is in any case not part of the public API and subject to change with each Nim version):&lt;/p&gt;
&lt;p&gt;&lt;pre class='code'&gt;&lt;span class=&quot;Identifier&quot;&gt;…&lt;/span&gt;
&lt;span class=&quot;Identifier&quot;&gt;N_NIMCALL&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;NimStringDesc&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;saferststringtohtml_235288&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;…&lt;/span&gt;
&lt;span class=&quot;Identifier&quot;&gt;N_NIMCALL&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;NimStringDesc&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;saferstfiletohtml_235656&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;…&lt;/span&gt;
&lt;span class=&quot;Identifier&quot;&gt;N_NIMCALL&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;NimStringDesc&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;sourcestringtohtml_235723&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;…&lt;/span&gt;
&lt;span class=&quot;Identifier&quot;&gt;…&lt;/span&gt;
&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;The mangling is done to avoid having linker errors due to two symbols being named the same. Especially necessary for Nim where you can overload procs or have two procs named the same living in separate modules. When you use the &lt;a href=&quot;http://nim-lang.org/docs/manual.html#foreign-function-interface-exportc-pragma&quot;&gt;exportc pragma&lt;/a&gt; the compiler won't mangle the name, so you have to pick a good unique one. The API of &lt;code&gt;lazy_rest&lt;/code&gt; is really small, but still I decided to use the typical Objective-C pattern of prefixing all symbols with two letters.&lt;/p&gt;
&lt;h2&gt;Memory handling&lt;/h2&gt;&lt;p&gt;Memory handling was obviously going to be a problem. C is managed manually, Nim has a garbage collector. Language bindings for any programming language always have these issues when the memory management is different, especially since the languages communicating are usually not aware of each other. Memory passed in from C to Nim is just a &lt;a href=&quot;http://nim-lang.org/docs/manual.html#types-cstring-type&quot;&gt;cstring&lt;/a&gt;, that's fine because it can be converted to a Nim &lt;code&gt;string&lt;/code&gt;. However, what do we do with a Nim proc which returns a &lt;code&gt;string&lt;/code&gt; to C? Strings in Nim are implicitly convertible to &lt;code&gt;cstring&lt;/code&gt; for convenience of C bindings, but what happens to their memory? Who handles that?&lt;/p&gt;

&lt;center&gt;
&lt;a href=&quot;http://arcturus127.tistory.com/831&quot;&gt;&lt;img
    src=&quot;../../../i/memory_handling.jpg&quot; alt=&quot;Stuff is hard&quot;
    style=&quot;width:100%;max-width:750px&quot; align=&quot;center&quot;
    hspace=&quot;8pt&quot; vspace=&quot;8pt&quot;&gt;&lt;/a&gt;
&lt;/center&gt;&lt;p&gt;The manual mentions the built in procs &lt;a href=&quot;http://nim-lang.org/docs/system.html#GC_ref&quot;&gt;GC_ref()&lt;/a&gt; and &lt;a href=&quot;http://nim-lang.org/docs/system.html#GC_unref&quot;&gt;GC_unref()&lt;/a&gt; can be used to keep the string data alive. That means that the C code calling this API would have to know about freeing the memory too. Instead I decided to store the result in a global variable. This forces the string to not be freed even when calling other Nim code which could trigger a garbage collection, and it is easier on the C programmer for the common use of one shot reStructuredText transformations. Improvements can be reviewed in the future whenever &lt;code&gt;lazy_rest&lt;/code&gt; gains a user base greater than one (me).&lt;/p&gt;
&lt;p&gt;One thing worth mentioning here too is that conversions between &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;cstring&lt;/code&gt; are &lt;a href=&quot;https://github.com/Araq/Nim/issues/1577&quot;&gt;not always correct&lt;/a&gt;. A &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;string&lt;/code&gt; won't convert to a &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;cstring&lt;/code&gt;. One way to deal with this is &lt;a href=&quot;https://github.com/gradha/badger_bits/blob/5dcc623d1fd5b8232a133370e068b1e3928f56bc/bb_system.nim#L135&quot;&gt;wrapping the string to cstring conversion&lt;/a&gt; to check explicitly for &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Exporting types from the Nim standard library&lt;/h2&gt;&lt;p&gt;Part of the configuration/input options of &lt;code&gt;lazy_rest&lt;/code&gt; are passed in through a &lt;a href=&quot;http://nim-lang.org/docs/strtabs.html&quot;&gt;StringTableRef&lt;/a&gt;. These type was named &lt;code&gt;PStringTable&lt;/code&gt; in Nimrod 0.9.6, and unfortunately &lt;a href=&quot;https://github.com/Araq/Nim/issues/1579&quot;&gt;it is not possible to export such symbols&lt;/a&gt;.  The typical usage of this type is to store configuration options from a file or memory string, so instead I provided &lt;a href=&quot;http://gradha.github.io/lazy_rest/gh_docs/v0.2.2/lazy_rest_c_api.html#lr_set_global_rst_options&quot;&gt;lr_set_global_rst_options()&lt;/a&gt;. C users can create an in memory string with the necessary configuration options and let the Nim code parse that.  Not very optimal, but this is not performance critical. Typically you will call this once before any other reStructuredText generation.&lt;/p&gt;
&lt;p&gt;Something which could be a deal breaker for some people writing C libraries is the fact that &lt;a href=&quot;https://github.com/Araq/Nim/issues/1189&quot;&gt;Nim doesn't export type fields&lt;/a&gt;. To work around this limitation you can export setters and getters. If your fields are primitive types this involves an extra function call, which doesn't look very appealing. For Nim types like strings you would have to implement the setters and getters anyway. The &lt;code&gt;lazy_rest&lt;/code&gt; API I export is mostly an opaque render-and-forget approach to the many internal types used for parsing and rendering, so it wasn't a problem.&lt;/p&gt;
&lt;h2&gt;Export enums and constants&lt;/h2&gt;&lt;p&gt;The Nim language doesn't allow &lt;a href=&quot;https://github.com/Araq/Nim/issues/826&quot;&gt;exporting enums or consts to C&lt;/a&gt;. This is quite a bummer. For &lt;code&gt;lazy_rest&lt;/code&gt; I did add the &lt;a href=&quot;http://gradha.github.io/lazy_rest/gh_docs/v0.2.2/lazy_rest_pkg/lconfig.html&quot;&gt;lconfig module&lt;/a&gt; which contains several constants mapping to strings used for &lt;code&gt;StringTableRef&lt;/code&gt; configuration objects. C users have to look at the documentation and duplicate their own hard coded strings.&lt;/p&gt;
&lt;p&gt;I suggested at some point &lt;a href=&quot;https://github.com/Araq/Nim/issues/905&quot;&gt;adding an emit header pragma&lt;/a&gt;. This pragma would work in a similar way to the &lt;a href=&quot;http://nim-lang.org/docs/nimc.html#additional-features-emit-pragma&quot;&gt;emit pragma&lt;/a&gt; but instead of generating C code it would allow you to add lines to the final header generated by the Nim compiler. With such pragma I could write a macro to wrap all those constants and let them pass through to the compiler while at the same time generating extra header lines.&lt;/p&gt;
&lt;p&gt;Recently Nim 0.10.2 was released and it also provides a way to write to a file from a macro. Macros happen at compile time, likely before any C header is generated, but I think a band aid for this issue could be to generate manually an additional C header in memory and write it to the &lt;code&gt;nimcache&lt;/code&gt; directory. Maybe in the future I'll try this.&lt;/p&gt;
&lt;h2&gt;Errors and exception handling&lt;/h2&gt;
&lt;a href=&quot;http://www.idol-grapher.com/1399&quot;&gt;&lt;img
    src=&quot;../../../i/nimc_exceptions.jpg&quot;
    alt=&quot;Plus there is no API&quot;
    style=&quot;width:100%;max-width:600px&quot; align=&quot;right&quot;
    hspace=&quot;8pt&quot; vspace=&quot;8pt&quot;&gt;&lt;/a&gt;&lt;p&gt;Exceptions are something else C doesn't have. Nim procs like &lt;a href=&quot;http://gradha.github.io/lazy_rest/gh_docs/v0.2.2/lazy_rest.html#rst_string_to_html&quot;&gt;rst_string_to_html()&lt;/a&gt; will throw exceptions on error, so how does the C binding deal with that? The C API module uses &lt;a href=&quot;http://nim-lang.org/docs/manual.html#effect-system&quot;&gt;Nim's effect system&lt;/a&gt; for exception tracking. All the procs are annotated with the &lt;code&gt;{.raises: [].}&lt;/code&gt; pragma. This pragma tells the compiler that no exception should be raised out of the proc, if there is any potentially being raised the code won't compile, and you have to add the appropriate &lt;code&gt;try/except&lt;/code&gt; combo somewhere to appease the compiler.&lt;/p&gt;
&lt;p&gt;Annotating procs with this pragma was very satisfying because after doing so you realise how much stuff could potentially break. In other languages you are left with the uncertainty that something could break and you have no catch for it, which leads to typical &lt;span style=&quot;font-style: italic;&quot;&gt;catch-all&lt;/span&gt; blocks in several points of the code, whether they are necessary or not. In Nim by default this could happen too, but the empty &lt;code&gt;raises&lt;/code&gt; pragma helps you go through each possible error.&lt;/p&gt;
&lt;p&gt;Thanks to this pragma I am confident there won't be any exception leaving the Nim domain. Such exceptions are treated for the C API as functions returning &lt;code&gt;NULL&lt;/code&gt; instead of the expected value.  The errors are again stored in another Nim global variable, and you can retrieve them with helper functions ending in &lt;code&gt;_error&lt;/code&gt; like &lt;a href=&quot;http://gradha.github.io/lazy_rest/gh_docs/v0.2.2/lazy_rest_c_api.html#lr_rst_string_to_html_error&quot;&gt;lr_rst_string_to_html_error()&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Callback exception tracking&lt;/h2&gt;&lt;p&gt;Things get trickier with exception tracking when you involve callbacks. The reStructuredText parser does have a callback to report warnings and errors to the user. This callback can just &lt;code&gt;echo&lt;/code&gt; information to the user, but it can also raise an exception, aborting parsing. So you have a proc which uses a callback, and the proc itself has been protected with all sort of &lt;code&gt;try/except&lt;/code&gt; blocks to keep the callback from causing trouble. The Nim compiler however disagrees, see this little snippet of code extracted from &lt;a href=&quot;https://github.com/Araq/Nim/issues/1631&quot;&gt;an issue I created&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;pre class='code'&gt;&lt;span class=&quot;Keyword&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;noRaise&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;Keyword&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;Punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;raises&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;Punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;Operator&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;Keyword&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;Keyword&quot;&gt;except&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;Keyword&quot;&gt;discard&lt;/span&gt;

&lt;span class=&quot;Keyword&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;callbackWichRaisesHell&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;Punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;raises&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;Punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;EIO&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;Operator&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;Keyword&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;newException&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;EIO&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;StringLit&quot;&gt;&amp;quot;IO&amp;quot;&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;Keyword&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;Punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;raises&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;Punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;Operator&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;Comment&quot;&gt;# doesn't compile even though nothing can be raised!&lt;/span&gt;
  &lt;span class=&quot;Identifier&quot;&gt;noRaise&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;callbackWichRaisesHell&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt; This code looks and reads perfectly fine to me. Despite passing &lt;code&gt;callbackWichRaisesHell&lt;/code&gt; around, the &lt;code&gt;noRaise()&lt;/code&gt; proc won't ever raise anything, but the example won't compile.  It will compile if you add a wrapper layer around the callback, as Araq suggests in the GitHub issue, or if you remove the empty &lt;code&gt;raises&lt;/code&gt; pragma from the &lt;code&gt;use()&lt;/code&gt; declaration (but that was the point of using the pragma). The reported issue was closed, meaning it's OK to have to patch correct code. I don't know yet if patching good code being the correct answer to a problem is more sad than having a compiler unable to reason about a ten line program.&lt;/p&gt;
&lt;p&gt;In any case this wasn't a problem for the library, since I wanted the callbacks to be usable from C there wasn't any point in making them raise exceptions (how would you raise a Nim exception from C code?). I simply modified the &lt;a href=&quot;http://gradha.github.io/lazy_rest/gh_docs/v0.2.2/lazy_rest_pkg/lrst.html#TMsgHandler&quot;&gt;TMsgHandler&lt;/a&gt; callback type to raise nothing and instead return the possible error as a non nil string. This avoided the problem of callbacks raising any exceptions.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=RztfjHdM-pg&quot;&gt;Pig and elephant DNA just won't splice&lt;/a&gt;, so know also that callbacks and exception tracking have issues together.&lt;/p&gt;

&lt;br clear=&quot;right&quot;&gt;&lt;h2&gt;Threads&lt;/h2&gt;
&lt;a href=&quot;http://dijkcrayon.tistory.com/297&quot;&gt;&lt;img
    src=&quot;../../../i/nimc_threads.jpg&quot; alt=&quot;Threads are terrible&quot;
    style=&quot;width:100%;max-width:600px&quot; align=&quot;right&quot;
    hspace=&quot;8pt&quot; vspace=&quot;8pt&quot;&gt;&lt;/a&gt;&lt;p&gt;Parsing and generating HTML from text is pretty much sequential, you can't start generating HTML for a random part of the document because the previous part could modify its meaning. But we have multi processor machines everywhere, so I thought it would be nice to provide a queue like API where you pass all the files or strings you need to process (e.g. results of scanning the file system) and let the multiple processors do their job, returning all the results.&lt;/p&gt;
&lt;p&gt;I started the &lt;a href=&quot;https://github.com/gradha/lazy_rest/blob/50738869005675b99b039516e8a6031ddf151972/lazy_rest_pkg/lqueues.nim&quot;&gt;lqueues module&lt;/a&gt; but couldn't get much done so I've left it disabled. I've done threading in C, Java, Objective-C, and after the initial problems grasping deadlocks and race conditions, nowadays I seem to be able to write at least non crashing code. But I couldn't get Nim to do the same. My biggest gripe was with the fact that threads can't touch other thread's variables, so they have to communicate through shared globals. Or use channels/actors which presumably are not the right solution (couldn't get the expected performance gains from them, but at least they didn't crash).&lt;/p&gt;
&lt;p&gt;Now that Nim 0.10.2 has been released there is hope in the new &lt;a href=&quot;http://nim-lang.org/docs/manual.html#parallel-spawn&quot;&gt;parallel and spawn statements&lt;/a&gt;, so I should try that soon. Still, I don't understand what's the presumable benefit of having threads unable to mutate state from other threads. To me it seems more like it's easier to implement concurrency with immutable state, but then, all the other languages I've worked with have mutability and they work perfectly fine.&lt;/p&gt;
&lt;p&gt;I don't think it's coincidence that there is pretty much zero Nim threaded code out there being written outside of a few very specific cases. Again, not something I'm worried now, but raises some questions for future work. At the moment I can't see myself using Nim for GUI programming because all the asynchronous patterns I know work with explicit mutability in mind. Neither the new &lt;code&gt;parallel&lt;/code&gt; and &lt;code&gt;spawn&lt;/code&gt; statements nor &lt;code&gt;async&lt;/code&gt; seem to be oriented for GUI programming where you require callbacks for progress indication (and this has to happen on the main thread, aka GUI thread) or cancellation.  Time to learn new tricks I guess, maybe Nim is just so superior in this area I'm unable to see the benefits yet. &amp;lt;insert needs-enlightment-here&amp;gt;&lt;/p&gt;

&lt;br clear=&quot;right&quot;&gt;&lt;h2&gt;Conclusion&lt;/h2&gt;&lt;p&gt;From the point of view of C library consumers, this project mostly works and is viable. Users can go to the &lt;a href=&quot;https://github.com/gradha/lazy_rest/releases&quot;&gt;lazy_rest releases section&lt;/a&gt;, download the pre generated C sources packages and use without having to install or even know about Nim. For generic C API libraries only the exportation of enums, constants and type fields seems to be a glaring problem because mostly everybody will hit it. Fortunately it doesn't seem to be hard to fix. As more Nim users try to export their Nim code with a C API there will be more interest in fixing or improving these issues.  And maybe in the not so distant future it will make sense to use Nim as a perfect replacement for C when you want to write reusable libraries for C users, or other languages using C bindings.&lt;/p&gt;
&lt;pre class='literal'&gt;$ nim c -r complex_callbacks.nim
complex_callbacks.nim(9, 21) Info: instantiation from here
complex_callbacks.nim(6, 41) Error: can raise an unlisted exception: IOError&lt;/pre&gt;
      </content>
    </entry>
    <entry>
      <title>The day Go reinvented macros</title>
      <link rel="alternate" type="text/html" href="http://gradha.github.io/articles/2015/01/the-day-go-reinvented-macros.html"/>
      <id>http://gradha.github.io/articles/2015/01/the-day-go-reinvented-macros.html</id>
      <published>2015-01-07T22:59:00Z</published>
      <updated>2015-08-02T15:01:00Z</updated>
      <author><name>Grzegorz Adam Hankiewicz</name></author>
      <content type="html">
        &lt;h1&gt;The day Go reinvented macros&lt;/h1&gt;&lt;h2&gt;Context&lt;/h2&gt;&lt;p&gt;One of the big selling points of the &lt;a href=&quot;http://nim-lang.org&quot;&gt;Nim programming language&lt;/a&gt; is that it has &lt;a href=&quot;https://en.wikipedia.org/wiki/Macro_(computer_science)#Syntactic_macros&quot;&gt;syntactic macros&lt;/a&gt;. When you go to its website, on the front page you can read these sentences:&lt;/p&gt;

&lt;a href=&quot;http://this-plt-life.tumblr.com/post/66298485729/when-im-being-propagandized-by-an-fp-weenie&quot;&gt;&lt;img
    src=&quot;../../../i/go_fpweenie.gif&quot; width='155px' height='100px'
    align=&quot;right&quot;&gt;&lt;/a&gt;&lt;ul&gt;&lt;li&gt;[…] Beneath a nice infix/indentation based syntax with a powerful (AST based, hygienic) macro system lies a semantic model that supports a soft realtime GC on thread local heaps. […]&lt;/li&gt;&lt;li&gt;Macros can modify the abstract syntax tree at compile time.&lt;/li&gt;&lt;li&gt;Macros can use the imperative paradigm to construct parse trees. Nim does not require a different coding style for meta programming.&lt;/li&gt;&lt;li&gt;Macros cannot change Nim's syntax because there is no need for it. Nim's syntax is flexible enough.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;If you learn about a new language and read these things on the front page, you understand that macros are a really important part of the language, and their use is encouraged by the language developers. As such, it was very surprising that when I posted to &lt;a href=&quot;http://www.reddit.com/r/nimrod/comments/2polby/swift_string_interpolation_with_nim_macros/&quot;&gt;reddit one of my articles about Nim macros&lt;/a&gt; the user &lt;span style=&quot;font-weight: bold;&quot;&gt;SupersonicSpitfire&lt;/span&gt; mentioned the article is offensive without any logic, macros are not an advantage, but a huge disadvantage, I'm stupid and I suck (later edited to &lt;span style=&quot;font-style: italic;&quot;&gt;soften&lt;/span&gt; the language a bit), and macros in general are offensive.&lt;/p&gt;

&lt;a href=&quot;http://this-plt-life.tumblr.com/post/36425244621/when-i-hear-your-new-pl-doesnt-have-exceptions&quot;&gt;&lt;img
    src=&quot;../../../i/go_dexter.gif&quot; width='150px' height='85px'
    align=&quot;right&quot;&gt;&lt;/a&gt;&lt;p&gt;I'm not a stranger to &lt;a href=&quot;http://www.penny-arcade.com/comic/2004/03/19/&quot;&gt;John Gabriel's Greater Internet Fuckwad Theory&lt;/a&gt;, being insulted on the internet is just the norm. But I didn't cross post this anywhere else, it was an article about Nim for other Nim programmers. Is &lt;span style=&quot;font-weight: bold;&quot;&gt;SupersonicSpitfire&lt;/span&gt; an actual Nim programmer who hates… a big chunk of the language? That's really bothering me. It's like something is broken in this universe. Why would people who passionately hate a feature follow their communities? Self inflicted stress? Pain?!&lt;/p&gt;
&lt;h2&gt;What are macros anyway?&lt;/h2&gt;
&lt;a href=&quot;http://this-plt-life.tumblr.com/post/37285848921/when-i-heard-of-gos-error-handling&quot;&gt;&lt;img
    src=&quot;../../../i/go_go.gif&quot; width='210px' height='142px'
    align=&quot;right&quot;&gt;&lt;/a&gt;&lt;p&gt;If you don't have the time to &lt;a href=&quot;https://en.wikipedia.org/wiki/Macro_(computer_science)#Syntactic_macros&quot;&gt;read Wikipedia's full article&lt;/a&gt;, macros are just one of the many methods to reduce typing. With macros you can &lt;span style=&quot;font-style: italic;&quot;&gt;generate&lt;/span&gt; source code for the compiler. Unfortunately the most well known macros are those from C/C++, which are just &lt;a href=&quot;https://en.wikipedia.org/wiki/Macro_(computer_science)#Text_substitution_macros&quot;&gt;text macros&lt;/a&gt; implemented by the language &lt;span style=&quot;font-weight: bold;&quot;&gt;preprocessor&lt;/span&gt; (the &lt;span style=&quot;font-weight: bold;&quot;&gt;pre&lt;/span&gt; should tell you already something about how they work).  While they are part of the standard (you can't implement C without them), they are not really part of the language itself, since the language doesn't know anything about them, and the preprocessor can only deal with source code as lines of text. Here is one fun example:&lt;/p&gt;
&lt;p&gt;&lt;pre class='code'&gt;&lt;span class=&quot;Preprocessor&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;Operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;stdio&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;Preprocessor&quot;&gt;#define&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;SIX&lt;/span&gt; &lt;span class=&quot;DecNumber&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;DecNumber&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;Preprocessor&quot;&gt;#define&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;NINE&lt;/span&gt; &lt;span class=&quot;DecNumber&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;DecNumber&quot;&gt;1&lt;/span&gt;

&lt;span class=&quot;Keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Keyword&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;Punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;Identifier&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;StringLit&quot;&gt;&amp;quot;Macros rule %d&lt;/span&gt;&lt;span class=&quot;EscapeSequence&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;StringLit&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;SIX&lt;/span&gt; &lt;span class=&quot;Operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;NINE&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;Punctuation&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/p&gt;

&lt;a href=&quot;http://this-plt-life.tumblr.com/post/44079123074/when-im-working-on-a-new-pl-most-of-the-time&quot;&gt;&lt;img
    src=&quot;../../../i/go_new.gif&quot; width='250px' height='122px'
    align=&quot;right&quot;&gt;&lt;/a&gt;&lt;p&gt;Running this program will produce the output 42, &lt;span style=&quot;font-weight: bold;&quot;&gt;not&lt;/span&gt; 54 as one could naively &lt;span style=&quot;font-style: italic;&quot;&gt;read&lt;/span&gt;. Since C macros are textual replacements, you actually get the expression &lt;code&gt;1 + 5 * 8 + 1&lt;/code&gt;, where the multiplication has higher priority, thus evaluates to &lt;code&gt;1 + 40 + 1 == 42&lt;/code&gt;. Experienced C programmers will bracket the hell out of their macros &lt;span style=&quot;font-weight: bold;&quot;&gt;just in case&lt;/span&gt;.  And this is the tip of the iceberg when people complain that macros hurt readability, entries of the &lt;a href=&quot;http://ioccc.org&quot;&gt;international obfuscated C code contest&lt;/a&gt; &lt;a href=&quot;http://ioccc.org/2013/endoh3/endoh3.c&quot;&gt;typically&lt;/a&gt; &lt;a href=&quot;http://ioccc.org/2013/hou/hou.c&quot;&gt;exploit&lt;/a&gt; &lt;a href=&quot;http://ioccc.org/2013/mills/mills.c&quot;&gt;macros&lt;/a&gt; &lt;a href=&quot;http://ioccc.org/2013/morgan2/morgan2.c&quot;&gt;extensively&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The reason text macros are still used is because they are very easy to implement, and with enough care they can help the programmer. For instance, the &lt;a href=&quot;http://aceontech.com/objc/ios/2014/01/10/weakify-a-more-elegant-solution-to-weakself.html&quot;&gt;@weakify(self) macro&lt;/a&gt; is quite popular in Objective-C circles because it hides away tedious typing you otherwise have to do to write correct code without going insane. The &lt;a href=&quot;https://github.com/jspahrsummers/libextobjc/blob/652c9903a84f44b93faed528882e0251542732b1/extobjc/EXTScope.h#L45&quot;&gt;weakify&lt;/a&gt; macro uses internally the &lt;a href=&quot;https://github.com/jspahrsummers/libextobjc/blob/master/extobjc/EXTScope.h#L115&quot;&gt;ext_keywordify&lt;/a&gt; macro. Just like with the &lt;code&gt;SIX * NINE&lt;/code&gt; from the first example, something written like this:&lt;/p&gt;
&lt;p&gt;&lt;pre class='code'&gt;&lt;span class=&quot;Operator&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;weakify&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt; …will expand to something similar to this: &lt;pre class='code'&gt;&lt;span class=&quot;Operator&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;Punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;Operator&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;Punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;Punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;Punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;Identifier&quot;&gt;more&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;macros&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;plus&lt;/span&gt;&lt;span class=&quot;Operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;Identifier&quot;&gt;self&lt;/span&gt;
&lt;/pre&gt;&lt;/p&gt;

&lt;a href=&quot;http://this-plt-life.tumblr.com/post/36425231672/when-a-code-base-uses-a-directory-structure-deeper&quot;&gt;&lt;img
    src=&quot;../../../i/go_src.gif&quot; width='160px' height='120px'
    align=&quot;right&quot;&gt;&lt;/a&gt;&lt;p&gt;Which is essentially the Objective-C equivalent of the &lt;a href=&quot;http://stackoverflow.com/questions/4674480/do-whilefalse-pattern&quot;&gt;do while(false)&lt;/a&gt; pattern used exclusively to bring that at-sign (&lt;code&gt;@&lt;/code&gt;) into your code so it &lt;span style=&quot;font-style: italic;&quot;&gt;looks&lt;/span&gt; like a &lt;span style=&quot;font-style: italic;&quot;&gt;native&lt;/span&gt; compiler directive. It's a clever hack, but following how it works is not easy at all: more bad reputation.&lt;/p&gt;
&lt;p&gt;I implemented myself another form of macros for Java and Android development. For a project where we had just one source code base customized for different clients, the most sensible way was to use a preprocessor where you replace a few strings or keywords and you get an different independent binary, something not supported by the ancient Ant build tool. Using Python and some regular expressions I implemented what later was replaced by &lt;a href=&quot;http://tools.android.com/tech-docs/new-build-system/user-guide#TOC-Build-Variants&quot;&gt;Gradle's build variants&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The Gradle version was better integrated with the build system, but effectively I had reached before the same conclusion: for a certain task, a macro was the best solution. And if it wasn't, Google engineers wouldn't have pushed this feature either.  One thing to note is that they didn't implement it as crude text replacement, looks more like &lt;a href=&quot;https://en.wikipedia.org/wiki/Macro_(computer_science)#Procedural_macros&quot;&gt;procedural macros&lt;/a&gt;, since you use Gradle (a mini language) to define these things, and it can be analyzed statically (I believe, or maybe it does that at runtime, which would explain why it is painfully slow whenever you change a setting). In any case, today new development tries to go away from the aberrations you can generate with textual macros. We know they are painful.&lt;/p&gt;
&lt;h2&gt;Nim macros&lt;/h2&gt;
&lt;a href=&quot;http://this-plt-life.tumblr.com/post/43655942984/when-im-working-on-a-macro-system-with-phase&quot;&gt;&lt;img
    src=&quot;../../../i/go_tower.gif&quot; width='100px' height='100px'
    align=&quot;right&quot;&gt;&lt;/a&gt;&lt;p&gt;In the quest for improving meta programming, we reach &lt;a href=&quot;https://en.wikipedia.org/wiki/Macro_(computer_science)#Syntactic_macros&quot;&gt;syntactic macros&lt;/a&gt;, which work on abstract syntax trees (ASTs) instead of lines of text. Nim macros, like other languages, features hygienic macros, meaning that unlike C macros where you can affect code posterior to the macro expansion, whatever you do in the macro stays there. Nim macros end up being like normal procs with two main differences:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;They run at compile time (in the case of Nim, other languages might do macro expansion at runtime)&lt;/li&gt;&lt;li&gt;They process ASTs, and generate ASTs.&lt;/li&gt;&lt;/ul&gt;
&lt;a href=&quot;http://this-plt-life.tumblr.com/post/40016419394/when-somebody-asks-me-about-a-non-s-expression&quot;&gt;&lt;img
    src=&quot;../../../i/go_huh_what.gif&quot; width='125px' height='101px'
    align=&quot;right&quot;&gt;&lt;/a&gt;&lt;p&gt;Like the Wikipedia article mentions, macros are kind of natural of &lt;a href=&quot;https://en.wikipedia.org/wiki/S-expression&quot;&gt;S-expression&lt;/a&gt; languages, since S-expression allows easily to treat code and data equally. But many people feel uncomfortable with S-expressions. Nim has an imperative syntax, so it looks more familiar, at the cost of being more verbose. The availability of modifying the ASTs is also limited. In a text macro implementation you can change whatever you want. But here you are fed just a subtree of the user's AST, and that's the only thing you can modify.&lt;/p&gt;
&lt;p&gt;To simplify, the Nim compiler runs your macros, which produce more ASTs, and then compiles their output. This allows one to expand the language and provide new constructs. With macros you can &lt;a href=&quot;http://nim-by-example.github.io/oop_macro/&quot;&gt;implement object oriented programming&lt;/a&gt;, no need to wait for the language to evolve, you can evolve it yourself!&lt;/p&gt;
&lt;h2&gt;So what does this have to do with Go, they don't have macros!&lt;/h2&gt;
&lt;a href=&quot;http://this-plt-life.tumblr.com/post/36425239482/when-i-hear-theyre-adding-features-to-c&quot;&gt;&lt;img
    src=&quot;../../../i/go_cxx.gif&quot; width='120px' height='114px'
    align=&quot;right&quot;&gt;&lt;/a&gt;&lt;p&gt;Yes they do. The blog post &lt;a href=&quot;http://blog.golang.org/generate&quot;&gt;Generating code&lt;/a&gt; posted on the 22nd of December of 2014 should already hint with its title that Go version 1.4 includes some sort of mechanism to generate code. Oh… shiny… that sounds like meta programming… as if you could generate code for the compiler…&lt;/p&gt;
&lt;br clear=&quot;right&quot;&gt;&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;ATTENTION:&lt;/span&gt; If you are one of those Go acolytes who believes Go's most important feature is simplicity and readability, please stop reading! And never ever &lt;span style=&quot;font-weight: bold;&quot;&gt;go&lt;/span&gt; to version 1.4 and beyond!&lt;/p&gt;

&lt;a href=&quot;http://this-plt-life.tumblr.com/post/39920361990/when-someone-is-enamored-with-a-languages-petty&quot;&gt;&lt;img
    src=&quot;../../../i/go_irrelevant.gif&quot; width='150px' height='150px'
    align=&quot;right&quot;&gt;&lt;/a&gt;&lt;p&gt;The example given in Go's blog is to stringify enum constants into strings so you can print them or maybe compare them. The &lt;a href=&quot;https://docs.google.com/a/golang.org/document/d/1V03LUfjSADDooDMhe-_K59EgpTEm3V8uvQRuNMAEnjg/edit?pli=1&quot;&gt;Go generate design document&lt;/a&gt; provides additional examples like generating protocol buffers bindings (which you could do with a Nim macro based on a type definition), embedding binary data (which you could do with a Nim macro, but is so common that you can use Nim's &lt;a href=&quot;http://nim-lang.org/docs/system.html#staticRead&quot;&gt;staticRead()&lt;/a&gt;), etc. Other quotes from that document:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;One could imagine a variant sort implementation that allows one to specify concrete types that have custom sorters, just by automatic rewriting of &lt;span style=&quot;font-weight: bold;&quot;&gt;macro-like&lt;/span&gt; sort definition[…]&lt;/li&gt;&lt;li&gt;There are many more possibilities, and it is a goal of this proposal to encourage experimentation with pre-build-time code generation&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;While the feature has just been released, people in the community have already been playing with it. Let's see some comments from the &lt;a href=&quot;http://www.reddit.com/r/golang/comments/2q3yj4/generating_code&quot;&gt;reddit discussion&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;I've been working on a tool called &lt;a href=&quot;https://github.com/jamesgarfield/goast&quot;&gt;goast&lt;/a&gt; off and on since they announced this proposal, that aims to to take advantage of the go generate tool.&lt;/li&gt;&lt;li&gt;Just want to link a tool I've been using for generics-like functionality recently. It's still an early version, but I think it's promising &lt;a href=&quot;https://github.com/ncw/gotemplate&quot;&gt;https://github.com/ncw/gotemplate&lt;/a&gt;.&lt;/li&gt;&lt;li&gt;this might be a way to implement data structure without interface […] I wrote this &lt;a href=&quot;https://github.com/jteeuwen/templates&quot;&gt;tool&lt;/a&gt; a few days ago as an experiment, to demonstrate just that[…]&lt;/li&gt;&lt;/ul&gt;
&lt;a href=&quot;http://this-plt-life.tumblr.com/post/44373483122/when-somebody-tries-to-add-a-type-system-to-an&quot;&gt;&lt;img
    src=&quot;../../../i/go_ts.gif&quot; width='180px' height='101px'
    align=&quot;right&quot;&gt;&lt;/a&gt;&lt;p&gt;This is inevitable. Go programmers like the language and they want more, so they explore meta programming. Unfortunately, the language authors don't want to provide support in the language, so they have resorted to the worst kind of macro implementation, which is text based. So much progress to reimplement C. Not only that, but since you can run arbitrary commands to pre generate code, users are not meant to run these custom preprocessors. Yay for littering our source control systems with pre generated crap no one will ever bother reading! Let's recap:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Go 1.4 officially defines a code generation mechanism.&lt;/li&gt;&lt;li&gt;The mechanism is external to the language.&lt;/li&gt;&lt;li&gt;Since it is external, you could see the day where a tool is for instance Windows specific and won't run on Linux.&lt;/li&gt;&lt;li&gt;The tools, being external, need to reimplement parsing and other basic facilities themselves. Not very DRY.&lt;/li&gt;&lt;li&gt;And they have to produce source code too, which has to be stored because &lt;span style=&quot;font-style: italic;&quot;&gt;normal&lt;/span&gt; users are not meant to run these tools.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;At least users can look at the generated source code. One of the pains of C/C++ is figuring out what the macro expansion does, since by default this goes straight to the compiler. Much of the readability problems arise from programmers thinking the macro does something else.  I think Go authors could have provided something better, but at least they are advancing their language.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;a href=&quot;http://this-plt-life.tumblr.com/post/36425240884/when-everybody-hypes-a-language-that-i-find-crap&quot;&gt;&lt;img
    src=&quot;../../../i/go_hate.gif&quot; width='147px' height='90px'
    align=&quot;right&quot;&gt;&lt;/a&gt;&lt;p&gt;Meta programming has come to stay. If you have been conditioned to think macros are bad because you have been spoon fed plenty of C/C++ horror stories, you should think again. More and more languages implement macros. But do yourself a favour and use a language which provides the more saner syntactic macros. Unfortunately that means leaving Go, at least until they reach 2.0 (or later) and improve their meta programming capabilities.&lt;/p&gt;

&lt;center&gt;&lt;a href=&quot;http://darkablaxx.tistory.com/69&quot;&gt;&lt;img
    src=&quot;../../../i/go_gon.jpg&quot;
    alt=&quot;Trolling Gon&quot;
    style=&quot;width:100%;max-width:600px&quot;
    hspace=&quot;8pt&quot; vspace=&quot;8pt&quot;&gt;&lt;/a&gt;&lt;/center&gt;&lt;br&gt;&lt;pre class='literal'&gt;$ nim c -r macros.nim
macros.nim(1, 7) Error: A module cannot import itself&lt;/pre&gt;
      </content>
    </entry>
</feed>
