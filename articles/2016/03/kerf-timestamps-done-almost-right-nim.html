<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang='en'>
	<head>
		<title>Kerf timestamps done almost right: Nim - Rants from the Ballmer Peak</title>
		<meta name="viewport" content="initial-scale=1, maximum-scale=1">
		<link rel="stylesheet" href="../../../css/normalize.css">
		<link rel="stylesheet" href="../../../css/style.css">
		<link href="../../../feed.xml" title="Articles" type="application/atom+xml" rel="alternate">
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	</head>
	<body>
	<div class="content">
		<h3><a href="../../../index.html">Rants from the Ballmer Peak</a> <a
				href="../../../feed.xml"><img
			alt="rss feed" src="../../../i/Feed-icon.svg"
			width="18pt" height="18pt"></a></h3>
    <table border="0" bgcolor="#cccccc"><tr><td><i>Need a great Android/KMP developer? <a href="https://www.linkedin.com/in/gradha/">Hire me!</a></i>
    </table><br>
		<h1>Kerf timestamps done almost right: Nim</h1><p>In the <a href="kerf-timestamps-done-almost-right-a-new-type.html">previous chapter of the series</a> we reached the conclusion that to implement Kerf's timestamp types we need the following features from a programming language:</p>
<ol><li>Value type semantics with strong typing to avoid mistakes.</li><li>Instancing types on the stack to avoid slow heap memory allocations and alleviate manual memory handling or garbage collector pressure.</li><li>Custom literals for easier construction of such types.</li><li>Operator overloading to implement all possible custom operations.</li><li>Generics are not necessary but help with implementation.</li></ol>
<table border="1" bgcolor="#cccccc"><tr><td style="vertical-align: middle;"
><b>META NAVIGATION START</b>
<p>This is a really long article (<a class="blink"
href="https://www.manning.com/books/nim-in-action"
>Buy Nim in Action!</a>) which has
been split in different chapters because it is (<a class="blink"
href="https://www.manning.com/books/nim-in-action"
>Nim in Action on sale!</a>) unsuitable for today's average attention span
and lets me
maximize (<a href="https://www.manning.com/books/nim-in-action" class="blink"
>Get Nim in Action now!</a>) page ads.
<p><b>META NAVIGATION END</b>
</td><td nowrap>
<ol>
<li><a href="kerf-timestamps-done-almost-right-a-new-type.html">a new type?</a>
<li>Nim <b>You are here!</b>
<li><a href="kerf-timestamps-done-almost-right-c-plus--plus-.html">C++</a>
<li><a href="kerf-timestamps-done-almost-right-swift.html">Swift</a>
<li><a href="kerf-timestamps-done-almost-right-wtf…-java.html">WTF… Java?</a>
<li><a href="kerf-timestamps-done-almost-right-conclusions.html">conclusions</a>
</ol></td></tr></table><p><a href="http://nim-lang.org">Nim</a> (formerly known as &quot;Nimrod&quot;) is a statically typed, imperative programming language that tries to give the programmer ultimate power without compromises on runtime efficiency. This means it focuses on compile-time mechanisms in all their various forms. However, for the task of designing a new custom timestamp type we don't need much of this compile-time power. Running our requirement list against Nim's feature set we get:</p>
<ol><li>Nim has value type semantics with strong typing to avoid mistakes (yay!).</li><li>Allows instancing types on the stack, though we will see we don't even need to create our own new types because we can reuse primitive ones (super yay!).</li><li>Nim doesn't have custom literals for construction of types (booo), but it has such flexible syntax which makes it look as if it had them (yay!).</li><li>Nim allows operator overloading (yay!).</li><li>Very simple to write clean generics for bonus points (yay!).</li></ol><p>With four yays and one super yay it is hard to not like this language, other than the lack of a core timestamp type which we will quickly fix. The implementation you see here (<a href="https://github.com/gradha/kerf_timestamps_done_almost_right/tree/master/nim">available at Github</a>) was the first to be done because it is the closest it can get to Kerf's core timestamp type. The other implementations are <a href="https://www.youtube.com/watch?v=UfV24sc-2gQ">wannabe clones</a>.</p>
<h2>Distinct timestamps</h2><a href="http://www.all-idol.com/1620"><img
    src="../../../i/kerf_distinct_types.jpg"
    alt="Distinct types, low maintenance, easy to use and effective, just what you need to deal with those type problems"
    style="width:100%;max-width:600px" align="right"
    hspace="8pt" vspace="8pt"></a><p>As mentioned in the introduction chapter, we will be implementing two different types. Internally they will have the same binary internal representation, but they will live in different modules. The differential type will be called <code>Nano</code> and will live in a <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/time_nanos.nim">time_nanos.nim file</a>. The calendar like type will be named <code>Stamp</code> and will live in a <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/time_stamp.nim">time_stamp.nim file</a>. The definition of both types is quite simple:</p>
<p><pre class='code'><span class="Keyword">type</span>
  <span class="Identifier">Nano</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">int64</span>

<span class="Keyword">type</span>
  <span class="Identifier">Stamp</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">int64</span>
</pre></p>
<p>In both cases what we are creating is a <a href="http://nim-lang.org/docs/manual.html#types-distinct-type">distinct type</a> based on a 64bit integer.  Distinct types are <a href="https://www.youtube.com/watch?v=sMZwZiU0kKs">my favourite choice for these problems</a> and are a way of telling the compiler: &quot;<span style="font-style: italic;">Hey, could you please treat this type you know as an actually different type and prevent me from doing stupid things to it unless I explicitly tell you to do so? kthxbye</span>&quot;.  This feature itself already provides us with two requirements from our goals list: value semantics with strong typing instanced on the stack for performance since we are using plain integers. The <code>*</code> symbol tells the compiler to export the type making it public for everybody to use.  After the type definition we need to tell the compiler which existing procs for the <span style="font-style: italic;">parent</span> or <span style="font-style: italic;">base</span> type (huh, type inheritance?) we want to have <span style="font-style: italic;">borrowed</span> for ourselves. So for <code>Nano</code> <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/time_nanos.nim#L5-L21">we would use</a>:</p>
<p><pre class='code'><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">&lt;</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int64</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">&lt;</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int64</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">&lt;=</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int64</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">&lt;=</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int64</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Keyword">mod</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int64</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int64</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Keyword">mod</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int64</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int64</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Keyword">mod</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Keyword">div</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int64</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int64</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Keyword">div</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int64</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int64</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Keyword">div</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int64</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">-</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int64</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int64</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span> <span class="Operator">=</span> <span class="Identifier">Nano</span><span class="Punctuation">(</span><span class="Identifier">x</span> <span class="Operator">*</span> <span class="Identifier">int64</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
</pre></p>
<p>Backticks are used to prevent the names of our procs from being interpreted by the compiler, they are the general identifier escaping mechanism and they are not required for normal looking identifiers.  That last line was made explicit without the <code>{.borrow.}</code> pragma to compare against the previous ones. For our simple cases multiplication is pretty easy to implement so it may not look like much (just a simple <a href="http://nim-lang.org/docs/manual.html#statements-and-expressions-type-conversions">type conversion</a>), but the borrow pragma comes in handy when you have a more complex type with busier procs.  Avoiding repetition is good and that is what this pragma does, besides we <span style="font-style: italic;">inherit</span> the upstream implementation should it change.  Following with our custom <code>Nano</code> type we will <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/time_nanos.nim#L26-L33">define a few constants</a> which we will be using through our code:</p>
<p><pre class='code'><span class="Keyword">const</span>
  <span class="Identifier">u_nano</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Identifier">Nano</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">)</span>
  <span class="Identifier">u_second</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Identifier">Nano</span><span class="Punctuation">(</span><span class="DecNumber">1_000_000_000</span><span class="Punctuation">)</span>
  <span class="Identifier">u_minute</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Identifier">u_second</span> <span class="Operator">*</span> <span class="DecNumber">60</span>
  <span class="Identifier">u_hour</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Identifier">u_minute</span> <span class="Operator">*</span> <span class="DecNumber">60</span>
  <span class="Identifier">u_day</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="DecNumber">24</span> <span class="Operator">*</span> <span class="Identifier">u_hour</span>
  <span class="Identifier">u_month</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="DecNumber">30</span> <span class="Operator">*</span> <span class="Identifier">u_day</span>
  <span class="Identifier">u_year</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Identifier">u_day</span> <span class="Operator">*</span> <span class="DecNumber">365</span>
</pre></p>
<p>Nothing special here at first glance. All the constants are exported through <code>*</code>. The first ones are type conversions from normal integers, one of them showing how the underscore character can be used to group numbers visually. The rest are the <span style="font-style: italic;">borrowed</span> procs for mathematical operations which already return our <code>Nano</code> type so they don't need further type conversions. Note how the <code>const</code> section is telling the compiler to run the code at compile time and store the result. Numerical constants are ordinary, but we can run essentially any Nim code and have its value pre calculated for us to avoid runtime slow downs.</p>
<p>Finally we reach the <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/time_nanos.nim#L37-L43">first lines of code</a> which will allow us to reach our goal of emulating Kerf timestamp types:</p>
<p><pre class='code'><span class="Keyword">proc</span> <span class="Identifier">ns</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int64</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Identifier">Nano</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>
<span class="Keyword">proc</span> <span class="Identifier">s</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int64</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">*</span> <span class="Identifier">u_second</span>
<span class="Keyword">proc</span> <span class="Identifier">i</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int64</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">*</span> <span class="Identifier">u_minute</span>
<span class="Keyword">proc</span> <span class="Identifier">h</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int64</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">*</span> <span class="Identifier">u_hour</span>
<span class="Keyword">proc</span> <span class="Identifier">d</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int64</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">*</span> <span class="Identifier">u_day</span>
<span class="Keyword">proc</span> <span class="Identifier">m</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int64</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">*</span> <span class="Identifier">u_month</span>
<span class="Keyword">proc</span> <span class="Identifier">y</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int64</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">*</span> <span class="Identifier">u_year</span>
</pre></p>
<p>These are normal procs which either cast or multiply plain integers with our constants to get a <code>Nano</code> value. We could use them like this:</p>
<p><pre class='code'><span class="Keyword">let</span> <span class="Identifier">time1</span> <span class="Operator">=</span> <span class="Identifier">ns</span><span class="Punctuation">(</span><span class="DecNumber">333</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">i</span><span class="Punctuation">(</span><span class="DecNumber">34</span><span class="Punctuation">)</span>
<span class="Keyword">let</span> <span class="Identifier">time2</span> <span class="Operator">=</span> <span class="Identifier">d</span><span class="Punctuation">(</span><span class="DecNumber">22</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">y</span><span class="Punctuation">(</span><span class="DecNumber">2</span><span class="Punctuation">)</span>
</pre></p>
<p>That's pretty boring. Previously I said that Nim doesn't have custom literals but the syntax is flexible enough to make it look like it has them.  How? Nim supports a flexible <a href="http://nim-lang.org/docs/manual.html#procedures-method-call-syntax">method call syntax</a> letting us to invoke the method on the first integer parameter as if it had been a class method (for primitive types!):</p>
<p><pre class='code'><span class="Keyword">let</span> <span class="Identifier">time3</span> <span class="Operator">=</span> <span class="FloatNumber">333.</span><span class="Identifier">ns</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="FloatNumber">34.</span><span class="Identifier">i</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Keyword">let</span> <span class="Identifier">time4</span> <span class="Operator">=</span> <span class="FloatNumber">22.</span><span class="Identifier">d</span> <span class="Operator">+</span> <span class="FloatNumber">2.</span><span class="Identifier">y</span>
</pre></p>
<p>The second line for <code>time4</code> goes through the next obvious step which is removal of parentheses since there are no more remaining call arguments. And that's how we get custom literals. Let's see again the equivalent Kerf syntax for comparison (I don't have access to Kerf, so this might have typos):</p>
<p><pre class='code'>
time1:333ns34i
time2:22d2y
time3:34i333ns
time4:2y22d
</pre> I'm guessing Kerf allows placing the time units in any order freely. It is certainly impossible to reach Kerf's exact syntax without you know, implementing such syntax in the compiler. Still, Nim's version is very very similar with the following drawbacks:</p>
<ol><li>The time unit has to be separate from the number by a dot.</li><li>You can't coalesce several time units into a single contiguous token.</li></ol><p>Another possible way of implementing these, and in fact, an additional way of doing since it can coexist with those separate pseudo literals, is creating a string parser. Just like we defined procs for integers we can make one for strings which at compile time parses the string and returns the <code>Nano</code> value or aborts compilation due to an error. I haven't implemented it for <code>Nano</code> since it's a little redundant and  will look at a parsing implementation for the <code>Stamp</code> literal equivalent. However, here is what it could look like:</p>
<p><pre class='code'><span class="Comment"># Hypothetical string literal</span>
<span class="Keyword">let</span> <span class="Identifier">time1</span> <span class="Operator">=</span> <span class="Identifier">Nano</span><span class="Punctuation">(</span><span class="StringLit">&quot;333ns34i&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">let</span> <span class="Identifier">time2</span> <span class="Operator">=</span> <span class="RawData">n&quot;22d2y&quot;</span>
<span class="Keyword">let</span> <span class="Identifier">time3</span> <span class="Operator">=</span> <span class="StringLit">&quot;34i333ns&quot;</span><span class="Operator">.</span><span class="Identifier">n</span>
<span class="Keyword">let</span> <span class="Identifier">time4</span> <span class="Operator">=</span> <span class="StringLit">&quot;2y22d&quot;</span><span class="Operator">.</span><span class="Identifier">n</span>
</pre></p>
<p>We can't get rid of the string literal delimiters, but depending on how we feel we can use a <code>Nano</code> pseudo constructor, or a <code>n</code> shortened version which doesn't have to use the dot separator in the prefix version since the string quotes are already a natural delimiter. I tend to prefer not using strings because they are like type safety pits so I will stick with the <span style="font-style: italic;">you-have-to-manually-add-them</span> version. Still, quite nice approximation to a core native language feature without much work on our part.  The examples so far have concentrated on the correct syntax, but you don't have to worry about making Mars climate orbiter class type errors, here is an example of an error the compiler will complain with if we fail to properly type the units in a mathematical expression:</p>
<p><pre class='code'><span class="Keyword">let</span> <span class="Identifier">error</span> <span class="Operator">=</span> <span class="DecNumber">345</span> <span class="Operator">+</span> <span class="FloatNumber">500.</span><span class="Identifier">ns</span>
<span class="Comment"># Error: type mismatch: got (int literal(345), Nano)</span>
<span class="Comment"># but expected one of:</span>
<span class="Comment"># time_nanos.+(x: Nano, y: Nano)</span>
<span class="Comment"># system.+(x: int32, y: int32)</span>
<span class="Comment"># system.+(x: float)</span>
<span class="Comment"># system.+(x: int32)</span>
<span class="Comment"># system.+(x: int8)</span>
<span class="Comment"># system.+(x: int)</span>
<span class="Comment"># system.+(x: float, y: float)</span>
<span class="Comment"># system.+(x: set[T], y: set[T])</span>
<span class="Comment"># system.+(x: int8, y: int8)</span>
<span class="Comment"># system.+(x: float32, y: float32)</span>
<span class="Comment"># system.+(x: int, y: int)</span>
<span class="Comment"># system.+(x: int64, y: int64)</span>
<span class="Comment"># system.+(x: int64)</span>
<span class="Comment"># system.+(x: float32)</span>
<span class="Comment"># system.+(x: int16)</span>
<span class="Comment"># system.+(x: int16, y: int16)</span>
</pre></p>
<p>The compiler looks for a proc which adds two parameters, one of type <code>literal</code> and another of type <code>Nano</code>. We have not defined any for that combination, hence we can't add untyped literals to time differentials, which is the whole point of using distinct types. As a reminder the compiler will list all the overloaded variants it knows of the addition proc, telling also what module their implementation comes from. With this we can scratch two more goals from our list: custom literals and type safe mathematical operations through operator overloading. Moving on sequentially through the <code>time_nanos.nim</code> implementation we find <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/time_nanos.nim#L45-L83">helpers which extract a value from a Nano</a>. A short excerpt:</p>
<p><pre class='code'><span class="Keyword">proc</span> <span class="Identifier">year</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">procvar</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">x</span> <span class="Keyword">div</span> <span class="Identifier">u_year</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">month</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">procvar</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">x</span> <span class="Keyword">div</span> <span class="Identifier">u_day</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">result</span> <span class="Keyword">mod</span> <span class="DecNumber">365</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="DecNumber">1</span> <span class="Operator">+</span> <span class="Punctuation">(</span><span class="Identifier">result</span> <span class="Keyword">mod</span> <span class="DecNumber">12</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">week</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">procvar</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">x</span> <span class="Keyword">div</span> <span class="Identifier">u_day</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">result</span> <span class="Keyword">mod</span> <span class="DecNumber">365</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="DecNumber">1</span> <span class="Operator">+</span> <span class="Punctuation">(</span><span class="Identifier">result</span> <span class="Keyword">div</span> <span class="DecNumber">7</span><span class="Punctuation">)</span>
</pre></p>
<p>That section defines the date component getters for the type, which can be used as proc calls in prefix or postfix notation to extract the year, month, week, etc of a <code>Nano</code> value. As you can see from the implementation I'm totally ignoring any calendar realities: all years are 365 days, the month and weeks are extracted through a simple modulo operation ignoring any real calendar… as warned before this is not a full, complete and perfect implementation of the functionality. These getters maybe don't have much sense for the <code>Nano</code> type but I felt like implementing them here, <code>Stamp</code> will just reuse them.  But for a <span style="font-style: italic;">real</span> implementation it could make sense that the <code>Nano</code> week getter and the <code>Stamp</code> week getter had different results. The interval week getter could calculate the amount of weeks the interval spans, returning a fractional value. The calendar week getter would instead provide you the week number index of the year the specific date falls at.</p>
<p>Following the date component getters there's the <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/time_nanos.nim#L86-L125">stringify proc for the Nano type</a>:</p>
<p><pre class='code'><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">x</span> <span class="Operator">&lt;</span> <span class="DecNumber">1</span><span class="Punctuation">:</span>
    <span class="Keyword">return</span> <span class="StringLit">&quot;0s&quot;</span>
  
  <span class="Keyword">var</span>
    <span class="Identifier">nano</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Keyword">mod</span> <span class="DecNumber">1_000_000_000</span>
    <span class="Identifier">seconds</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">x</span> <span class="Keyword">div</span> <span class="DecNumber">1_000_000_000</span><span class="Punctuation">)</span> <span class="Keyword">mod</span> <span class="DecNumber">60</span>
    <span class="Identifier">minutes</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Keyword">div</span> <span class="DecNumber">60_000_000_000</span>
  
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Keyword">if</span> <span class="DecNumber">0</span> <span class="Operator">==</span> <span class="Identifier">nano</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&quot;</span> <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Operator">$</span><span class="Identifier">nano</span> <span class="Operator">&amp;</span> <span class="StringLit">&quot;ns&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Keyword">if</span> <span class="DecNumber">0</span> <span class="Operator">==</span> <span class="Identifier">seconds</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Operator">$</span><span class="Identifier">seconds</span> <span class="Operator">&amp;</span> <span class="StringLit">&quot;s&quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">result</span><span class="Punctuation">)</span>
  <span class="Keyword">if</span> <span class="Identifier">minutes</span> <span class="Operator">&lt;</span> <span class="DecNumber">1</span><span class="Punctuation">:</span>
    <span class="Keyword">return</span>
  
  <span class="Keyword">var</span> <span class="Identifier">hours</span> <span class="Operator">=</span> <span class="Identifier">minutes</span> <span class="Keyword">div</span> <span class="DecNumber">60</span>
  <span class="Identifier">minutes</span> <span class="Operator">=</span> <span class="Identifier">minutes</span> <span class="Keyword">mod</span> <span class="DecNumber">60</span>
  
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Keyword">if</span> <span class="DecNumber">0</span> <span class="Operator">==</span> <span class="Identifier">minutes</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Operator">$</span><span class="Identifier">minutes</span> <span class="Operator">&amp;</span> <span class="StringLit">&quot;m&quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">result</span><span class="Punctuation">)</span>
  <span class="Keyword">if</span> <span class="Identifier">hours</span> <span class="Operator">&lt;</span> <span class="DecNumber">1</span><span class="Punctuation">:</span>
    <span class="Keyword">return</span>
  
  <span class="Keyword">var</span> <span class="Identifier">days</span> <span class="Operator">=</span> <span class="Identifier">hours</span> <span class="Keyword">div</span> <span class="DecNumber">24</span>
  <span class="Identifier">hours</span> <span class="Operator">=</span> <span class="Identifier">hours</span> <span class="Keyword">mod</span> <span class="DecNumber">24</span>
  
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Keyword">if</span> <span class="DecNumber">0</span> <span class="Operator">==</span> <span class="Identifier">hours</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Operator">$</span><span class="Identifier">hours</span> <span class="Operator">&amp;</span> <span class="StringLit">&quot;h&quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">result</span><span class="Punctuation">)</span>
  <span class="Keyword">if</span> <span class="Identifier">days</span> <span class="Operator">&lt;</span> <span class="DecNumber">1</span><span class="Punctuation">:</span>
    <span class="Keyword">return</span>
  
  <span class="Keyword">let</span> <span class="Identifier">years</span> <span class="Operator">=</span> <span class="Identifier">days</span> <span class="Keyword">div</span> <span class="DecNumber">365</span>
  <span class="Identifier">days</span> <span class="Operator">=</span> <span class="Identifier">days</span> <span class="Keyword">mod</span> <span class="DecNumber">365</span>
  
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Keyword">if</span> <span class="DecNumber">0</span> <span class="Operator">==</span> <span class="Identifier">days</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Operator">$</span><span class="Identifier">days</span> <span class="Operator">&amp;</span> <span class="StringLit">&quot;d&quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">result</span><span class="Punctuation">)</span>
  <span class="Keyword">if</span> <span class="Identifier">years</span> <span class="Operator">&lt;</span> <span class="DecNumber">1</span><span class="Punctuation">:</span>
    <span class="Keyword">return</span>
  
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Operator">$</span><span class="Identifier">years</span> <span class="Operator">&amp;</span> <span class="StringLit">&quot;y&quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">result</span>
</pre></p>
<p>In Nim the <a href="http://nim-lang.org/docs/system.html#$">$ operator</a> is used generically to convert anything to a string.  The <a href="http://nim-lang.org/docs/system.html#echo">system.echo()</a> proc used to output values uses an additional feature, <a href="http://nim-lang.org/docs/manual.html#types-varargs">Nim variadic parameters allow specifying an automatic type conversion proc</a>. What this means is that we don't have to type <code>$</code> in many situations because the compiler can figure that out and spare us.</p>
<p>The implementation of this <code>$</code> proc won't win any performance contests, it is just the first version I came up which looked more or less understandable. The <code>Nano</code> value is being split in units and each is converted to a string with the appropriate suffix. Some logic is added to avoid outputting <span style="font-style: italic;">empty</span> units, which makes the string representation more compact and similar to what you would write as input to the compiler. I made the output match Kerf's examples, but maybe it would have been better to match Nim input exactly and separate the time units in the final string with addition sings, so you could copy and paste the output from <code>echo()</code> somewhere else and have it work. Again, freedom we have since the type is not core to the language and we can decide what it does (or if this came from a library, customize/override the behaviour).</p>
<p>After the <code>$</code> proc implementation there come <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/time_nanos.nim#L127-L129">two helpers for string concatenation</a>:</p>
<p><pre class='code'><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">&amp;</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Operator">$</span><span class="Identifier">x</span> <span class="Operator">&amp;</span> <span class="Identifier">y</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">&amp;</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">&amp;</span> <span class="Operator">$</span><span class="Identifier">y</span>
</pre></p>
<p>On top of the <code>$</code> proc, Nim uses the <a href="http://nim-lang.org/docs/system.html#&amp;">&amp; operator</a> to concatenate strings. Why not overload the addition operator like for example in Java? There are different preferences to this but they also depend on context. In Java there is no operator overloading so it is OK if the language defines this especially for String objects. However in a language like Nim you are allowed and sometimes encouraged to create your own operators. Since addition is such a generic operator it is best to keep it from having the meaning of concatenating stuff, otherwise if you wrote <span style="font-weight: bold;">by mistake</span> the addition between a string and a <code>Nano</code> you could end up with the compiler stringifying the <code>Nano</code> value and concatenating it to the previous variable. This is a bad idea, hence a <code>&amp;</code> operator is preferred in languages which allow overloading, to avoid confusion and/or extra parentheses around your expressions to coerce them to the expected type. This little design decision will have implications in the <a href="kerf-timestamps-done-almost-right-swift.html">Swift implementation</a>.</p>
<p>After these helpers we have <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/time_nanos.nim#L132-L139">another custom operator helper</a>. It's usage is not obvious at the moment so we will come back to it by the end of the article. The implementation <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/time_nanos.nim#L142-L167">ends up with a basic self unit testing code</a> I wrote to verify I'm not doing anything too stupid. From this code we can see how near or far we have come to Kerf's version:</p>
<p><pre class='code'><span class="Keyword">const</span>
  <span class="Identifier">composed_difference</span> <span class="Operator">=</span> <span class="FloatNumber">1.</span><span class="Identifier">h</span> <span class="Operator">+</span> <span class="FloatNumber">23.</span><span class="Identifier">i</span> <span class="Operator">+</span> <span class="FloatNumber">45.</span><span class="Identifier">s</span>
  <span class="Identifier">composed_string</span> <span class="Operator">=</span> <span class="Operator">$</span><span class="Identifier">composed_difference</span>


<span class="Keyword">proc</span> <span class="Identifier">test_seconds</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Testing second operations:</span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span>
  <span class="Identifier">echo</span> <span class="Identifier">Nano</span><span class="Punctuation">(</span><span class="DecNumber">500</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="StringLit">&quot; = &quot;</span><span class="Punctuation">,</span> <span class="FloatNumber">500.</span><span class="Identifier">ns</span>
  <span class="Identifier">echo</span> <span class="Identifier">u_second</span><span class="Punctuation">,</span> <span class="StringLit">&quot; = &quot;</span><span class="Punctuation">,</span> <span class="FloatNumber">1.</span><span class="Identifier">s</span>
  <span class="Identifier">echo</span> <span class="Identifier">u_minute</span> <span class="Operator">+</span> <span class="Identifier">u_second</span> <span class="Operator">+</span> <span class="Identifier">Nano</span><span class="Punctuation">(</span><span class="DecNumber">500</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="StringLit">&quot; = &quot;</span><span class="Punctuation">,</span> <span class="FloatNumber">1.</span><span class="Identifier">i</span> <span class="Operator">+</span> <span class="FloatNumber">1.</span><span class="Identifier">s</span> <span class="Operator">+</span> <span class="FloatNumber">500.</span><span class="Identifier">ns</span>
  <span class="Identifier">echo</span> <span class="Identifier">u_hour</span><span class="Punctuation">,</span> <span class="StringLit">&quot; = &quot;</span><span class="Punctuation">,</span> <span class="FloatNumber">1.</span><span class="Identifier">h</span>
  <span class="Identifier">echo</span> <span class="FloatNumber">1.</span><span class="Identifier">h</span> <span class="Operator">+</span> <span class="FloatNumber">23.</span><span class="Identifier">i</span> <span class="Operator">+</span> <span class="FloatNumber">45.</span><span class="Identifier">s</span><span class="Punctuation">,</span> <span class="StringLit">&quot; = &quot;</span><span class="Punctuation">,</span> <span class="Identifier">composed_difference</span><span class="Punctuation">,</span> <span class="StringLit">&quot; = &quot;</span><span class="Punctuation">,</span> <span class="Identifier">composed_string</span>
  <span class="Identifier">echo</span> <span class="Identifier">u_day</span><span class="Punctuation">,</span> <span class="StringLit">&quot; = &quot;</span><span class="Punctuation">,</span> <span class="FloatNumber">1.</span><span class="Identifier">d</span>
  <span class="Identifier">echo</span> <span class="Identifier">u_year</span><span class="Punctuation">,</span> <span class="StringLit">&quot; = &quot;</span><span class="Punctuation">,</span> <span class="FloatNumber">1.</span><span class="Identifier">y</span>
  <span class="Identifier">echo</span> <span class="Identifier">u_year</span> <span class="Operator">-</span> <span class="FloatNumber">1.</span><span class="Identifier">d</span>
  
  <span class="Keyword">let</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">composed_difference</span> <span class="Operator">+</span> <span class="FloatNumber">3.</span><span class="Identifier">y</span> <span class="Operator">+</span> <span class="FloatNumber">6.</span><span class="Identifier">m</span> <span class="Operator">+</span> <span class="FloatNumber">4.</span><span class="Identifier">d</span> <span class="Operator">+</span> <span class="FloatNumber">12_987.</span><span class="Identifier">ns</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;total &quot;</span><span class="Punctuation">,</span> <span class="Identifier">a</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\t</span><span class="StringLit">year &quot;</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">year</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\t</span><span class="StringLit">month &quot;</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">month</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\t</span><span class="StringLit">day &quot;</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">day</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\t</span><span class="StringLit">hour &quot;</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">hour</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\t</span><span class="StringLit">minute &quot;</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">minute</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\t</span><span class="StringLit">second &quot;</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">second</span>
</pre></p>
<p>The Kerf language compiles to C, and Nim does the same, both are equally cross platform. Since Nim allows running mostly any Nim code at compile time, the <code>const</code> block will run the <code>Nano</code> conversions at compilation time and will embed the final value in the C output source. By now you shouldn't have troubles understanding all these lines and figuring their expected output, but here it is in any case:</p>
<p><pre class='code'>
Testing second operations:

500ns = 500ns
1s = 1s
1m1s500ns = 1m1s500ns
1m1s500ns = 1m1s500ns
1h = 1h
1h23m45s = 1h23m45s = 1h23m45s
1d = 1d
1y = 1y
364d
total 3y184d1h23m45s12987ns
        year 3
        month 5
        day 5
        hour 1
        minute 23
        second 45
</pre></p>
<h2>I'm not an integer, not yet a Date</h2><p>The implementation of the <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/time_stamp.nim">time_stamp.nim file</a> implementing the parallel <code>Stamp</code> type is very similar to <code>Nano</code>, I'll cover only any new interesting details. The first one is that we can <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/time_stamp.nim#L6-L10">borrow basic mathematical operators to mix our types</a>:</p>
<p><pre class='code'><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Stamp</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Stamp</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Stamp</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Stamp</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">-</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Stamp</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Stamp</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">-</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Stamp</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Stamp</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
</pre></p>
<p>Of course the important thing is that we are <span style="font-weight: bold;">not</span> defining these operations for two <code>Stamp</code> types, we respect the laws of space-time continuum in this blog.  Just below we define <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/time_stamp.nim#L12-L22">a few internal non exported constants</a> for string parsing, <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/time_stamp.nim#L25-L34">wrappers for Stamp calendar component getters</a> as mentioned above, and finally the <span style="font-style: italic;">pseudo</span> <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/time_stamp.nim#L37-L103">custom literal for construction of Stamp types from strings</a>:</p>
<p><pre class='code'><span class="Keyword">proc</span> <span class="Identifier">date</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Stamp</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">token</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
  <span class="Identifier">do_assert</span> <span class="DecNumber">4</span> <span class="Operator">==</span> <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">parse_while</span><span class="Punctuation">(</span><span class="Identifier">token</span><span class="Punctuation">,</span> <span class="Identifier">Digits</span><span class="Punctuation">,</span> <span class="Identifier">year_start</span><span class="Punctuation">)</span>
  <span class="Keyword">var</span>
    <span class="Identifier">yyyy</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">mm</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">dd</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  <span class="Identifier">do_assert</span> <span class="DecNumber">4</span> <span class="Operator">==</span> <span class="Identifier">token</span><span class="Operator">.</span><span class="Identifier">parse_int</span><span class="Punctuation">(</span><span class="Identifier">yyyy</span><span class="Punctuation">)</span>
  <span class="Identifier">do_assert</span> <span class="Identifier">yyyy</span> <span class="Operator">&gt;=</span> <span class="Identifier">epoch_offset</span>
  
  <span class="Identifier">do_assert</span> <span class="DecNumber">2</span> <span class="Operator">==</span> <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">parse_while</span><span class="Punctuation">(</span><span class="Identifier">token</span><span class="Punctuation">,</span> <span class="Identifier">Digits</span><span class="Punctuation">,</span> <span class="Identifier">month_start</span><span class="Punctuation">)</span>
  <span class="Identifier">do_assert</span> <span class="DecNumber">2</span> <span class="Operator">==</span> <span class="Identifier">token</span><span class="Operator">.</span><span class="Identifier">parse_int</span><span class="Punctuation">(</span><span class="Identifier">mm</span><span class="Punctuation">)</span>
  <span class="Identifier">do_assert</span> <span class="Identifier">mm</span> <span class="Operator">&gt;</span> <span class="DecNumber">0</span> <span class="Keyword">and</span> <span class="Identifier">mm</span> <span class="Operator">&lt;</span> <span class="DecNumber">13</span>
  
  <span class="Identifier">do_assert</span> <span class="DecNumber">2</span> <span class="Operator">==</span> <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">parse_while</span><span class="Punctuation">(</span><span class="Identifier">token</span><span class="Punctuation">,</span> <span class="Identifier">Digits</span><span class="Punctuation">,</span> <span class="Identifier">days_start</span><span class="Punctuation">)</span>
  <span class="Identifier">do_assert</span> <span class="DecNumber">2</span> <span class="Operator">==</span> <span class="Identifier">token</span><span class="Operator">.</span><span class="Identifier">parse_int</span><span class="Punctuation">(</span><span class="Identifier">dd</span><span class="Punctuation">)</span>
  <span class="Identifier">do_assert</span> <span class="Identifier">dd</span> <span class="Operator">&gt;</span> <span class="DecNumber">0</span> <span class="Keyword">and</span> <span class="Identifier">dd</span> <span class="Operator">&lt;</span> <span class="DecNumber">32</span>
  
  <span class="Comment"># Finally, convert the individual values to a (fake) calendar.</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">Stamp</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">yyyy</span> <span class="Operator">-</span> <span class="Identifier">epoch_offset</span><span class="Punctuation">)</span> <span class="Operator">*</span> <span class="Identifier">u_year</span> <span class="Operator">+</span>
    <span class="Punctuation">(</span><span class="Identifier">mm</span> <span class="Operator">-</span> <span class="DecNumber">1</span><span class="Punctuation">)</span> <span class="Operator">*</span> <span class="Identifier">days_in_a_month</span> <span class="Operator">*</span> <span class="Identifier">u_day</span> <span class="Operator">+</span> <span class="Punctuation">(</span><span class="Identifier">dd</span> <span class="Operator">-</span> <span class="DecNumber">1</span><span class="Punctuation">)</span> <span class="Operator">*</span> <span class="Identifier">u_day</span><span class="Punctuation">)</span>
  
  <span class="Keyword">if</span> <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">&lt;</span> <span class="Identifier">minutes_start</span> <span class="Operator">-</span> <span class="DecNumber">1</span><span class="Punctuation">:</span>
    <span class="Keyword">return</span>
  
  <span class="Comment"># Ugh, we got some times… ok, try to parse them.</span>
  <span class="Identifier">…more</span> <span class="Identifier">boring</span> <span class="Identifier">code…</span>

<span class="Keyword">proc</span> <span class="Identifier">d</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Stamp</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">date</span>
</pre></p>
<p>The whole proc was shortened a bit for the blog because it is not very interesting. As you can see it simply goes through the string attempting to parse digits. Since this is a simple naive implementation it doesn't do much other than assert very basic conditions, and error reporting to the user in case of syntax failure is abysmal. But at least it works for our example. The last additional <code>d()</code> proc definition creates a convenience alias to shorten optional instantiation of <code>Stamp</code> types so we can write lines like:</p>
<p><pre class='code'><span class="Keyword">let</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="StringLit">&quot;2012.01.01&quot;</span><span class="Operator">.</span><span class="Identifier">date</span> <span class="Operator">+</span> <span class="FloatNumber">1.</span><span class="Identifier">d</span>
<span class="Keyword">let</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="RawData">d&quot;2012.01.01&quot;</span>
<span class="Keyword">let</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="StringLit">&quot;2012.01.01&quot;</span><span class="Operator">.</span><span class="Identifier">d</span>
</pre></p>
<p>The first one uses the known postfix parentheses less version to construct a date from a string (plus adding a single day to it). The second uses the optional <code>d()</code> alias in a prefix version and the third in postfix. Why does this not get confused with the <code>1.d</code> bit? Because one function accepts integer literals and the other one accepts strings, we've been using proc overloading for a while now so this shouldn't be a surprise. Potential addition errors are detected just like in the previous <code>Nano</code> example:</p>
<p><pre class='code'><span class="Keyword">let</span> <span class="Identifier">error</span> <span class="Operator">=</span> <span class="RawData">d&quot;2012.01.01&quot;</span> <span class="Operator">+</span> <span class="StringLit">&quot;2012.01.01&quot;</span><span class="Operator">.</span><span class="Identifier">d</span>
<span class="Comment"># Error: type mismatch: got (Stamp, Stamp)</span>
<span class="Comment"># but expected one of:</span>
<span class="Comment"># system.+(x: int32, y: int32)</span>
<span class="Comment"># system.+(x: float)</span>
<span class="Comment"># system.+(x: int32)</span>
<span class="Comment"># system.+(x: int8)</span>
<span class="Comment"># system.+(x: int)</span>
<span class="Comment"># system.+(x: float, y: float)</span>
<span class="Comment"># system.+(x: set[T], y: set[T])</span>
<span class="Comment"># system.+(x: int8, y: int8)</span>
<span class="Comment"># system.+(x: float32, y: float32)</span>
<span class="Comment"># system.+(x: int, y: int)</span>
<span class="Comment"># system.+(x: int64, y: int64)</span>
<span class="Comment"># system.+(x: int64)</span>
<span class="Comment"># system.+(x: float32)</span>
<span class="Comment"># system.+(x: int16)</span>
<span class="Comment"># system.+(x: int16, y: int16)</span>
<span class="Comment"># time_nanos.+(x: Nano, y: Nano)</span>
<span class="Comment"># time_stamp.+(x: Nano, y: Stamp)</span>
<span class="Comment"># time_stamp.+(x: Stamp, y: Nano)</span>
<span class="Comment"># time_stamp.+(x: Stamp, y: seq[Nano])</span>
</pre></p>
<p>Other than the extra addition proc overloads available to the compiler the reported error should be familiar. After having seen the stringify proc for the <code>Nano</code> type I won't copy the <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/time_stamp.nim#L107-L155">Stamp version</a> because it doesn't add anything worthy to the discussion. Then we get two more <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/time_stamp.nim#L158-L173">helper procs</a> which will remain as hidden ninjas prepared to strike at a later time, and the <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/time_stamp.nim#L176-L202">typical self unit testing code</a>:</p>
<p><pre class='code'><span class="Identifier">echo</span> <span class="StringLit">&quot;Testing stamps</span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span>
<span class="Keyword">var</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="RawData">date&quot;2012-01-01&quot;</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;let's start at &quot;</span><span class="Punctuation">,</span> <span class="Identifier">a</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;plus one day is &quot;</span><span class="Punctuation">,</span> <span class="Identifier">a</span> <span class="Operator">+</span> <span class="FloatNumber">1.</span><span class="Identifier">d</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;plus one month is &quot;</span><span class="Punctuation">,</span> <span class="Identifier">a</span> <span class="Operator">+</span> <span class="FloatNumber">1.</span><span class="Identifier">m</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;plus one month and a day is &quot;</span><span class="Punctuation">,</span> <span class="Identifier">a</span> <span class="Operator">+</span> <span class="FloatNumber">1.</span><span class="Identifier">m</span> <span class="Operator">+</span> <span class="FloatNumber">1.</span><span class="Identifier">d</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;…plus 1h15i17s &quot;</span><span class="Punctuation">,</span> <span class="Identifier">a</span> <span class="Operator">+</span> <span class="FloatNumber">1.</span><span class="Identifier">m</span> <span class="Operator">+</span> <span class="FloatNumber">1.</span><span class="Identifier">d</span> <span class="Operator">+</span> <span class="FloatNumber">1.</span><span class="Identifier">h</span> <span class="Operator">+</span> <span class="FloatNumber">15.</span><span class="Identifier">i</span> <span class="Operator">+</span> <span class="FloatNumber">17.</span><span class="Identifier">s</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;…plus 23 hours &quot;</span><span class="Punctuation">,</span> <span class="Identifier">a</span> <span class="Operator">+</span> <span class="FloatNumber">1.</span><span class="Identifier">m</span> <span class="Operator">+</span> <span class="FloatNumber">2.</span><span class="Identifier">d</span> <span class="Operator">-</span> <span class="FloatNumber">1.</span><span class="Identifier">h</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;2001.01.01T01&quot;</span><span class="Operator">.</span><span class="Identifier">date</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;2001.01.01T02:01&quot;</span><span class="Operator">.</span><span class="Identifier">date</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;2001.01.01T03:02:01&quot;</span><span class="Operator">.</span><span class="Identifier">date</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;2001.01.01T04:09:02.1&quot;</span><span class="Operator">.</span><span class="Identifier">date</span>
<span class="Identifier">echo</span> <span class="RawData">date&quot;2001.01.01T04:09:02.12&quot;</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;2001.01.01T04:09:02.123&quot;</span><span class="Operator">.</span><span class="Identifier">date</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;2001.01.01T05:04:03.0123&quot;</span><span class="Operator">.</span><span class="Identifier">date</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;2001.01.01T06:05:04.012345678&quot;</span><span class="Operator">.</span><span class="Identifier">date</span>
<span class="Identifier">a</span> <span class="Operator">=</span> <span class="StringLit">&quot;2001.01.01T06:05:04.012345678&quot;</span><span class="Operator">.</span><span class="Identifier">date</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\t</span><span class="StringLit">year &quot;</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">year</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\t</span><span class="StringLit">month &quot;</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">month</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\t</span><span class="StringLit">day &quot;</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">day</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\t</span><span class="StringLit">hour &quot;</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">hour</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\t</span><span class="StringLit">minute &quot;</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">minute</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\t</span><span class="StringLit">second &quot;</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">second</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\t</span><span class="StringLit">microsecond &quot;</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">microsecond</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\t</span><span class="StringLit">millisecond &quot;</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">millisecond</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\t</span><span class="StringLit">nanosecond &quot;</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">nanosecond</span>
</pre></p>
<p>The output of this code would be:</p>
<p><pre class='code'>
Testing stamps

let's start at 2012.01.01
plus one day is 2012.01.02
plus one month is 2012.02.01
plus one month and a day is 2012.02.02
…plus 1h15i17s 2012.02.02T01:15:17
…plus 23 hours 2012.02.02T23:00:00
2001.01.01T01:00:00
2001.01.01T02:01:00
2001.01.01T03:02:01
2001.01.01T04:09:02.100000000
2001.01.01T04:09:02.120000000
2001.01.01T04:09:02.123000000
2001.01.01T05:04:03.012300000
2001.01.01T06:05:04.012345678
        year 2001
        month 1
        day 1
        hour 6
        minute 5
        second 4
        microsecond 12345
        millisecond 12
        nanosecond 12345678
</pre></p>
<p>As you can see this is just normal exercising of the code to verify visually that nothing terrible is going on. With this module in place we can finally emulate the Kerf examples set as our goal in the first chapter.</p>

<br clear="right"><center>
<a href="http://arcturus127.tistory.com/801"><img
    src="../../../i/kerf_wall_of_text.jpg"
    alt="Finally, I thought the wall of text would never end"
    style="width:100%;max-width:750px" align="center"
    hspace="8pt" vspace="8pt"></a>
</center><h2>The Kerf comparison test</h2><p>Let's create a new file named <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/units.nim">units.nim</a> from which we will test everything. Running the compiler with <code>nim c -r units.nim</code> is enough to get the output of the individual self unit testing already shown plus the following lines:</p>
<p><pre class='code'>
Showing blog examples.

Example 1: 2012.01.01
Example 2:
        2012.01.02
        2012.01.02
Example 3: 2012.02.02T01:15:17
Example 4: @[2012.01.01, 2012.02.02T01:15:17, 2012.03.03T02:30:34, 2012.04.04T03:45:51, 2012.05.05T05:01:08, 2012.06.06T06:16:25, 2012.07.07T07:31:42, 2012.08.08T08:46:59, 2012.09.09T10:02:16, 2012.10.10T11:17:33]
…again but compressed… @[2012.01.01, 2012.02.02T01:15:17, 2012.03.03T02:30:34, 2012.04.04T03:45:51, 2012.05.05T05:01:08, 2012.06.06T06:16:25, 2012.07.07T07:31:42, 2012.08.08T08:46:59, 2012.09.09T10:02:16, 2012.10.10T11:17:33]
…using helper procs… @[2012.01.01, 2012.02.02T01:15:17, 2012.03.03T02:30:34, 2012.04.04T03:45:51, 2012.05.05T05:01:08, 2012.06.06T06:16:25, 2012.07.07T07:31:42, 2012.08.08T08:46:59, 2012.09.09T10:02:16, 2012.10.10T11:17:33]
Example 5 b[week]: @[1, 5, 9, 14, 18, 23, 27, 32, 36, 40]
Example 5 b[second]: @[0, 17, 34, 51, 8, 25, 42, 59, 16, 33]
Extra points b[bonusWeek]: @[^1^, ^5^, ^9^, ^14^, ^18^, ^23^, ^27^, ^32^, ^36^, ^40^]

Did all examples.
</pre></p>
<p>The <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/units.nim#L9-L14">first three examples</a> have already been explained. The fourth example has been split in three versions which were the ones I wrote to approximate the final one. <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/units.nim#L16-L21">The first is the verbose one</a>:</p>
<p><pre class='code'><span class="Keyword">let</span>
  <span class="Identifier">r</span> <span class="Operator">=</span> <span class="Identifier">to_seq</span><span class="Punctuation">(</span><span class="DecNumber">0</span> <span class="Operator">..</span> <span class="Operator">&lt;</span><span class="DecNumber">10</span><span class="Punctuation">)</span>
  <span class="Identifier">offsets</span> <span class="Operator">=</span> <span class="Identifier">r</span><span class="Operator">.</span><span class="Identifier">map_it</span><span class="Punctuation">(</span><span class="Identifier">Nano</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="FloatNumber">1.</span><span class="Identifier">m</span> <span class="Operator">+</span> <span class="FloatNumber">1.</span><span class="Identifier">d</span> <span class="Operator">+</span> <span class="FloatNumber">1.</span><span class="Identifier">h</span> <span class="Operator">+</span> <span class="FloatNumber">15.</span><span class="Identifier">i</span> <span class="Operator">+</span> <span class="FloatNumber">17.</span><span class="Identifier">s</span><span class="Punctuation">)</span> <span class="Operator">*</span> <span class="Identifier">it</span><span class="Punctuation">)</span>
  <span class="Identifier">values</span> <span class="Operator">=</span> <span class="Identifier">offsets</span><span class="Operator">.</span><span class="Identifier">map_it</span><span class="Punctuation">(</span><span class="Identifier">Stamp</span><span class="Punctuation">,</span> <span class="RawData">d&quot;2012.01.01&quot;</span> <span class="Operator">+</span> <span class="Identifier">it</span><span class="Punctuation">)</span>

<span class="Identifier">echo</span> <span class="StringLit">&quot;Example 4: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">values</span>
</pre></p>
<p>This is pretty verbose compared to the Kerf version, but it's easier to start from here to understand what is going on. The first assignment creates a sequence variable from a range using <a href="http://nim-lang.org/docs/sequtils.html#toSeq">sequtils.toSeq()</a>. The second line uses <a href="http://nim-lang.org/docs/sequtils.html#mapIt">sequtils.mapIt()</a> to apply or map some code to each of its elements and return a new sequence. Here we have the template injected <code>it</code> variable representing each entry in the sequence, which is multiplied against a <code>Nano</code> type (side note: this is old Nim style, as mentioned in the documentation newer Nim 0.13 versions don't require specifying the type of the returned items as first parameter of <code>mapIt()</code> because the type is inferred properly by the compiler). The <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/units.nim#L23-L25">second version is simply an attempt to put it all in a single big expression</a>:</p>
<p><pre class='code'><span class="Identifier">echo</span> <span class="StringLit">&quot;…again but compressed… &quot;</span><span class="Punctuation">,</span> <span class="Identifier">to_seq</span><span class="Punctuation">(</span><span class="DecNumber">0</span> <span class="Operator">..</span> <span class="Operator">&lt;</span><span class="DecNumber">10</span><span class="Punctuation">)</span>
    <span class="Operator">.</span><span class="Identifier">map_it</span><span class="Punctuation">(</span><span class="Identifier">Nano</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="FloatNumber">1.</span><span class="Identifier">m</span> <span class="Operator">+</span> <span class="FloatNumber">1.</span><span class="Identifier">d</span> <span class="Operator">+</span> <span class="FloatNumber">1.</span><span class="Identifier">h</span> <span class="Operator">+</span> <span class="FloatNumber">15.</span><span class="Identifier">i</span> <span class="Operator">+</span> <span class="FloatNumber">17.</span><span class="Identifier">s</span><span class="Punctuation">)</span> <span class="Operator">*</span> <span class="Identifier">it</span><span class="Punctuation">)</span>
    <span class="Operator">.</span><span class="Identifier">map_it</span><span class="Punctuation">(</span><span class="Identifier">Stamp</span><span class="Punctuation">,</span> <span class="StringLit">&quot;2012.01.01&quot;</span><span class="Operator">.</span><span class="Identifier">date</span> <span class="Operator">+</span> <span class="Identifier">it</span><span class="Punctuation">)</span>
</pre></p>
<p>Quite boring stuff, this uses the typical object oriented dot notation continuations where a long line expression is broken into multiple lines because the parser allows you to do so placing the dot as the first non white space character on the next line. The problem here is that we can't get rid of the two <code>mapIt()</code> calls which are verbose. Or can we? Yes, we can! With help from additional operator overloading we can reach <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/units.nim#L27-L28">the final form</a>:</p>
<p><pre class='code'><span class="Identifier">echo</span> <span class="StringLit">&quot;…using helper procs… &quot;</span><span class="Punctuation">,</span>
  <span class="RawData">d&quot;2012.01.01&quot;</span> <span class="Operator">+</span> <span class="Punctuation">(</span><span class="FloatNumber">1.</span><span class="Identifier">m</span> <span class="Operator">+</span> <span class="FloatNumber">1.</span><span class="Identifier">d</span> <span class="Operator">+</span> <span class="FloatNumber">1.</span><span class="Identifier">h</span> <span class="Operator">+</span> <span class="FloatNumber">15.</span><span class="Identifier">i</span> <span class="Operator">+</span> <span class="FloatNumber">17.</span><span class="Identifier">s</span><span class="Punctuation">)</span> <span class="Operator">*</span> <span class="Punctuation">(</span><span class="DecNumber">0</span> <span class="Operator">..</span> <span class="Operator">&lt;</span><span class="DecNumber">10</span><span class="Punctuation">)</span>
</pre></p>
<p>What we have here is overloading of the <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/time_nanos.nim#L132-L139">multiplication proc with a slice of integers</a>:</p>
<p><pre class='code'><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Nano</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Slice</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">Nano</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Keyword">let</span> <span class="Identifier">total_len</span> <span class="Operator">=</span> <span class="Identifier">y</span><span class="Operator">.</span><span class="Identifier">b</span> <span class="Operator">-</span> <span class="Identifier">y</span><span class="Operator">.</span><span class="Identifier">a</span> <span class="Operator">+</span> <span class="DecNumber">1</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">new_seq</span><span class="Punctuation">(</span><span class="Identifier">total_len</span><span class="Punctuation">)</span>
  <span class="Keyword">var</span> <span class="Identifier">pos</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Keyword">while</span> <span class="Identifier">pos</span> <span class="Operator">&lt;</span> <span class="Identifier">total_len</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span><span class="Punctuation">[</span><span class="Identifier">pos</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">pos</span> <span class="Operator">+</span> <span class="Identifier">y</span><span class="Operator">.</span><span class="Identifier">a</span><span class="Punctuation">)</span>
    <span class="Identifier">pos</span><span class="Operator">.</span><span class="Identifier">inc</span>
</pre></p>
<p>The helper takes a <code>Nano</code> and <span style="font-style: italic;">multiplies</span> it against the slice, returning a new sequence. This sequence is then mapped against an overload of the <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/time_stamp.nim#L158-L164">addition operator between Stamps and sequence of Nanos</a>:</p>
<p><pre class='code'><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Stamp</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">Nano</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">Stamp</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">new_seq</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">)</span>
  <span class="Keyword">var</span> <span class="Identifier">pos</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Keyword">while</span> <span class="Identifier">pos</span> <span class="Operator">&lt;</span> <span class="Identifier">y</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span><span class="Punctuation">[</span><span class="Identifier">pos</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span><span class="Punctuation">[</span><span class="Identifier">pos</span><span class="Punctuation">]</span>
    <span class="Identifier">pos</span><span class="Operator">.</span><span class="Identifier">inc</span>
</pre></p>
<p>In a similar way to the multiplication operator, another list is constructed applying the addition of each element to the input <code>Stamp</code> value, returning the final result. Here is the original Kerf version we wanted to compete with:</p>
<p><pre class='code'>
KeRF&gt; b: 2012.01.01 + (1m1d + 1h15i17s) times mapright  range(10)
Nim&gt;  let b = d&quot;2012.01.01&quot; + (1.m + 1.d + 1.h + 15.i + 17.s) * (0 .. &lt;10)
</pre></p>
<p>Some verbosity due to the lack of real custom syntax is recovered through the overloading of the operators to avoid having to write <code>times mapright range(10)</code>, but all in all the result is quite the same in readability. If you don't like operators you could use names as in Kerf, remember that there is nothing special about writing an operator in Nim, it's just a proc with two parameters. The <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/units.nim#L30-L31">last bit of the example may throw you off</a>:</p>
<p><pre class='code'><span class="Identifier">echo</span> <span class="StringLit">&quot;Example 5 b[week]: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">values</span><span class="Punctuation">[</span><span class="Identifier">week</span><span class="Punctuation">]</span>
<span class="Comment"># Example 5 b[week]: @[1, 5, 9, 14, 18, 23, 27, 32, 36, 40]</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;Example 5 b[second]: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">values</span><span class="Punctuation">[</span><span class="Identifier">second</span><span class="Punctuation">]</span>
<span class="Comment"># Example 5 b[second]: @[0, 17, 34, 51, 8, 25, 42, 59, 16, 33]</span>
</pre></p>
<p>If we compare the numbers to the Kerf version it doesn't match:</p>
<p><pre class='code'>
b['week']
  [1, 6, 10, 15, 19, 24, 28, 33, 37, 42]
b['second']
  [0, 17, 34, 51, 8, 25, 42, 59, 16, 33]
</pre></p>
<p>Remember when I quickly and naively implemented the <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/time_nanos.nim#L54-L57">week() date component getter</a>? I explicitly <span style="font-weight: bold;">did not</span> implement real calendars because that is boring. So if you look at the calendar you will see that the differences between Keft and my Nim implementation is that the first week of 2012 starts on the 2nd day of January and not on the 8th day like the simple implementation presumes. A real implementation would do this right and the Nim output would then equal Kerfs.</p>
<h2>Bonus generic subscript operator</h2><p>The last lines of the Nim implementation use a <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/units.nim#L4">bonusWeek() proc defined earlier</a>:</p>
<p><pre class='code'><span class="Identifier">echo</span> <span class="StringLit">&quot;Extra points b[bonusWeek]: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">values</span><span class="Punctuation">[</span><span class="Identifier">bonusWeek</span><span class="Punctuation">]</span>
<span class="Comment"># Extra points b[bonusWeek]: @[^1^, ^5^, ^9^, ^14^, ^18^, ^23^, ^27^, ^32^, ^36^, ^40^]</span>
</pre></p>
<p>Let's explain first that what we are doing here is <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/time_stamp.nim#L167-L173">overloading the subscript operator for sequences</a>:</p>
<p><pre class='code'><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">S</span><span class="Punctuation">,</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">S</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">filter</span><span class="Punctuation">:</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">S</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">new_seq</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">)</span>
  <span class="Keyword">var</span> <span class="Identifier">pos</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Keyword">while</span> <span class="Identifier">pos</span> <span class="Operator">&lt;</span> <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span><span class="Punctuation">[</span><span class="Identifier">pos</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">filter</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">[</span><span class="Identifier">pos</span><span class="Punctuation">]</span><span class="Punctuation">)</span>
    <span class="Identifier">pos</span><span class="Operator">.</span><span class="Identifier">inc</span>
</pre></p>
<p>Hey! Where did <code>Stamp</code> and <code>Nano</code> go?  That's right, the <code>S</code> and <code>T</code> are generic types, that proc definition applies to anything that will match the signature. So what it is doing is that for sequences of type <code>S</code>, the parameter will be applied to each entry and a new sequence returned. We have just reimplemented the <code>mapIt()</code> template. The <code>filter</code> parameter requires that the proc accepts an <code>S</code> type as input and generates a <code>T</code> type. And you know what does that? Yes, the date component getters we implemented before. All those returned integers, <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/time_stamp.nim#L25-L34">remember</a>? The <a href="https://github.com/gradha/kerf_timestamps_done_almost_right/blob/master/nim/units.nim#L4">bonusWeek() proc returns strings instead</a> and that's fine because supporting generics the compiler will generate the procs with the appropriate types time during compilation.</p>
<p>This is what I meant in the previous chapter about a potential Kerf design mistake or limitation: Kerf seems to overload the subscript operator for sequences but uses an input string as parameter. Since Kerf claims to be interpreted maybe this doesn't pose a problem, the interpreter can look in the environment and match against any function with the specified name. But it feels odd, as if their implementation used a big ass string switch, which would users prevent from customizing the operations to filter the sequence.  Who knows, it's not really that important in the grand scheme of things.</p>
<h2>Conclusion</h2><p>What is important is that with a generic programming language we have matched the feature set of Kerf's native timestamp type, plus we can implement it in different ways not limiting ourselves to a niche. Or rather the genericness of the language supports any design requirements by the programmers using it, allowing them to implement new types as needed in search of the optimal performance.</p>
<p>Does then our timestamp type have <span style="font-weight: bold;">anything</span> to do with storing dates or ticks in a database? Nope. The type uses an integer storing nanoseconds, but by the time we write to the database in our serialization layer we could be storing it <a href="http://www.emojicode.org/docs/guides/compile-and-run.html">encoded in emoji</a> just for fun and to annoy other people. It would be a really poor storage decision, and Scott would loudly complain about Unicode conversion performance bottlenecks, but it wouldn't hurt the type at all in the language. Next <a href="kerf-timestamps-done-almost-right-c-plus--plus-.html">we will do this in C++</a> (I mean the Kerf timestamp, not the weird emoji shit).</p>

<br clear="right"><center>
<a href="http://www.idol-grapher.com/1239"><img
    src="../../../i/kerf_emoji.jpg"
    alt="Don't talk to me, talk to the emoji"
    style="width:100%;max-width:600px" align="center"
    hspace="8pt" vspace="8pt"></a>
</center>
	</div>
		<hr>
		<p>See <a href="../../../index.html">the article index</a> or browse
		articles by tags:     <a href="../../../tags/design.html">design</a>
    ,
    <a href="../../../tags/nim.html">nim</a>
    ,
    <a href="../../../tags/java.html">java</a>
    ,
    <a href="../../../tags/cpp.html">cpp</a>
    ,
    <a href="../../../tags/languages.html">languages</a>
    ,
    <a href="../../../tags/kerf.html">kerf</a>
    ,
    <a href="../../../tags/programming.html">programming</a>
    ,
    <a href="../../../tags/swift.html">swift</a>
    
.<br>Published on: 06/03/2016 22:50. Last update:
			06/03/2016 22:50. <a
			href="../../../feed.xml"><img
			alt="rss feed" src="../../../i/Feed-icon.svg"
			width="18pt" height="18pt"></a><br>
		Copyright 2025 by <a href="../../../about.html">Grzegorz Adam Hankiewicz</a>.<br>
		Generated with <a href="https://github.com/dom96/ipsumgenera">ipsum
			genera</a>. Look at <a
		href="https://github.com/gradha/gradha.github.io">the
		source code</a>.</p>
	</body>
</html>
