<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang='en'>
	<head>
		<title>Prototyping a dumb server for location sharing apps - Rants from the Ballmer Peak</title>
		<meta name="viewport" content="initial-scale=1, maximum-scale=1">
		<link rel="stylesheet" href="../../../css/normalize.css">
		<link rel="stylesheet" href="../../../css/style.css">
		<link href="../../../feed.xml" title="Articles" type="application/atom+xml" rel="alternate">
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	</head>
	<body>
	<div class="content">
		<h3><a href="../../../index.html">Rants from the Ballmer Peak</a> <a
				href="../../../feed.xml"><img
			alt="rss feed" src="../../../i/Feed-icon.svg"
			width="18pt" height="18pt"></a></h3>
		<h1>Prototyping a dumb server for location sharing apps</h1>
<div style="background-color:yellow;float:right;margin:1px"
    ><a href="https://youtu.be/p4tLL59NtZc?t=51"><video autoplay muted loop
    style="width: 166px; height: 166px;"> <source
    src="../../../i/omb_01.mp4" type="video/mp4"
    /> No silly animated videos, good for you!</video></a></div><p>At the beginning of the year 2009 Google created <a href="https://en.wikipedia.org/wiki/Google_Latitude">Google Latitude</a>, which was a service to report your own mobile location to their servers so that other users could see where you are. It is funny to me that I didn't even know such a thing existed until 2010, when one of my previous coworkers released <a href="https://web.archive.org/web/20101027221033/http://www.latitudie.com/">Latitudie</a>, which was an iOS app using Google's Latitude service (I even did buy it and use it for my nefarious purposes!). But you had to wait until the end of 2011 (<a href="https://arstechnica.com/gadgets/2011/04/how-apple-tracks-your-location-without-your-consent-and-why-it-matters/">after possibly the most public false start</a>) for <a href="https://en.wikipedia.org/wiki/Find_My_Friends">Apple to innovate with their Find My Friends app</a>, offering pretty much the same service as Google, except for the fact that you were limited to using Apple devices and, at least at that time, there was no way to view a friend's location on a desktop web browser. Those limitations set the world on fire, and thus a new era of location tracking apps <span style="font-style: italic;">officially</span> emerged.</p>

<div style="background-color:yellow;float:left;margin:1px"
    ><a href="https://www.youtube.com/watch?v=rW9r_1ys2ec"><video autoplay muted loop
    style="width: 166px; height: 166px;"> <source
    src="../../../i/omb_02.mp4" type="video/mp4"
    /> No silly animated videos, good for you!</video></a></div><p>Google closed its service in 2013 (and so had to do my friend), but later embedded the feature directly in their Google Maps app, so that only <span style="font-style: italic;">their</span> official client was able to use <span style="font-style: italic;">their</span> servers. Maybe you weren't aware of it though? If you have a mobile phone with Google Maps you only need to touch the <span style="font-style: italic;">hamburguer</span> menu button on the corner of the screen, and select the <span style="font-weight: bold;">Share my location</span> option. With Apple prominently adding an icon to all their devices, and Google having Maps in most of their Android devices, you would think there was no place for other firms to develop similar apps. But the funny thing about wheels is that just as they don't seem to stop with the appropriate momentum, so do software developers seem to endlessly rewrite them.</p>

<div style="background-color:yellow;float:right;margin:1px"
    ><a href="https://www.youtube.com/watch?v=A5aTxyEdD4k"><video autoplay muted loop
    style="width: 166px; height: 166px;"> <source
    src="../../../i/omb_03.mp4" type="video/mp4"
    /> No silly animated videos, good for you!</video></a></div><p>It is thanks to <a href="https://arstechnica.com/information-technology/2018/03/your-facebook-data-archive-wont-really-show-everything-facebook-knows-about-you/">mishaps like those from Facebook</a> that users are starting to realize <a href="https://www.schneier.com/crypto-gram/archives/2018/0415.html#1">all the services they enjoy might not have been paid for themselves through their uploading of food pictures to whatever social network they use</a>. <a href="http://www.vs.inf.ethz.ch/publ/papers/privacy-principles.pdf">Privacy is a word hard to define</a>, especially since <a href="https://en.wikipedia.org/wiki/Privacy">some cultures don't even have such a word</a>, and what exactly is privacy for a mobile user, who <span style="font-weight: bold;">depends</span> on a server? If you ask the backend developer, privacy might mean to avoid selling or sharing your data to third parties. Maybe it could mean not storing logs or backups of your data forever. But whatever concession is made and sold to you, the server <span style="font-style: italic;">wants to access</span> your data, and you build an implicit trust relationship with it.</p>

<div style="background-color:yellow;float:left;margin:1px"
    ><a href="https://youtu.be/Lqa8e0r5uI8?t=14"><video autoplay muted loop
    style="width: 166px; height: 166px;"> <source
    src="../../../i/omb_04.mp4" type="video/mp4"
    /> No silly animated videos, good for you!</video></a></div><p>Is it possible to build a service similar to Google's Latitude or Apple's Find My Friends which respects the privacy of its users? Even if you <span style="font-style: italic;">trust</span> a company, <a href="https://techcrunch.com/2010/09/14/google-engineer-spying-fired/">can you trust all the people ever employed there</a>, when some people have trouble trusting their own family members? In such cases, the best would be to avoid a server at all and develop something maybe using a <a href="https://en.wikipedia.org/wiki/Distributed_hash_table">distributed hash table</a>. Unfortunately decentralized algorithms tend to penalize mobile users, since they usually consume more bandwidth, having a negative effect on battery life and possibly monthly bandwidth allowance. The middle ground solution is to build a server as dumb as it possibly is: the less it knows, the better for your privacy.</p>
<h2>Requirements</h2>
<div style="background-color:yellow;float:right;margin:1px"
    ><a href="https://youtu.be/DVZ1GDc634o?t=33"><video autoplay muted loop
    style="width: 166px; height: 166px;"> <source
    src="../../../i/omb_05.mp4" type="video/mp4"
    /> No silly animated videos, good for you!</video></a></div><p>What I will outline in the rest of this article are my personal requirements for configuration and operation of a server working as location relay to different mobile users. It is unlikely to stop <a href="https://www.nsa.gov">state level surveillance</a>, but at least it should make it fairly difficult for not very interested parties in learning about your location, increasing the work required to invade your privacy and thus making the attacker go look for easier prey. Since the purpose is having a server somewhere we don't trust, all the communication will go encrypted (I'm not inventing anything here, just borrowing from <a href="https://libsodium.org">the Sodium crypto library</a>) and the server itself will merely serve as a message relay point. Where the server is located doesn't really matter, it could be <a href="https://cloud.google.com/appengine/">Google App Engine</a>, a mobile oriented service like <a href="https://pusher.com">Pusher</a>, or a custom server hosted on the <a href="https://sandstorm.io">Sandstorm platform</a>.</p>

<div style="background-color:yellow;float:left;margin:1px"
    ><a href="https://youtu.be/ZAeNaWv8V7o?t=32"><video autoplay muted loop
    style="width: 166px; height: 166px;"> <source
    src="../../../i/omb_06.mp4" type="video/mp4"
    /> No silly animated videos, good for you!</video></a></div><p>The main requirement is to avoid giving up on two things to the server: our social network, and our location. The social network is essentially the list of people in our address book, telephonic or otherwise. To shortcut problems with this we can piggyback on existing secure messaging platforms like <a href="https://wiki.tox.chat/">Tox</a>, <a href="https://signal.org/blog/private-contact-discovery/">Signal</a>, <a href="https://www.whatsapp.com">Whatsapp</a> or <a href="https://threema.ch/en/">Threema</a>. Our dumb server will be used to relay our position to other parties, but those will join us using one of these communication networks, there is no need to reinvent <span style="font-weight: bold;">that</span> wheel. For instance, to start broadcasting our position to other users, we will generate a blob of data, encoded in a URL or file, which we will send to them through these <span style="font-style: italic;">alternate communications channel</span>, and it will contain all the necessary information to join the location server.</p>
<p>While I have in mind implementing real time communication with something similar to <a href="https://en.wikipedia.org/wiki/WebSocket">websockets</a>, there is nothing specific to websockets in the design, you could as well implement it over <a href="https://en.wikipedia.org/wiki/IP_over_Avian_Carriers">avian carriers</a> (if you can stomach the latency).  The first important step is starting a position broadcast and sharing it with others, which requires:</p>

<div style="background-color:yellow;float:right;margin:1px"
    ><a href="https://www.youtube.com/watch?v=0liD6Jv5JuE"><video autoplay muted loop
    style="width: 166px; height: 166px;"> <source
    src="../../../i/omb_07.mp4" type="video/mp4"
    /> No silly animated videos, good for you!</video></a></div><ul><li>Information about the message relay server and its configuration, usually a URL.</li><li>Session identifier or chat name. The server can be used by multiple users at the same time, so this identifier restricts communication to just its users. It is very easy to construct this value through a <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">universally unique identifier (UUID)</a>, but it could as well be completely 128 bits of randomness. Knowing this identifier means being able to listen and read all the messages sent between the parties. Each session will have a new value, which is enough to conceal our broadcast from other users, but we need something more to conceal our position from the listening server itself.</li><li>Symmetric encryption key. The same key will be used to encrypt all the messages through the active session. Sessions are meant to be short lived (sharing your location for 15 minutes, or maybe a few hours), and creating a new broadcast (or even broadcasting to two sets of different people at the same time!) will create a new symmetric key. Most messages will be a simple JSON with the encrypted payload.</li></ul>
<div style="background-color:yellow;float:left;margin:1px"
    ><a href="https://youtu.be/VB3GLxDpjVM?t=163"><video autoplay muted loop
    style="width: 166px; height: 166px;"> <source
    src="../../../i/omb_08.mp4" type="video/mp4"
    /> No silly animated videos, good for you!</video></a></div><p>Example of URL:</p>
<pre class='literal'>https://server.com:1234/some_path?s=&lt;session id&gt;#&lt;encryption key&gt;</pre><p>There is no creation or destruction of a chat, or session id, meaning there is no way for the server or its users know if a broadcast is going on, finished, didn't yet start, etc. Giving a 404 for a bad session identifier is an information leak we don't need.</p>
<p>Whenever a client connects to a session, that client is assigned a random 32bit integer user identifier, which is broadcast to other listening users for them to know somebody has joined. This identifier can be used in more advanced setups to authenticate users, but for the moment let's presume all users are simply random and anonymous. A client being disconnected will get a new random value the next time he joins. The messages client machines will exchange with the server are in plaintext JSON:</p>

<div style="background-color:yellow;float:right;margin:1px"
    ><a href="https://youtu.be/PY_71_zD6tw?t=12"><video autoplay muted loop
    style="width: 166px; height: 166px;"> <source
    src="../../../i/omb_09.mp4" type="video/mp4"
    /> No silly animated videos, good for you!</video></a></div><ul><li><p><code>{&quot;a&quot;: &quot;logged_in&quot;, &quot;id&quot;: 32bit, &quot;t&quot;: 64bit}</code></p>
<p>Message received by a new user connecting to a session. From that moment on the specified <code>id</code> will be used for the rest of the connection. The <code>t</code> value contains the current server time in milliseconds since the Unix epoch. Future messages generated by clients should use this value + the time since they joined for each message, which will help with the encrypting.</p>
</li><li><p><code>{&quot;a&quot;: &quot;new_user&quot;, &quot;id&quot;: 32bit}</code></p>
<p>Message sent by the server to other users, they can update their list of members in the chat.</p>
</li></ul>
<div style="background-color:yellow;float:left;margin:1px"
    ><a href="https://youtu.be/MPOtEIhikxU?t=25"><video autoplay muted loop
    style="width: 166px; height: 166px;"> <source
    src="../../../i/omb_10.mp4" type="video/mp4"
    /> No silly animated videos, good for you!</video></a></div><ul><li><p><code>{&quot;a&quot;: &quot;logged_out&quot;, &quot;id&quot;: 32bit}</code></p>
<p>Message sent by the server to whoever is listening indicating that the specified <code>id</code> is no longer valid and won't accept connections. It is possible for a reconnecting user to get their previous id, but this shouldn't be expected.</p>
</li><li><p><code>{&quot;a&quot;: &quot;pos&quot;, &quot;lat&quot;: float, &quot;lon&quot;: float}</code></p>
<p>Message sent by whoever is willing to broadcast their position. This message will actually be encrypted (see below) and the wrapper will contain the identifier of the sender.  The identifier is used by listening clients to overwrite the previous known position of that user, as well as decrypt the message.</p>
</li></ul>
<div style="background-color:yellow;float:right;margin:1px"
    ><a href="https://www.youtube.com/watch?v=tdE9YQKYMik"><video autoplay muted loop
    style="width: 166px; height: 166px;"> <source
    src="../../../i/omb_11.mp4" type="video/mp4"
    /> No silly animated videos, good for you!</video></a></div><p>And that's it! What else could we want from a minimally viable location broadcasting project expect, anyway. The <code>logged_in</code>, <code>logged_out</code> and <code>new_user</code> messages are sent by the server unencrypted, but  <code>pos</code> packets will be sent <span style="font-style: italic;">encrypted</span> in a wrapper JSON with the following form:</p>
<ul><li><p><code>{&quot;p&quot;: &quot;base64 encrypted string&quot;, &quot;t&quot;: 64bit, &quot;from&quot;: 32bit[, &quot;to&quot;: 32bit]}</code>:</p>
<p>This is what all the listeners to the session will see, a basic payload packet where the base64 encoded string has to be decrypted with the symmetric session key. All the listeners receive the message (except whoever sent it), unless the <code>to</code> field is present, in which case the message is sent only to the addressed user. Delivery is never guaranteed. The <code>from</code> value is inserted by the server (or overwritten if it exists) and identifies the source of the message.</p>
<p>The <code>t</code> value should be the server's received value during login + the current elapsed time when generating the encrypted message. This value exists mostly to help the symmetric encryption algorithm, which will be explained later below, and is used as part of a nonce to avoid message repetition.</p>
</li></ul>
<div style="background-color:yellow;float:left;margin:1px"
    ><a href="https://youtu.be/Wo38Rz0iBgw?t=198"><video autoplay muted loop
    style="width: 166px; height: 166px;"> <source
    src="../../../i/omb_12.mp4" type="video/mp4"
    /> No silly animated videos, good for you!</video></a></div><p>The server will simply relay all the messages with a <code>p</code> without doing anything else with it.  With all this setup what we end up with is a server which doesn't even perform any authentication, authorization or storage at all, it simply forwards messages here and there to whoever is listening. Starting from this base experiment we can keep adding features, as long as they don't reduce the privacy we have achieved so far. The server can't know who we are or where we are with great precision, they can still know our approximate IP geolocation, which is information your cell phone provider can also provide to say law enforcement.  Should this be a concern, you can hide your real IP with a <a href="https://en.wikipedia.org/wiki/Virtual_private_network">VPN service</a> like <a href="https://www.tunnelbear.com">TunnelBear</a> or a <a href="https://www.torproject.org">Tor connection</a> like the <a href="https://guardianproject.info/apps/orbot/">Orbot</a> proxy.</p>
<h2>The initial libsodium prototype</h2>
<div style="background-color:yellow;float:right;margin:1px"
    ><a href="https://youtu.be/_7xk5pBSiYo?t=56"><video autoplay muted loop
    style="width: 166px; height: 166px;"> <source
    src="../../../i/omb_13.mp4" type="video/mp4"
    /> No silly animated videos, good for you!</video></a></div><p>To verify that the above makes some sense, let's start creating a simple C example using libsodium to simulate the creation of a session on a non existent server and a few users talking to each other using the previous protocol. The only reason this can't be made directly on paper is the part where libsodium takes place doing it's magic crypto stuff. You can grab the source code from <a href="https://gitlab.com/gradha/prototyping-a-dumb-server-for-location-sharing-apps/">https://gitlab.com/gradha/prototyping-a-dumb-server-for-location-sharing-apps/</a>, it contains a basic <code>Makefile</code> which uses a local custom path for the libsodium library, so if you have installed libsodium globally it is easier for you to simply run <code>gcc -o test -lsodium *.c</code> to compile it. Anyway, here is the output <a href="https://gitlab.com/gradha/prototyping-a-dumb-server-for-location-sharing-apps/blob/master/simulate.c">form the program</a> in case you don't <span style="font-style: italic;">trust</span> running it yourself:<pre class='literal'>
Got session id ebee376ba1bc15ea36924ad4726a373a (base64: 6+43a6G8Feo2kkrUcmo3Og==)
The encryption key is c53d8859946acbcd1688c3bfec351c8d8d96a838e5f7e3566e702d7d6044c994 (base64: xT2IWZRqy80WiMO/7DUcjY2WqDjl9+NWbnAtfWBEyZQ=)
A hypothetical URL for web clients could be:
    https://server.com:1234/path?s=ebee376ba1bc15ea36924ad4726a373a#ebee376ba1bc15ea36924ad4726a373ac53d8859946acbcd1688c3bfec351c8d

{'a': 'logged_in', 'id': 6050335, 't': 1535922234440000}
{'a': 'logged_in', 'id': 13250510, 't': 1540391876920000}
to client 6050335: {'a': 'new_user', 'id': 13250510}
{'a': 'logged_in', 'id': 103415, 't': 1544861519400000}
to client 6050335: {'a': 'new_user', 'id': 103415}
to client 13250510: {'a': 'new_user', 'id': 103415}
Client ids: 1:6050335, 2:13250510: 3:103415

client 6050335 wants to send: {'a': 'pos', 'lat': 43.200001, 'lon': 15.935000}
The encrypted payload is 65 bytes:
    hex: 563b8e66a1dc501c184912202df335655889f770f30febb57cb17aad1607dc6cac4691fc8c7ae80942c77d04092aa0becd8826aa28b8c08b057e7eb5a167b5c4c3
    base64: VjuOZqHcUBwYSRIgLfM1ZViJ93DzD+u1fLF6rRYH3GysRpH8jHroCULHfQQJKqC+zYgmqii4wIsFfn61oWe1xMM=
Server received encrypted JSON: {'p': 'VjuOZqHcUBwYSRIgLfM1ZViJ93DzD+u1fLF6rRYH3GysRpH8jHroCULHfQQJKqC+zYgmqii4wIsFfn61oWe1xMM=', 't': 1544861519400, 'from': 6050335}
    JSON sent to client 13250510
    JSON sent to client 103415
Client decrypted '{'a': 'pos', 'lat': 43.200001, 'lon': 15.935000}'

secretbox bytes 32
secretbox nonce bytes 24
secretbox mac bytes 16
Simulate EOF</pre></p>

<div style="background-color:yellow;float:left;margin:1px"
    ><a href="https://youtu.be/kCXW5qYalgY?t=137"><video autoplay muted loop
    style="width: 166px; height: 166px;"> <source
    src="../../../i/omb_14.mp4" type="video/mp4"
    /> No silly animated videos, good for you!</video></a></div><p>As you can see most binary outputs are displayed in hexadecimal, and some of them are also base64 encoded, which is a way of embedding binary data into plaintext like JSON formats. The first block shows that the libsodium <a href="https://download.libsodium.org/doc/generating_random_data/">randombytes_buf() function</a> is used to generate both the session identifier <span style="font-weight: bold;">and</span> the encryption key. As mentioned above, the session key emulates a UUID 128bit value (16 bytes), which should be enough to avoid <span style="font-style: italic;">outside</span> stalkers to enter the same chat by chance and listen, but even if they do, or the server is <span style="font-weight: bold;">evil</span>, there is also the symmetric encryption key, whose length is 32 bytes, which is the value of the <code>crypto_secretbox_KEYBYTES</code> constant. The hypothetical URL shows how the secret could be <span style="font-style: italic;">safely</span> sent to other users. Presuming this URL is opened with a web browser, this hypothetical web page would use some JavaScript trickery to connect through a websocket to the server, open the channel, and use the specified encryption key after the hash. Why after? So that the browser doesn't accidentally send it to the server along the other parameters to remain in some log file for later decryption. In fact, everything could be after the hash. If the server is <span style="font-style: italic;">evil</span>, we are dead though, since the web browser is getting the JavaScript from this evil source and who knows what it is doing.</p>
<p>The second block shows the typical login/join behaviour:<pre class='literal'>
{'a': 'logged_in', 'id': 6050335, 't': 1535922234440000}
{'a': 'logged_in', 'id': 13250510, 't': 1540391876920000}
to client 6050335: {'a': 'new_user', 'id': 13250510}
{'a': 'logged_in', 'id': 103415, 't': 1544861519400000}
to client 6050335: {'a': 'new_user', 'id': 103415}
to client 13250510: {'a': 'new_user', 'id': 103415}
Client ids: 1:6050335, 2:13250510: 3:103415</pre></p>

<div style="background-color:yellow;float:right;margin:1px"
    ><a href="https://youtu.be/nr6W6ZRBKXs?t=96"><video autoplay muted loop
    style="width: 166px; height: 166px;"> <source
    src="../../../i/omb_15.mp4" type="video/mp4"
    /> No silly animated videos, good for you!</video></a></div><p>The first client joins the session and is assigned the id 6050335. The second client joins the chat and gets assigned the id 13250510. This event is broadcast by the server to the first already logged in client. The same dance happens with the login of the third client, assigned id 103415. The last line shows the assigned identifiers together. Every run of the simulation will give you different identifiers, just like it generates different session identifiers and encryption keys.</p>
<p>All the encryption/decryption goodness is in the third block:<pre class='literal'>
client 6050335 wants to send: {'a': 'pos', 'lat': 43.200001, 'lon': 15.935000}
The encrypted payload is 65 bytes:
    hex: 563b8e66a1dc501c184912202df335655889f770f30febb57cb17aad1607dc6cac4691fc8c7ae80942c77d04092aa0becd8826aa28b8c08b057e7eb5a167b5c4c3
    base64: VjuOZqHcUBwYSRIgLfM1ZViJ93DzD+u1fLF6rRYH3GysRpH8jHroCULHfQQJKqC+zYgmqii4wIsFfn61oWe1xMM=
Server received encrypted JSON: {'p': 'VjuOZqHcUBwYSRIgLfM1ZViJ93DzD+u1fLF6rRYH3GysRpH8jHroCULHfQQJKqC+zYgmqii4wIsFfn61oWe1xMM=', 't': 1544861519400, 'from': 6050335}
    JSON sent to client 13250510
    JSON sent to client 103415
Client decrypted '{'a': 'pos', 'lat': 43.200001, 'lon': 15.935000}'</pre></p>

<div style="background-color:yellow;float:left;margin:1px"
    ><a href="https://youtu.be/C_3S95ruYe8?t=42"><video autoplay muted loop
    style="width: 166px; height: 166px;"> <source
    src="../../../i/omb_16.mp4" type="video/mp4"
    /> No silly animated videos, good for you!</video></a></div><p>The first client wants to send the position action JSON with the latitude and longitude at the time. The simulation calls the <a href="https://gitlab.com/gradha/prototyping-a-dumb-server-for-location-sharing-apps/blob/master/client.c#L46-76">gen_broadcast_pos() function</a> which generates the plaintext JSON and then encrypts it. The encryption uses the libsodium <a href="https://download.libsodium.org/doc/secret-key_cryptography/authenticated_encryption.html">crypto_secretbox_easy() function</a>, which requires as input parameters the destination where the cipher text will be written, the source plain text, the length of the source plain text (we are saying <span style="font-style: italic;">text</span> here but it really is any sequence of bytes, printable or not), a nonce, and the encryption key. What is the nonce and what do we need it when we already have an encryption key?</p>

<div style="background-color:yellow;float:right;margin:1px"
    ><a href="https://youtu.be/qOEdvexx06Q?t=112"><video autoplay muted loop
    style="width: 166px; height: 166px;"> <source
    src="../../../i/omb_17.mp4" type="video/mp4"
    /> No silly animated videos, good for you!</video></a></div><p>The nonce is essentially an initialization vector used to randomize more the output of the encryption, with the purpose of avoiding replay attacks. Since the same symmetric key is used during a <span style="font-weight: bold;">conversation</span>, a nasty listener could perform a <a href="https://en.wikipedia.org/wiki/Replay_attack">replay attack</a> simply copying the input of a user and sending it to another one. Usually the current time can be used to avoid such attacks, and in this case what we do is generate a nonce from the random chat identifier and time given to us by the server given to us during login. That's what the <a href="https://gitlab.com/gradha/prototyping-a-dumb-server-for-location-sharing-apps/blob/master/client.c#L25-41">gen_nonce() function</a> does. libsodium nonces have a length of 24 bytes and we are only filling 11, so just like we send the encryption key through an external channel to other users we could send a 13 byte nonce prefix to use, which would defeat the server being able to serve us always the same identifier/time during login.</p>

<div style="background-color:yellow;float:left;margin:1px"
    ><a href="https://www.youtube.com/watch?v=8J2lPs39Iic"><video autoplay muted loop
    style="width: 166px; height: 166px;"> <source
    src="../../../i/omb_18.mp4" type="video/mp4"
    /> No silly animated videos, good for you!</video></a></div><p>Once sent, we see that the encrypted JSON is sent to the server, and this is broadcast to the two other listeners. Note how the listeners receive the encrypted payload and the two changing values that make up the nonce for each message (the time and sender identifier). Of course the simulation knows everything and has access to the plaintext JSON, but to verify everything works the <a href="https://gitlab.com/gradha/prototyping-a-dumb-server-for-location-sharing-apps/blob/master/client.c#L84-101">decrypt_message() function</a> takes the message and encryption key and calls libsodium <a href="https://download.libsodium.org/doc/secret-key_cryptography/authenticated_encryption.html">crypto_secretbox_open_easy() function</a> to reverse the decryption. If you modify the simulation program and change a few bytes here or there, or modify the nonce values you should see the function failing.</p>

<div style="background-color:yellow;float:right;margin:1px"
    ><a href="https://youtu.be/qKM3819wLqs?t=98"><video autoplay muted loop
    style="width: 166px; height: 166px;"> <source
    src="../../../i/omb_19.mp4" type="video/mp4"
    /> No silly animated videos, good for you!</video></a></div><p>Finally, the last block of lines shows a few constants which might be of interest. The first line tells us that symmetric encryption keys need to have a length of 32 bytes. The second line tells us that the nonce is 24 bytes long. The last line tells us that <code>crypto_secretbox_MACBYTES</code> is 16 bytes long. When we perform symmetric encryption, unless we use some sort of padding the output should have the same length of bytes as the input. libsodium adds these 16 bytes as a sort of tag which authenticates the encrypted content to verify that it has not been tampered with during the exchange.</p>
<h2>Being user friendly to… users</h2>
<div style="background-color:yellow;float:left;margin:1px"
    ><a href="https://www.youtube.com/watch?v=jlSKz_eSPIw"><video autoplay muted loop
    style="width: 166px; height: 166px;"> <source
    src="../../../i/omb_20.mp4" type="video/mp4"
    /> No silly animated videos, good for you!</video></a></div><p>If we ended up implementing the above, we would have a system where we could use a third party server to relay our position to other users securely as long as the server (and other parties) weren't aware of the encryption key. But anonymous users are not fun at all to display, we would like to see who we are watching or who is watching us as well. Authenticating users is not really difficult at all, once a client has joined the chat and knows the symmetric key, they can access the information flow. At that point, we could have a protocol to ask for/exchange information about ourselves. For example:</p>
<ul><li><p><code>{&quot;a&quot;: &quot;request_info&quot;}</code></p>
<p>When clients join the session they first thing they can do is send this message already encrypted. All the connected users will receive it and send their answer. Existing users can as well send this message to the recently joined user, but instead of sending this message to the whole channel they can use the <code>to</code> optional parameter of the wrapper to direct the message to the new id.</p>
</li></ul>
<div style="background-color:yellow;float:right;margin:1px"
    ><a href="https://youtu.be/DK895XQPzWQ?t=16"><video autoplay muted loop
    style="width: 166px; height: 166px;"> <source
    src="../../../i/omb_21.mp4" type="video/mp4"
    /> No silly animated videos, good for you!</video></a></div><ul><li><p><code>{&quot;a&quot;: &quot;user_info&quot;, name: string, &quot;static_id&quot;: 64bit}</code></p>
<p>This answer, always directed at a specific user with the unencrypted wrapper <code>to</code> field, would contain the information about the user to display on the web or the mobile client, at least a name to make it more human friendly. The useful bit could be the <code>static_id</code> field. Since mobile applications will at some point lose their connection to the server, and our dumb server is designed to generate a new chat identifier for each login, it might be annoying to track the position of the same user uniquely. During the first login, clients could assign themselves a static identifier and reuse it for all the connections. This static identifier could be appended to the previous messages, like the position message.</p>
<p>In addition to the name, more information about the user could be sent, like the hash of an image which would later be requested to be sent and displayed as avatar… but then we start getting into useless UI details, like how we send the image, or what do we do if the user changes it, etc, which are not interesting from our privacy aware point of view.</p>
</li></ul><h2>Slave to the state</h2>
<div style="background-color:yellow;float:left;margin:1px"
    ><a href="https://youtu.be/wSjAOl2vQUU?t=86"><video autoplay muted loop
    style="width: 166px; height: 166px;"> <source
    src="../../../i/omb_22.mp4" type="video/mp4"
    /> No silly animated videos, good for you!</video></a></div><p>Another user friendly thing to implement would be state. At the moment clients can know their positions by asking, but we know not everybody is going to be online always at the same time. Let's say Alice… erm, <a href="https://en.wikipedia.org/wiki/Ah_Young">Ah Young</a> wants to meet with Bo… <a href="https://en.wikipedia.org/wiki/Bae_Woo-hee">Bae Woo-hee</a> to discuss future plans after the disbandment of <a href="https://en.wikipedia.org/wiki/Dal_Shabet">Dal Shabet</a>. Ah Young wants to share her position while traveling because she doesn't know yet if she's going to take the bus, the train, or if traffic is going to be ok, so she creates a session and shares it with Woo-hee using <a href="https://www.kakaocorp.com/service/KakaoTalk?lang=en">KakaoTalk</a> for her to be able to check periodically if she's going to show up at the door. The session is <span style="font-style: italic;">created</span>, but Woo-hee doesn't see the message for the next 15 minutes, and when she logs in, she is alone in the channel. What gives?</p>
<p>To prevent users from entering empty sessions, which as mentioned before are not distinguishable from expired links, we would like the server to store our last position, or a list of people who are known to be invited to the session. If we <span style="font-weight: bold;">do</span> control the software of the server, we can extend the public protocol to let the server store a chunk of binary encrypted information for each user. In its simplest form we could add to the normal <code>p</code> encrypted packet an optional field <code>store</code>, which set to true would tell the server to <span style="font-style: italic;">remeber</span> this packet and associate it to the user. Then, any user logging in could send a request to fetch all the stored information so far:</p>

<div style="background-color:yellow;float:right;margin:1px"
    ><a href="https://youtu.be/PpZgSXcQ3k8?t=137"><video autoplay muted loop
    style="width: 166px; height: 166px;"> <source
    src="../../../i/omb_23.mp4" type="video/mp4"
    /> No silly animated videos, good for you!</video></a></div><ul><li><p><code>{&quot;a&quot;: &quot;see_storage&quot;}</code>:</p>
<p>This message sent to the server would not be relayed to other users, instead it will trigger the server to flush to the client all the individually stored and encrypted messages. The client can decrypt them easily and get the last known position of users and see them on the map.</p>
</li></ul><p>In the case of the previous scenario, Woo-Hee would see the last position of Ah Young along with a time representing how fresh that position is, which could give here an approximate idea of where she is or how long it will take here to reach her. It is better than nothing, but still feels <span style="font-style: italic;">icky</span> because the server has a chunk of information and it knows it is very likely to be a position, which is what we are preventing to store. Also, if there are other data we would like to persist for the session, like a chat between users or the avatars (so that they don't log in to faceless avatars), we would end up with a very big chunk of encrypted data sent periodically to the server, since we can't update just a tiny bit of the whole encrypted data.</p>

<div style="background-color:yellow;float:left;margin:1px"
    ><a href="https://youtu.be/yw5xawWPDHI?t=87"><video autoplay muted loop
    style="width: 166px; height: 166px;"> <source
    src="../../../i/omb_24.mp4" type="video/mp4"
    /> No silly animated videos, good for you!</video></a></div><p>If we don't like that, or the server/backend we have selected doesn't allow any form or storage, we could store the state faking a server through a <span style="font-weight: bold;">persistent</span> client.  Chances are you are reading this on some kind of electronic medium, either a mobile, or a computer. Chances are you can also leave the computer connected to the internet downloading <a href="https://www.youtube.com/playlist?list=PL2HEDIx6Li8hDUxaa-0cLX2tNrx_brV7G">Kpop videos day and night</a>, or have an old mobile you haven't recycled yet because you might keep it as a back up of your current phone. In both cases these devices could join the session and perform the storage actions a trusted server would. In effect, they replace the server inside our encrypted communications channel.</p>
<p>The big advantage over using the server as storage is that the client emulating the storage has access to the encryption key. Thus, people sending their position don't need to identify their packets in any special way, the fake server will see them and store them. The previous <code>see_storage</code> command could also be more fine grained, maybe the client only wants to know the most recent positions, or maybe it wants to download the user information/avatar of somebody who has previously joined the session but is now not available. This fake server could also store the willingness to end the position broadcasting session, or purge it and disconnect after a set up time by the user creating the first session. If this fake server client advertises itself as such, new clients joining the session can by default upload their identity to it to be available to others even when they are not online.</p>
<h2>Out of marbles</h2>
<div style="background-color:yellow;float:right;margin:1px"
    ><a href="https://youtu.be/xxCmQa5zV_c?t=7"><video autoplay muted loop
    style="width: 166px; height: 166px;"> <source
    src="../../../i/omb_25.mp4" type="video/mp4"
    /> No silly animated videos, good for you!</video></a></div><p>At this point, regardless of how fun it is to use libsodium or how cool we feel for hiding our position to a third party using encryption, we are definitely running out of marbles. In fact, the next step to raise the ante would be to switch from symmetric encryption to public/private key encryption, like the <a href="https://threema.ch/en/faq/crypto_differences">paranoid guys at Threema</a>. Instead of trusting your secondary communication channel you would not trust that either, so you need each user to generate their public/private key and share them in a non online form previous to any online interaction.</p>
<p>But is this all necessary to share temporarily our position to a few people? Let's consider that mobile users are 99% likely to be using either iOS by Apple or Android by Google, and both report their position to <span style="font-style: italic;">the mothership</span>, for basic services like tracking the location of your phone in case it gets stolen and you want to recover it or push a message which obliterates its content. Or to know <span style="font-style: italic;">statistically</span> the chance of running into a traffic jam because many other Android phones are for some reason stopped in the middle of a highway in your path instead of travelling at their <span style="font-style: italic;">usual</span> speed.  When you dismiss without thought the <span style="font-style: italic;">daily cards</span> which remind you it's time to drive home and you should take a different route because <a href="https://www.youtube.com/watch?v=H9SnGn3oKps">there is a traffic jam</a>, isn't then a little bit paranoid to not trust a random company offering location sharing when you are already implicitly sharing your location with at least your operating system provider (and <a href="https://www.gsmarena.com/cia_nsa_fbi_chiefs_warn_against_buying_huawei_and_zte_phones-news-29618.php">who knows how many others in case of Android</a>)? Maybe you are one of the few who trust in the <a href="https://puri.sm/shop/librem-5/">Librem 5 phone</a>, which promises security and privacy? Or you installed a custom ROM on that Android provided by unknown people who you trust more than a corporation full of unknown people?</p>
<p>I think that designing servers, protocols, clients, and methods of communications where all the personal sensitive data is stored in different compartments helps in whatever failure cases you can think of (theft, impersonation, surveillance, etc), so it is legitimate to request providers to use the safest protocols or methods they can afford. But security and privacy are always a matter of trust, because you are still using that shiny Apple or Android phone, installing a binary compiled by somebody, who likely didn't read all the lines of code that went into it, and you need to trust somebody at some point anyway.  Instead of throwing away thousands at building a fictitious location sharing protocol running on third party servers it might be wiser and more economically viable to buy your own server and be done with all this crap.</p>
<p>Speaking of trust, I wouldn't trust the loonatic ramblings of somebody on the internet. Even less if that person tells you how to implement security while linking random weird things from time to time to confuse you. In an article published the 1st of April. Seriously, <a href="http://knowyourmeme.com/memes/these-are-not-the-droids-you-are-looking-for">these</a> <a href="https://www.youtube.com/watch?v=ShVRP09NCO4">aren't</a> <a href="https://www.youtube.com/watch?v=BIly131MSyQ">the</a> <a href="https://www.youtube.com/watch?v=KhZCNhUj4AI">droids</a> <a href="https://www.youtube.com/watch?v=4K4b9Z9lSwc">you're</a> <a href="https://www.youtube.com/watch?v=mjknp1nWGjY">looking</a> <a href="https://www.realdoll.com">for</a>.</p>
<pre class='literal'>$ nim c -r encrypt.nim too_many_secrets.doc
Please type your password to apply rot256 encryption:</pre>
	</div>
		<hr>
		<p>See <a href="../../../index.html">the article index</a> or browse
		articles by tags:     <a href="../../../tags/design.html">design</a>
    ,
    <a href="../../../tags/user-experience.html">user experience</a>
    ,
    <a href="../../../tags/programming.html">programming</a>
    
.<br>Published on: 01/04/2018 01:27. Last update:
			27/07/2018 00:26. <a
			href="../../../feed.xml"><img
			alt="rss feed" src="../../../i/Feed-icon.svg"
			width="18pt" height="18pt"></a><br>
		Copyright 2018 by <a href="../../../about.html">Grzegorz Adam Hankiewicz</a>.<br>
		Generated with <a href="https://github.com/dom96/ipsumgenera">ipsum
			genera</a>. Look at <a
		href="https://github.com/gradha/gradha.github.io">the
		source code</a>.</p>
	</body>
</html>
