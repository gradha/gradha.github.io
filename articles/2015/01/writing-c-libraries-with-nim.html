<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang='en'>
	<head>
		<title>Writing C libraries with Nim - Rants from the Ballmer Peak</title>
		<meta name="viewport" content="initial-scale=1, maximum-scale=1">
		<link rel="stylesheet" href="../../../css/normalize.css">
		<link rel="stylesheet" href="../../../css/style.css">
		<link href="../../../feed.xml" title="Articles" type="application/atom+xml" rel="alternate">
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	</head>
	<body>
	<div class="content">
		<h3><a href="../../../index.html">Rants from the Ballmer Peak</a> <a
				href="../../../feed.xml"><img
			alt="rss feed" src="../../../i/Feed-icon.svg"
			width="18pt" height="18pt"></a></h3>
		<h1>Writing C libraries with Nim</h1><h2>Context</h2><p>When you look at <a href="http://stackoverflow.com/questions/2746692/restructuredtext-tool-support">reStructuredText tool support</a> you can notice that with the main reference implementation being written in Python, all other implementations are in languages <span style="font-style: italic;">equal</span> or greater than Python: Java, Scala, Haskell, Perl, PHP, Nim. All these languages have in common that the programmer doesn't have to manage memory manually, and given the complexity of reStructuredText that doesn't seem to be a coincidence. This may have slowed down adoption of reStructuredText compared to <a href="http://daringfireball.net/projects/markdown/">Markdown</a>. Markdown started as a Perl script, but its simplicity led to <a href="https://github.com/hoedown/hoedown">many C libraries</a>, and even a <a href="http://commonmark.org">standarization attempt</a>, not without <a href="http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/">typical drama</a>. Wouldn't it be nice to have a C library for reStructuredText?</p>
<p>Since I dislike Python due to its brittleness and slow speed, I didn't want to use a Python solution for an <a href="https://en.wikipedia.org/wiki/Quick_Look">OS X Quick Look plugin</a>. I wrote <a href="https://github.com/gradha/quicklook-rest-with-nim">quicklook-rest-with-nim</a> which just takes the work done by the Nim developers in the <a href="https://github.com/Araq/Nim/blob/80b83611875383760da40d626a516e794e1245e7/lib/packages/docutils/rst.nim">rst</a>, <a href="http://nim-lang.org/docs/rstast.html">rstast</a> and <a href="http://nim-lang.org/docs/rstgen.html">rstgen</a> modules and packages it as a Quick Look renderer. Everything is statically linked, you can copy the plugin to any machine and it should run without any other runtime dependencies (note: <a href="https://github.com/gradha/quicklook-rest-with-nim/issues/48">some unknown bug</a> prevents it from working on Yosemite when installed in a home directory, but works fine form a system folder).</p>
<p>The Quick Look renderer is implemented using the default Objective-C Xcode template modifying it to call the Nim code through C bindings. That's when I realised the Nim implementation could be distributed as a plain C library for other languages to use, to avoid their pain rewriting the wheel or running shell commands. For the Quick Look plugin I was simply using two entry points exported to C with hard coded values, not acceptable to other people. I started then to move the custom Nim code to a separate module named <a href="https://github.com/gradha/lazy_rest">lazy_rest</a>.  Exposing directly the Nim API didn't make sense for several reasons, so first I <a href="http://gradha.github.io/lazy_rest/gh_docs/v0.2.2/lazy_rest.html">implemented a slightly different Nim API</a> which I think is nicer than the original, then proceeded to wrap it in a separate <a href="http://gradha.github.io/lazy_rest/gh_docs/v0.2.2/lazy_rest_c_api.html">C API module</a> which is really another Nim file wrapping all of its procs with the <a href="http://nim-lang.org/docs/manual.html#foreign-function-interface-exportc-pragma">exportc pragma</a>.</p>
<p>The project was successful, when I <a href="https://github.com/gradha/quicklook-rest-with-nim/issues/42">replaced the old rester module</a> with <code>lazy_rest</code> I dropped several brittle shell scripts and external nim compiler invocations from the project and simply dragged the C files into the Xcode project. This was pleasantly easy. The refactoring of the original reStructuredText modules into <a href="https://github.com/gradha/lazy_rest">lazy_rest</a> wasn't that easy though, I did hit some problems or annoyances. This post is going to enumerate the issues I found, in case you would like to make some other Nim module available to C users.</p>
<h2>Namespaces and identifiers</h2><p>Nim compiles to C, but most of the identifiers will have mangled C names you usually don't care about.  Looking at the code found in the <code>nimcache</code> directory you can get an idea of the mangling pattern (which is in any case not part of the public API and subject to change with each Nim version):</p>
<p><pre class='code'><span class="Identifier">…</span>
<span class="Identifier">N_NIMCALL</span><span class="Punctuation">(</span><span class="Identifier">NimStringDesc</span><span class="Operator">*</span><span class="Punctuation">,</span> <span class="Identifier">saferststringtohtml_235288</span><span class="Punctuation">)</span><span class="Punctuation">(</span><span class="Identifier">…</span>
<span class="Identifier">N_NIMCALL</span><span class="Punctuation">(</span><span class="Identifier">NimStringDesc</span><span class="Operator">*</span><span class="Punctuation">,</span> <span class="Identifier">saferstfiletohtml_235656</span><span class="Punctuation">)</span><span class="Punctuation">(</span><span class="Identifier">…</span>
<span class="Identifier">N_NIMCALL</span><span class="Punctuation">(</span><span class="Identifier">NimStringDesc</span><span class="Operator">*</span><span class="Punctuation">,</span> <span class="Identifier">sourcestringtohtml_235723</span><span class="Punctuation">)</span><span class="Punctuation">(</span><span class="Identifier">…</span>
<span class="Identifier">…</span>
</pre></p>
<p>The mangling is done to avoid having linker errors due to two symbols being named the same. Especially necessary for Nim where you can overload procs or have two procs named the same living in separate modules. When you use the <a href="http://nim-lang.org/docs/manual.html#foreign-function-interface-exportc-pragma">exportc pragma</a> the compiler won't mangle the name, so you have to pick a good unique one. The API of <code>lazy_rest</code> is really small, but still I decided to use the typical Objective-C pattern of prefixing all symbols with two letters.</p>
<h2>Memory handling</h2><p>Memory handling was obviously going to be a problem. C is managed manually, Nim has a garbage collector. Language bindings for any programming language always have these issues when the memory management is different, especially since the languages communicating are usually not aware of each other. Memory passed in from C to Nim is just a <a href="http://nim-lang.org/docs/manual.html#types-cstring-type">cstring</a>, that's fine because it can be converted to a Nim <code>string</code>. However, what do we do with a Nim proc which returns a <code>string</code> to C? Strings in Nim are implicitly convertible to <code>cstring</code> for convenience of C bindings, but what happens to their memory? Who handles that?</p>

<center>
<a href="http://arcturus127.tistory.com/831"><img
    src="../../../i/memory_handling.jpg" alt="Stuff is hard"
    style="width:100%;max-width:750px" align="center"
    hspace="8pt" vspace="8pt"></a>
</center><p>The manual mentions the built in procs <a href="http://nim-lang.org/docs/system.html#GC_ref">GC_ref()</a> and <a href="http://nim-lang.org/docs/system.html#GC_unref">GC_unref()</a> can be used to keep the string data alive. That means that the C code calling this API would have to know about freeing the memory too. Instead I decided to store the result in a global variable. This forces the string to not be freed even when calling other Nim code which could trigger a garbage collection, and it is easier on the C programmer for the common use of one shot reStructuredText transformations. Improvements can be reviewed in the future whenever <code>lazy_rest</code> gains a user base greater than one (me).</p>
<p>One thing worth mentioning here too is that conversions between <code>string</code> and <code>cstring</code> are <a href="https://github.com/Araq/Nim/issues/1577">not always correct</a>. A <code>nil</code> <code>string</code> won't convert to a <code>nil</code> <code>cstring</code>. One way to deal with this is <a href="https://github.com/gradha/badger_bits/blob/5dcc623d1fd5b8232a133370e068b1e3928f56bc/bb_system.nim#L135">wrapping the string to cstring conversion</a> to check explicitly for <code>nil</code>.</p>
<h2>Exporting types from the Nim standard library</h2><p>Part of the configuration/input options of <code>lazy_rest</code> are passed in through a <a href="http://nim-lang.org/docs/strtabs.html">StringTableRef</a>. These type was named <code>PStringTable</code> in Nimrod 0.9.6, and unfortunately <a href="https://github.com/Araq/Nim/issues/1579">it is not possible to export such symbols</a>.  The typical usage of this type is to store configuration options from a file or memory string, so instead I provided <a href="http://gradha.github.io/lazy_rest/gh_docs/v0.2.2/lazy_rest_c_api.html#lr_set_global_rst_options">lr_set_global_rst_options()</a>. C users can create an in memory string with the necessary configuration options and let the Nim code parse that.  Not very optimal, but this is not performance critical. Typically you will call this once before any other reStructuredText generation.</p>
<p>Something which could be a deal breaker for some people writing C libraries is the fact that <a href="https://github.com/Araq/Nim/issues/1189">Nim doesn't export type fields</a>. To work around this limitation you can export setters and getters. If your fields are primitive types this involves an extra function call, which doesn't look very appealing. For Nim types like strings you would have to implement the setters and getters anyway. The <code>lazy_rest</code> API I export is mostly an opaque render-and-forget approach to the many internal types used for parsing and rendering, so it wasn't a problem.</p>
<h2>Export enums and constants</h2><p>The Nim language doesn't allow <a href="https://github.com/Araq/Nim/issues/826">exporting enums or consts to C</a>. This is quite a bummer. For <code>lazy_rest</code> I did add the <a href="http://gradha.github.io/lazy_rest/gh_docs/v0.2.2/lazy_rest_pkg/lconfig.html">lconfig module</a> which contains several constants mapping to strings used for <code>StringTableRef</code> configuration objects. C users have to look at the documentation and duplicate their own hard coded strings.</p>
<p>I suggested at some point <a href="https://github.com/Araq/Nim/issues/905">adding an emit header pragma</a>. This pragma would work in a similar way to the <a href="http://nim-lang.org/docs/nimc.html#additional-features-emit-pragma">emit pragma</a> but instead of generating C code it would allow you to add lines to the final header generated by the Nim compiler. With such pragma I could write a macro to wrap all those constants and let them pass through to the compiler while at the same time generating extra header lines.</p>
<p>Recently Nim 0.10.2 was released and it also provides a way to write to a file from a macro. Macros happen at compile time, likely before any C header is generated, but I think a band aid for this issue could be to generate manually an additional C header in memory and write it to the <code>nimcache</code> directory. Maybe in the future I'll try this.</p>
<h2>Errors and exception handling</h2>
<a href="http://www.idol-grapher.com/1399"><img
    src="../../../i/nimc_exceptions.jpg"
    alt="Plus there is no API"
    style="width:100%;max-width:600px" align="right"
    hspace="8pt" vspace="8pt"></a><p>Exceptions are something else C doesn't have. Nim procs like <a href="http://gradha.github.io/lazy_rest/gh_docs/v0.2.2/lazy_rest.html#rst_string_to_html">rst_string_to_html()</a> will throw exceptions on error, so how does the C binding deal with that? The C API module uses <a href="http://nim-lang.org/docs/manual.html#effect-system">Nim's effect system</a> for exception tracking. All the procs are annotated with the <code>{.raises: [].}</code> pragma. This pragma tells the compiler that no exception should be raised out of the proc, if there is any potentially being raised the code won't compile, and you have to add the appropriate <code>try/except</code> combo somewhere to appease the compiler.</p>
<p>Annotating procs with this pragma was very satisfying because after doing so you realise how much stuff could potentially break. In other languages you are left with the uncertainty that something could break and you have no catch for it, which leads to typical <span style="font-style: italic;">catch-all</span> blocks in several points of the code, whether they are necessary or not. In Nim by default this could happen too, but the empty <code>raises</code> pragma helps you go through each possible error.</p>
<p>Thanks to this pragma I am confident there won't be any exception leaving the Nim domain. Such exceptions are treated for the C API as functions returning <code>NULL</code> instead of the expected value.  The errors are again stored in another Nim global variable, and you can retrieve them with helper functions ending in <code>_error</code> like <a href="http://gradha.github.io/lazy_rest/gh_docs/v0.2.2/lazy_rest_c_api.html#lr_rst_string_to_html_error">lr_rst_string_to_html_error()</a>.</p>
<h2>Callback exception tracking</h2><p>Things get trickier with exception tracking when you involve callbacks. The reStructuredText parser does have a callback to report warnings and errors to the user. This callback can just <code>echo</code> information to the user, but it can also raise an exception, aborting parsing. So you have a proc which uses a callback, and the proc itself has been protected with all sort of <code>try/except</code> blocks to keep the callback from causing trouble. The Nim compiler however disagrees, see this little snippet of code extracted from <a href="https://github.com/Araq/Nim/issues/1631">an issue I created</a>:</p>
<p><pre class='code'><span class="Keyword">proc</span> <span class="Identifier">noRaise</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">proc</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">try</span><span class="Punctuation">:</span> <span class="Identifier">x</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Keyword">except</span><span class="Punctuation">:</span> <span class="Keyword">discard</span>

<span class="Keyword">proc</span> <span class="Identifier">callbackWichRaisesHell</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">EIO</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">EIO</span><span class="Punctuation">,</span> <span class="StringLit">&quot;IO&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">use</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment"># doesn't compile even though nothing can be raised!</span>
  <span class="Identifier">noRaise</span><span class="Punctuation">(</span><span class="Identifier">callbackWichRaisesHell</span><span class="Punctuation">)</span>
</pre> This code looks and reads perfectly fine to me. Despite passing <code>callbackWichRaisesHell</code> around, the <code>noRaise()</code> proc won't ever raise anything, but the example won't compile.  It will compile if you add a wrapper layer around the callback, as Araq suggests in the GitHub issue, or if you remove the empty <code>raises</code> pragma from the <code>use()</code> declaration (but that was the point of using the pragma). The reported issue was closed, meaning it's OK to have to patch correct code. I don't know yet if patching good code being the correct answer to a problem is more sad than having a compiler unable to reason about a ten line program.</p>
<p>In any case this wasn't a problem for the library, since I wanted the callbacks to be usable from C there wasn't any point in making them raise exceptions (how would you raise a Nim exception from C code?). I simply modified the <a href="http://gradha.github.io/lazy_rest/gh_docs/v0.2.2/lazy_rest_pkg/lrst.html#TMsgHandler">TMsgHandler</a> callback type to raise nothing and instead return the possible error as a non nil string. This avoided the problem of callbacks raising any exceptions.</p>
<p><a href="https://www.youtube.com/watch?v=RztfjHdM-pg">Pig and elephant DNA just won't splice</a>, so know also that callbacks and exception tracking have issues together.</p>

<br clear="right"><h2>Threads</h2>
<a href="http://dijkcrayon.tistory.com/297"><img
    src="../../../i/nimc_threads.jpg" alt="Threads are terrible"
    style="width:100%;max-width:600px" align="right"
    hspace="8pt" vspace="8pt"></a><p>Parsing and generating HTML from text is pretty much sequential, you can't start generating HTML for a random part of the document because the previous part could modify its meaning. But we have multi processor machines everywhere, so I thought it would be nice to provide a queue like API where you pass all the files or strings you need to process (e.g. results of scanning the file system) and let the multiple processors do their job, returning all the results.</p>
<p>I started the <a href="https://github.com/gradha/lazy_rest/blob/50738869005675b99b039516e8a6031ddf151972/lazy_rest_pkg/lqueues.nim">lqueues module</a> but couldn't get much done so I've left it disabled. I've done threading in C, Java, Objective-C, and after the initial problems grasping deadlocks and race conditions, nowadays I seem to be able to write at least non crashing code. But I couldn't get Nim to do the same. My biggest gripe was with the fact that threads can't touch other thread's variables, so they have to communicate through shared globals. Or use channels/actors which presumably are not the right solution (couldn't get the expected performance gains from them, but at least they didn't crash).</p>
<p>Now that Nim 0.10.2 has been released there is hope in the new <a href="http://nim-lang.org/docs/manual.html#parallel-spawn">parallel and spawn statements</a>, so I should try that soon. Still, I don't understand what's the presumable benefit of having threads unable to mutate state from other threads. To me it seems more like it's easier to implement concurrency with immutable state, but then, all the other languages I've worked with have mutability and they work perfectly fine.</p>
<p>I don't think it's coincidence that there is pretty much zero Nim threaded code out there being written outside of a few very specific cases. Again, not something I'm worried now, but raises some questions for future work. At the moment I can't see myself using Nim for GUI programming because all the asynchronous patterns I know work with explicit mutability in mind. Neither the new <code>parallel</code> and <code>spawn</code> statements nor <code>async</code> seem to be oriented for GUI programming where you require callbacks for progress indication (and this has to happen on the main thread, aka GUI thread) or cancellation.  Time to learn new tricks I guess, maybe Nim is just so superior in this area I'm unable to see the benefits yet. &lt;insert needs-enlightment-here&gt;</p>

<br clear="right"><h2>Conclusion</h2><p>From the point of view of C library consumers, this project mostly works and is viable. Users can go to the <a href="https://github.com/gradha/lazy_rest/releases">lazy_rest releases section</a>, download the pre generated C sources packages and use without having to install or even know about Nim. For generic C API libraries only the exportation of enums, constants and type fields seems to be a glaring problem because mostly everybody will hit it. Fortunately it doesn't seem to be hard to fix. As more Nim users try to export their Nim code with a C API there will be more interest in fixing or improving these issues.  And maybe in the not so distant future it will make sense to use Nim as a perfect replacement for C when you want to write reusable libraries for C users, or other languages using C bindings.</p>
<pre class='literal'>$ nim c -r complex_callbacks.nim
complex_callbacks.nim(9, 21) Info: instantiation from here
complex_callbacks.nim(6, 41) Error: can raise an unlisted exception: IOError</pre>
	</div>
		<hr>
		<p>See <a href="../../../index.html">the article index</a> or browse
		articles by tags:     <a href="../../../tags/languages.html">languages</a>
    ,
    <a href="../../../tags/programming.html">programming</a>
    ,
    <a href="../../../tags/nim.html">nim</a>
    ,
    <a href="../../../tags/nimrod.html">nimrod</a>
    
.<br>Published on: 14/01/2015 22:59. Last update:
			02/08/2015 15:01. <a
			href="../../../feed.xml"><img
			alt="rss feed" src="../../../i/Feed-icon.svg"
			width="18pt" height="18pt"></a><br>
		Copyright 2016 by <a href="../../../about.html">Grzegorz Adam Hankiewicz</a>.<br>
		Generated with <a href="https://github.com/dom96/ipsumgenera">ipsum
			genera</a>. Look at <a
		href="https://github.com/gradha/gradha.github.io">the
		source code</a>.</p>
	</body>
</html>
