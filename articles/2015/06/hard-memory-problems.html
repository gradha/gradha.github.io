<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang='en'>
	<head>
		<title>Hard memory problems - Rants from the Ballmer Peak</title>
		<meta name="viewport" content="initial-scale=1, maximum-scale=1">
		<link rel="stylesheet" href="../../../css/normalize.css">
		<link rel="stylesheet" href="../../../css/style.css">
		<link href="../../../feed.xml" title="Articles" type="application/atom+xml" rel="alternate">
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	</head>
	<body>
	<div class="content">
		<h3><a href="../../../index.html">Rants from the Ballmer Peak</a> <a
				href="../../../feed.xml"><img
			alt="rss feed" src="../../../i/Feed-icon.svg"
			width="18pt" height="18pt"></a></h3>
    <!--table border="0" bgcolor="#cccccc"><tr><td><i>Need a great Android/KMP developer? <a href="https://www.linkedin.com/in/gradha/">Hire me!</a></i>
    </table><br-->
		<h1>Hard memory problems</h1>
<a href="https://instagram.com/p/vzWU8iSB9B/"><img
    src="../../../i/crayon_pop_explain.jpg"
    alt="Endless pit of patience"
    style="width:100%;max-width:320px" align="right"
    hspace="8pt" vspace="8pt"></a><p>The conclusion of <a href="../../2013/10/40-years-later-we-still-cant-be-friends.html">one of my previous articles</a> might have led you to believe nobody cares about new better ways of sharing the CPU for end users. That's correct, but still solvable for many scenarios through libraries like <a href="https://en.wikipedia.org/wiki/Grand_Central_Dispatch">Grand Central Dispatch (GCD)</a>, so it is a matter of time until the rest of the industry drags their feet forward. The problem we really haven't solved is about memory.  From a practical point of view, the CPU is <span style="font-style: italic;">sort of</span> infinite if we look into the dimension of time: no current time slice for my starved process? OK, let's just wait a few clock ticks more until we can run. On the other hand, if a process gets any amount of memory, that memory is lost, completely gone and impossible to recover for any other process on the machine. In weird situations even the original owner of the memory may be unable to recover it! Why? What did we do to deserve this punishment?</p>
<h2>Memento fragmentation</h2><p>Allocation of <a href="http://en.wikipedia.org/wiki/C_dynamic_memory_allocation">dynamic memory</a> is still done today through a very simple interface. When you want a chunk of memory, you call <a href="http://man7.org/linux/man-pages/man3/malloc.3.html">malloc() and later free()</a>. If you are not using C, your language may provide a different set of primitives, like <a href="https://en.wikipedia.org/wiki/New_(C%2B%2B)">new and delete in C++</a>, but the basic idea is you ask for a chunk of memory, and you later free this chunk of memory. Higher level languages with <span style="font-style: italic;">managed memory</span>, usually implementing a <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">garbage collector</a>, alleviate the programmer from doing this task manually but it still exists there, it's just a little bit hidden.</p>
<p>In any case, the OS has to keep track of what cells in the whole hardware memory are free to use. And there is always a trade-off between precision of what byte belongs to whom, and space efficiency. Usually the OS will subdivide the hardware memory in blocks. Even lower level, the hardware itself might be able to provide memory to the OS only at the <span style="font-style: italic;">page</span> granularity of say 1KB or 4KB. Programs have complex memory allocation patterns. If the program allocates different chunks, and frees one of them, the remaining chunks may prevent the shared memory block from being freed, and even make it not usable for future memory requests. This is called <a href="https://en.wikipedia.org/wiki/Fragmentation_(computing)">memory fragmentation</a>.</p>
<p>Let's say that the OS imposes memory boundaries of 1KB and you request a <code>malloc()</code> chunk of 1500 bytes. That will use two pages of memory. Depending on how clever the OS wants to be, the remaining bytes of the second page might be unable to other <code>malloc()</code> requests. In this situation, your process is effectively losing <code>2048 - 1500 = 548</code> bytes. If the OS is <span style="font-style: italic;">clever</span>, let's say that it allows you to reuse this space. So we start again with a reserve of 1500 bytes, and get two pages.  Now we request another 1500 bytes, and the OS being clever gives us one page more, with the second allocation starting right at the end of the first one.  This is very nice, from the three pages of 1024 bytes we are losing only <code>(1024 * 3) - (1500 * 2) = 72</code> bytes. Now the question is, what happens when the first <code>malloc()</code> is freed? Only the first page can be freed. But more importantly, what if we now want to <code>malloc()</code> 10KB? The OS is unable to give us that first page, because it is not contiguous to the other ones we need. Hence, we get a contiguous block of pages <span style="font-style: italic;">after</span> the third page. We have fragmented our own free memory, the first hardware page is free, but we are not getting it.</p>
<p>Memory allocators are always tricky software to write. Maybe one of the most famous ones is the one by <a href="http://g.oswego.edu/dl/html/malloc.html">Doug Lea</a>. That page has a lot of juicy information, you can read it to get an idea about many more problems memory allocators have to deal with. I love to rant on the problem of sharing memory between languages inside the same process.</p>
<h2>Sharing is caring</h2>
<a href="https://instagram.com/p/1hAndMyB2u/"><img
    src="../../../i/crayon_pop_sharing.jpg"
    alt="Gangsta sharing"
    style="width:100%;max-width:320px" align="right"
    hspace="8pt" vspace="8pt"></a><p>The memory interface is very minimal, and once a program has hold of a memory block, the OS guarantees that this block will be available forever to the program at that specific memory address. Since most programming languages are based on the idea of pointers, the OS is not able to <span style="font-style: italic;">move</span> or reshuffle this block of memory because somewhere a variable might still point to the old <span style="font-weight: bold;">address</span>. Moving this memory around could lead to crashes when this variable/pointer is later used to read or write to memory.</p>
<p>In summary, dynamic memory handling in most programming languages is tied to these two very basic restrictions, which are not the fault of the language but of the foundation OSes provide:</p>
<ol><li>The OS doesn't have any idea what the memory is going to be used for, or for how long.</li><li>Once provided, the OS is unable to move this memory later due to guarantees to its physical address.</li></ol><p>How many times have you written software that depended on these restrictions being valid? Never? Unless you are writing some kind of <a href="https://en.wikipedia.org/wiki/Direct_memory_access">DMA level</a> software, kernel, audio/video streaming interface, or similar piece of software which is <span style="font-style: italic;">really</span> restricted by the hardware, you are unlikely to ever care <span style="font-weight: bold;">where</span> the memory is allocated, or if it actually stays <span style="font-weight: bold;">there</span> much later. Most software developers only care about memory being available or not. If there is not enough, the program just gives up and asks the user to buy more. Still, OSes are tied to this basic interface since the beginning of time. So you end up with the problem we described earlier for pages but at the level of whole processes.</p>
<h2>Memory boundaries</h2><p>If memory issues are already bad between a process and the OS, you have additional barriers when you want to produce software which involves two or more different programming languages. Some time ago I started writing <a href="http://pyallegro.sourceforge.net/alpy.php">AlPy</a>, a small binding between Python and <a href="http://alleg.sourceforge.net">Allegro</a>. Since Allegro is a C library, you deal with creation and destruction of bitmaps manually. In Python land, you rarely if ever notice memory allocation, it is automatic. And there are two ways to write a binding for Python: you either make memory allocation explicit to the Python programmer, or you make it implicit.</p>
<p>An explicit interface would mean that the user creates some <code>Bitmap</code> placeholder object in Python land, and before using it another initialization method has to be called on it to reserve the appropriate amount of memory (which would call the C function).  Later when the user is done with the object another method is called, and the associated memory is freed, despite the Python placeholder still being alive and kicking. An implicit interface would let Python users to create freely as much <code>Bitmap</code> objects as they want, and only usage of these objects would trigger allocations (and later deallocation when the Python object is deleted). The disadvantage of this method is that memory allocation/freeing is a potentially expensive operation you might want to control.</p>

<br clear="right"><center>
<a href="https://instagram.com/p/ybmONSGosR/"><img
    src="../../../i/kpop_interracial.jpg"
    alt="Jake Pains"
    style="width:100%;max-width:750px" align="center"
    hspace="8pt" vspace="8pt"></a>
</center><p>In any of these cases, it is possible that objects created at the Python level which are not necessary any more, but haven't been collected, may prevent newer objects to be allocated. Let's say that you implement the kind of binding where the low level memory allocation happens automatically behind the user's back. Users might want to happily write a loop where they process all the files in a directory to load them, perform some tweaking on them, then save them to disk. It could happen that the memory allocated by the <code>Bitmap</code> objects in one iteration of the loop is not freed immediately. The next iteration allocates more memory, and so on. When you look at such software in a memory debugger you see the memory growing in steps and suddenly drop when the loop finishes and all the temporary objects can be released at the same time.</p>
<p>Let's twist this a little bit more. In Python it is frequent to cache the result of expensive operations. Maybe you want to load an image, perform some operations and store the final result in a dictionary. If the software has to come back to this image, rather than doing all the operations again, you can retrieve the cached image from the dictionary. Users love this because their interaction is immediate. But how do you make Python and C libraries cooperate? The solution is to delegate memory allocation from both actors into a separate third party. Instead of C or Python calling <code>malloc()</code> directly, you write a separate memory cache library. This library will perform their <code>malloc()</code> and <code>free()</code>. But now when the Python (or C library) code wants to cache something, it can mark a bitmap as a <a href="https://en.wikipedia.org/wiki/Weak_reference">weak reference</a>. These objects go into a separate pool. If a new <code>malloc()</code> comes in and the OS doesn't have any more free memory, the cache library can look through the pool of weak objects and free one or more of them before giving up.</p>
<p>One interesting artifact of how memory is shared between languages shows its ugly head to Android programmers when they deal with images. If you take a brief look at <a href="http://square.github.io/picasso/">Square's Picasso library</a> and look at the custom image transformations example, look at the following depressing lines:</p>
<p><pre class='code'><span class="Identifier">Bitmap</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">Bitmap</span><span class="Punctuation">.</span><span class="Identifier">createBitmap</span><span class="Punctuation">(</span><span class="Identifier">source</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">size</span><span class="Punctuation">,</span> <span class="Identifier">size</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
<span class="Keyword">if</span> <span class="Punctuation">(</span><span class="Identifier">result</span> <span class="Operator">!=</span> <span class="Identifier">source</span><span class="Punctuation">)</span> <span class="Punctuation">{</span>
    <span class="Identifier">source</span><span class="Punctuation">.</span><span class="Identifier">recycle</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
<span class="Punctuation">}</span>
</pre></p>
<p>Any ideas about what <code>recycle()</code> does? Depending on the Android version, <a href="https://developer.android.com/training/displaying-bitmaps/manage-memory.html">bitmap memory is managed in a different way</a>, and the call to <code>recycle()</code> <span style="font-style: italic;">helps</span> to avoid running out of memory because the Java <code>Bitmap</code> object is separate from it's native memory storage, causing a similar situation to what I described earlier, a Python object preventing a C malloc'ed image from being freed at the appropriate time. The documentation says this is only for older Android versions, but I suspect the implementation of <code>recycle()</code> is still used in newer ones to signal the OS that most of the backing memory for the Bitmap can be used for something else at that moment. In fact, if it weren't really necessary, wouldn't they <span style="font-style: italic;">deprecate</span> that API? Huh? <span style="font-style: italic;">Unneeded</span> APIs still in use by the most popular image libraries out there… sounds like <a href="https://en.wikipedia.org/wiki/Cargo_cult_programming">sane design</a>. Or maybe not?</p>
<h2>Running parallelly with scissors</h2>
<a href="https://instagram.com/p/sKU6jvyB0J/"><img
    src="../../../i/crayon_pop_listens.jpg"
    alt="Don't want to hurt your feelings"
    style="width:100%;max-width:320px" align="right"
    hspace="8pt" vspace="8pt"></a><p>This is all a little bit tedious, but doable if all the parties agree on the mechanism to control memory (aka: not gonna happen). How do you extend this among separate processes? In an ideal world we would like to have the user open an image browser. The first time the image browser is loaded all the images in a specific directory are loaded and cached in memory (four rows of five images, each 20 mega pixels in size, or about 80 MB of uncompressed memory, for a total of 1.5GB of RAM required to have them all loaded at once). After browsing some of them, maybe editing them (more memory for undo required!) the user hears a sound and receives a new email. The email prompts to <a href="https://www.youtube.com/watch?v=YR92tv29pFU&amp;spfreload=10">watch some youtube video</a>.  Without closing the photo software the user opens the web browser to see a streaming video equivalent to about 150 or 200 MB file. With the video being in Full HD, each frame takes about 8MB of RAM. Not much, but still some frames might be buffered for smoother playback.</p>
<p>Even on a machine with just 2GB of RAM this is all doable without problems. But what happens if there are more images on screen? What if the pictures the user is handling have higher resolution? What if we would like the video player to have caching and not have to download or uncompress parts of the stream again if the user clicks a few seconds back on the playback bar to watch again the video? All these <span style="font-style: italic;">niceties</span> increase the memory usage. Programs don't have mechanisms to tell the OS &quot;<span style="font-style: italic;">oh well, I want memory for these images, but the user has not accessed to them in a while, so maybe you can purge them if their memory is needed for something else</span>&quot;.  At the moment the closest thing to this are two mechanisms available in mobile operating systems, which are leading advances in memory sharing due to their low hardware resources compared to desktop machines:</p>
<ol><li>Provide mechanism for the OS to request cache memory from applications.</li><li>Make memory handling opaque to the programmer through proxies, so it can be freed and recovered at certain points during execution.</li></ol><p>In the first category there are methods like Android's <a href="http://developer.android.com/reference/android/app/Application.html#onLowMemory%28%29">Application.onLowMemory()</a> which is called when the overall system is running low on memory, and actively running processes have to trim their memory usage. On iOS there are similar methods like <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplicationDelegate_Protocol/index.html#//apple_ref/occ/intfm/UIApplicationDelegate/applicationDidReceiveMemoryWarning:">applicationDidReceiveMemoryWarning:</a>. It is worth noting though that methods like <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewController_Class/index.html#//apple_ref/occ/instm/UIViewController/viewDidUnload">UIViewController.viewDidUnload</a> have actually been deprecated! I remember watching a WWDC video session where they explained this method was removed because… people weren't using it properly causing more crashes than helping out, and anyway most of the memory was reclaimed through other means (a quick search says this was a <a href="http://stackoverflow.com/a/12509381/172690">WWDC 2012 session named Evolution of view controllers</a>). Interesting, isn't it?</p>
<p>Actually, that &quot;<span style="font-style: italic;">through other means</span>&quot; leads us to the next next category, which is using proxy elements instead of letting programmer's filthy fingers touch directly any RAM. In both Android and iOS this happens through the classes used to display images. Think about it, most of the time when mobile developers build a user interface they are only <span style="font-style: italic;">connecting</span> resources with objects controlling their appearance on the screen. Meaning, I want the data contain by this specific filename be displayed at this particular position on the screen with these resizing properties and relations to other visual objects.  And for this reason, when one of these mobile applications is interrupted and goes to the background, since the program is <span style="font-style: italic;">not really</span> touching any of the memory, the OS can actually free the memory used by all those user interface bitmaps, and when the app comes back to the foreground it can reload the resources associated with them.</p>
<p>For generic objects, programmers in Java can use a <a href="http://developer.android.com/reference/java/lang/ref/WeakReference.html">WeakReference</a>. iOS developers can use <a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/NSCache_Class/">NSCache</a>. The unfortunate side of these APIs is that nobody uses them. They are somehow awkward to use, and I've come to see zero usages of them in other people's code. I have used them myself only once or twice.</p>
<p>As for the first category, the idea of memory being released when the OS asks for it is nice until you realise it is all a lie. You see, the OS is allowed to call those methods only when <span style="font-weight: bold;">you</span> are in the foreground. So if you build an app which keeps big data structures (not using those specific cache aware APIs) and the user switches to another one… you are out of luck, the OS won't call those methods again. Why? Well, imagine the performance of your app if when memory is scarce the OS starts running <span style="font-style: italic;">other apps' code</span> in the <span style="font-style: italic;">hope</span> that they can free some memory (and hopefully none of those other apps attempt to run anything that causes <span style="font-weight: bold;">more</span> memory to be allocated, like, maybe be <span style="font-style: italic;">evil</span> and request some network resource while they got some CPU to play with). What you end up realizing is that if you <span style="font-weight: bold;">really</span> want to be a good neighbour to other running apps you have to essentially flush yourself your caches <span style="font-weight: bold;">before</span> being pushed to the background while you are still running, or risk being killed due to an <a href="http://www.oracle.com/technetwork/articles/servers-storage-dev/oom-killer-1911807.html">out of memory</a> situation if the future foreground app tries to allocate memory.  And the number of mobile programmers who do this is… (depressing answer left as an exercise for the reader).</p>
<h2>Conclusion</h2>
<a href="https://instagram.com/p/v8Skk3yB1Z/"><img
    src="../../../i/crayon_pop_christmas.jpg"
    alt="Gangsta sharing"
    style="width:100%;max-width:320px" align="right"
    hspace="8pt" vspace="8pt"></a><p>While a lot has been written about memory allocation and fragmentation prevention techniques (like <a href="https://en.wikipedia.org/wiki/Region-based_memory_management">regions</a>, quite popular in video games for level loading), the problems of sharing memory between different processes, or sharing memory between different languages running in the same process are rarely talked about because they fall out of the domain of a single stakeholder. Memory fragmentation is easier to deal with because it is <span style="font-style: italic;">yours</span>. Memory sharing with other processes? Meh, it's <span style="font-style: italic;">their</span> fault. Don't expect any improvements in this area in your lifetime, at least until programming languages don't incorporate memory sharing primitives in their languages (or make memory sharing proxies transparent, which is the most realistic solution as proved by mobile platforms).</p>
<p>Some of the examples described here may look alien to you, especially if you work on desktops or servers which have comparatively huge quantities of memory resources compared to mobile or (gosh!) <span style="font-style: italic;">real</span> embedded systems (no, mobiles today are just little desktops). If so, you can take a look at the short 5 minute video <a href="https://www.youtube.com/watch?v=x8Hddx1eOZo">Trimming and Sharing Memory (Android Performance Patterns Season 3 ep5)</a> which puts the ideas here into context on Android. For a longer video, look at <a href="https://developer.apple.com/videos/play/wwdc2015-212/">Optimizing Your App for Multitasking on iPad in iOS 9</a> which explains the growing difficulties of memory sharing in newer iOS version supporting multitasking. The idea of storing uncompressed resources as <a href="http://man7.org/linux/man-pages/man2/mmap.2.html">mmap'ed memory</a> reminds me a lot of <a href="https://en.wikipedia.org/wiki/MegaTexture">Doom3's megatexture</a> techniques.</p>
<p>Where is your OS helping you write applications when application developers have to handle the memory hierarchy themselves, huh?  And now, get back to your <code>malloc()</code> and <code>free()</code>!</p>

<br clear="right">
	</div>
		<hr>
		<p>See <a href="../../../index.html">the article index</a> or browse
		articles by tags:     <a href="../../../tags/multitasking.html">multitasking</a>
    ,
    <a href="../../../tags/user-experience.html">user-experience</a>
    
.<br>Published on: 14/06/2015 20:05. Last update:
			19/01/2016 21:08. <a
			href="../../../feed.xml"><img
			alt="rss feed" src="../../../i/Feed-icon.svg"
			width="18pt" height="18pt"></a><br>
		Copyright 2025 by <a href="../../../about.html">Grzegorz Adam Hankiewicz</a>.<br>
		Generated with <a href="https://github.com/dom96/ipsumgenera">ipsum
			genera</a>. Look at <a
		href="https://github.com/gradha/gradha.github.io">the
		source code</a>.</p>
	</body>
</html>
